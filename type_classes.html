<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>10. Type Classes &#8212; Theorem Proving in Lean 3 (outdated) 3.23.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=5ca61e87" />
    <script src="_static/documentation_options.js?v=5de50469"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="11. Axioms and Computation" href="axioms_and_computation.html" />
    <link rel="prev" title="9. Structures and Records" href="structures_and_records.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="type-classes">
<span id="id1"></span><h1><span class="section-number">10. </span>Type Classes<a class="headerlink" href="#type-classes" title="Link to this heading">&#182;</a></h1>
<p>We have seen that Lean&#8217;s elaborator provides helpful automation, filling in information that is tedious to enter by hand. In this section we will explore a simple but powerful technical device known as <em>type class inference</em>, which provides yet another mechanism for the elaborator to supply missing information.</p>
<p>The notion of a <em>type class</em> originated with the <em>Haskell</em> programming language. In that context, it is often used to associate operations, like a canonical addition or multiplication operation, to a data type. Many of the original uses carry over, but, as we will see, the realm of interactive theorem proving raises even more possibilities for their use.</p>
<section id="type-classes-and-instances">
<h2><span class="section-number">10.1. </span>Type Classes and Instances<a class="headerlink" href="#type-classes-and-instances" title="Link to this heading">&#182;</a></h2>
<p>Any family of types can be marked as a <em>type class</em>. We can then declare particular elements of a type class to be <em>instances</em>. These provide hints to the elaborator: any time the elaborator is looking for an element of a type class, it can consult a table of declared instances to find a suitable element.</p>
<p>More precisely, there are three steps involved:</p>
<ul class="simple">
<li><p>First, we declare a family of inductive types to be a type class.</p></li>
<li><p>Second, we declare instances of the type class.</p></li>
<li><p>Finally, we mark some implicit arguments with square brackets instead of curly brackets, to inform the elaborator that these arguments should be inferred by the type class mechanism.</p></li>
</ul>
<p>Let us start with a simple example. Many theorems hold under the additional assumption that a type is inhabited, which is to say, it has at least one element. For example, if <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is a type, <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code> is true only if <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is inhabited. Similarly, it often happens that we would like a definition to return a default element in a &#8220;corner case.&#8221; For example, we would like the expression <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">l</span></code> to be of type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> when <code class="docutils literal notranslate"><span class="pre">l</span></code> is of type <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">&#945;</span></code>; but then we are faced with the problem that <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">l</span></code> needs to return an &#8220;arbitrary&#8221; element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> in the case where <code class="docutils literal notranslate"><span class="pre">l</span></code> is the empty list, <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</p>
<p>The standard library defines a type class <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">&#8594;</span> <span class="pre">Type</span></code> to enable type class inference to infer a &#8220;default&#8221; or &#8220;arbitrary&#8221; element of an inhabited type. In the example below, we use a namespace <code class="docutils literal notranslate"><span class="pre">hidden</span></code> as usual to avoid conflicting with the definitions in the standard library.</p>
<p>Let us start with the first step of the program above, declaring an appropriate class:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Aclass%20inhabited%20(%CE%B1%20%3A%20Type%20_)%20%3A%3D%0A(default%20%3A%20%CE%B1)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">_</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The command <code class="docutils literal notranslate"><span class="pre">class</span></code> above is shorthand for</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0A%40%5Bclass%5D%20structure%20inhabited%20(%CE%B1%20%3A%20Type%20_)%20%3A%3D%0A(default%20%3A%20%CE%B1)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">@[</span><span class="n">class</span><span class="kd">]</span><span class="w"> </span><span class="kd">structure</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">_</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>An element of the class <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">&#945;</span></code> is simply an expression of the form <code class="docutils literal notranslate"><span class="pre">inhabited.mk</span> <span class="pre">a</span></code>, for some element <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>. The projection <code class="docutils literal notranslate"><span class="pre">inhabited.default</span></code> will allow us to &#8220;extract&#8221; such an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> from an element of <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">&#945;</span></code>.</p>
<p>The second step of the program is to populate the class with some instances:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Ainstance%20Prop_inhabited%20%3A%20inhabited%20Prop%20%3A%3D%0Ainhabited.mk%20true%0A%0Ainstance%20bool_inhabited%20%3A%20inhabited%20bool%20%3A%3D%0Ainhabited.mk%20tt%0A%0Ainstance%20nat_inhabited%20%3A%20inhabited%20nat%20%3A%3D%0Ainhabited.mk%200%0A%0Ainstance%20unit_inhabited%20%3A%20inhabited%20unit%20%3A%3D%0Ainhabited.mk%20()%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">Prop_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="n">inhabited.mk</span><span class="w"> </span><span class="n">true</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">bool_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="o">:=</span>
<span class="n">inhabited.mk</span><span class="w"> </span><span class="n">tt</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">nat_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span>
<span class="n">inhabited.mk</span><span class="w"> </span><span class="mi">0</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">unit_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">:=</span>
<span class="n">inhabited.mk</span><span class="w"> </span><span class="o">()</span>
</pre></div>
</div>
</div><p>In the Lean standard library, we regularly use the anonymous constructor when defining instances. It is particularly useful when the class name is long.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Ainstance%20Prop_inhabited%20%3A%20inhabited%20Prop%20%3A%3D%0A%E2%9F%A8true%E2%9F%A9%0A%0Ainstance%20bool_inhabited%20%3A%20inhabited%20bool%20%3A%3D%0A%E2%9F%A8tt%E2%9F%A9%0A%0Ainstance%20nat_inhabited%20%3A%20inhabited%20nat%20%3A%3D%0A%E2%9F%A80%E2%9F%A9%0A%0Ainstance%20unit_inhabited%20%3A%20inhabited%20unit%20%3A%3D%0A%E2%9F%A8()%E2%9F%A9%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">Prop_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">true</span><span class="o">&#10217;</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">bool_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">tt</span><span class="o">&#10217;</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">nat_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">0</span><span class="o">&#10217;</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">unit_inhabited</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;()&#10217;</span>
</pre></div>
</div>
</div><p>These declarations simply record the definitions <code class="docutils literal notranslate"><span class="pre">Prop_inhabited</span></code>, <code class="docutils literal notranslate"><span class="pre">bool_inhabited</span></code>, <code class="docutils literal notranslate"><span class="pre">nat_inhabited</span></code>, and <code class="docutils literal notranslate"><span class="pre">unit_inhabited</span></code> on a list of instances. Whenever the elaborator is looking for a value to assign to an argument <code class="docutils literal notranslate"><span class="pre">?M</span></code> of type <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">&#945;</span></code> for some <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, it can check the list for a suitable instance. For example, if it looking for an instance of <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">Prop</span></code>, it will find <code class="docutils literal notranslate"><span class="pre">Prop_inhabited</span></code>.</p>
<p>The final step of the program is to define a function that infers an element <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">inhabited</span> <span class="pre">&#945;</span></code> and puts it to good use. The following function simply extracts the corresponding element <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Adef%20default%20(%CE%B1%20%3A%20Type*)%20%5Bs%20%3A%20inhabited%20%CE%B1%5D%20%3A%20%CE%B1%20%3A%3D%0A%40inhabited.default%20%CE%B1%20s%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">@</span><span class="n">inhabited.default</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">s</span>
</pre></div>
</div>
</div><p>This has the effect that given a type expression <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, whenever we write <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">&#945;</span></code>, we are really writing <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">&#945;</span> <span class="pre">?s</span></code>, leaving the elaborator to find a suitable value for the metavariable <code class="docutils literal notranslate"><span class="pre">?s</span></code>. When the elaborator succeeds in finding such a value, it has effectively produced an element of type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, as though by magic.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Adef%20default%20(%CE%B1%20%3A%20Type*)%20%5Bs%20%3A%20inhabited%20%CE%B1%5D%20%3A%20%CE%B1%20%3A%3D%0A%40inhabited.default%20%CE%B1%20s%0A--%20BEGIN%0A%23check%20default%20Prop%20%20--%20Prop%0A%23check%20default%20nat%20%20%20--%20%E2%84%95%0A%23check%20default%20bool%20%20--%20bool%0A%23check%20default%20unit%20%20--%20unit%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="kt">Prop</span><span class="w">  </span><span class="c1">-- Prop</span>
<span class="k">#check</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">nat</span><span class="w">   </span><span class="c1">-- &#8469;</span>
<span class="k">#check</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">bool</span><span class="w">  </span><span class="c1">-- bool</span>
<span class="k">#check</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">unit</span><span class="w">  </span><span class="c1">-- unit</span>
</pre></div>
</div>
</div><p>In general, whenever we write <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">&#945;</span></code>, we are asking the elaborator to synthesize an element of type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.</p>
<p>Notice that we can &#8220;see&#8221; the value that is synthesized with <code class="docutils literal notranslate"><span class="pre">#reduce</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Adef%20default%20(%CE%B1%20%3A%20Type*)%20%5Bs%20%3A%20inhabited%20%CE%B1%5D%20%3A%20%CE%B1%20%3A%3D%0A%40inhabited.default%20%CE%B1%20s%0A--%20BEGIN%0A%23reduce%20default%20Prop%20%20--%20true%0A%23reduce%20default%20nat%20%20%20--%200%0A%23reduce%20default%20bool%20%20--%20ff%0A%23reduce%20default%20unit%20%20--%20()%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="kt">Prop</span><span class="w">  </span><span class="c1">-- true</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">nat</span><span class="w">   </span><span class="c1">-- 0</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">bool</span><span class="w">  </span><span class="c1">-- ff</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">unit</span><span class="w">  </span><span class="c1">-- ()</span>
</pre></div>
</div>
</div><p>Sometimes we want to think of the default element of a type as being an <em>arbitrary</em> element, whose specific value should not play a role in our proofs. For that purpose, we can write <code class="docutils literal notranslate"><span class="pre">arbitrary</span> <span class="pre">&#945;</span></code> instead of <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">&#945;</span></code>. The definition of <code class="docutils literal notranslate"><span class="pre">arbitrary</span></code> is the same as that of default, but is marked <code class="docutils literal notranslate"><span class="pre">irreducible</span></code> to discourage the elaborator from unfolding it. This does not preclude proofs from making use of the value, however, so the use of <code class="docutils literal notranslate"><span class="pre">arbitrary</span></code> rather than <code class="docutils literal notranslate"><span class="pre">default</span></code> functions primarily to signal intent.</p>
</section>
<section id="chaining-instances">
<h2><span class="section-number">10.2. </span>Chaining Instances<a class="headerlink" href="#chaining-instances" title="Link to this heading">&#182;</a></h2>
<p>If that were the extent of type class inference, it would not be all that impressive; it would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table. What makes type class inference powerful is that one can <em>chain</em> instances. That is, an instance declaration can in turn depend on an implicit instance of a type class. This causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.</p>
<p>For example, the following definition shows that if two types <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> are inhabited, then so is their product:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Adef%20default%20(%CE%B1%20%3A%20Type*)%20%5Bs%20%3A%20inhabited%20%CE%B1%5D%20%3A%20%CE%B1%20%3A%3D%0A%40inhabited.default%20%CE%B1%20s%0A--%20BEGIN%0Ainstance%20prod_inhabited%0A%20%20%20%20%7B%CE%B1%20%CE%B2%20%3A%20Type*%7D%20%5Binhabited%20%CE%B1%5D%20%5Binhabited%20%CE%B2%5D%20%3A%0A%20%20inhabited%20(prod%20%CE%B1%20%CE%B2)%20%3A%3D%0A%E2%9F%A8(default%20%CE%B1%2C%20default%20%CE%B2)%E2%9F%A9%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">prod_inhabited</span>
<span class="w">    </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#946;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">prod</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;(</span><span class="n">default</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)&#10217;</span>
</pre></div>
</div>
</div><p>With this added to the earlier instance declarations, type class instance can infer, for example, a default element of <code class="docutils literal notranslate"><span class="pre">nat</span> <span class="pre">&#215;</span> <span class="pre">bool</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Adef%20default%20(%CE%B1%20%3A%20Type*)%20%5Bs%20%3A%20inhabited%20%CE%B1%5D%20%3A%20%CE%B1%20%3A%3D%0A%40inhabited.default%20%CE%B1%20s%0A--%20BEGIN%0A%23check%20default%20(nat%20%C3%97%20bool)%0A%23reduce%20default%20(nat%20%C3%97%20bool)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">(</span><span class="n">nat</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">bool</span><span class="o">)</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">(</span><span class="n">nat</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">bool</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Given the expression <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">(nat</span> <span class="pre">&#215;</span> <span class="pre">bool)</span></code>, the elaborator is called on to infer an implicit argument <code class="docutils literal notranslate"><span class="pre">?M</span> <span class="pre">:</span> <span class="pre">inhabited</span> <span class="pre">(nat</span> <span class="pre">&#215;</span> <span class="pre">bool)</span></code>. The instance <code class="docutils literal notranslate"><span class="pre">prod_inhabited</span></code> reduces this to inferring <code class="docutils literal notranslate"><span class="pre">?M1</span> <span class="pre">:</span> <span class="pre">inhabited</span> <span class="pre">nat</span></code> and <code class="docutils literal notranslate"><span class="pre">?M2</span> <span class="pre">:</span> <span class="pre">inhabited</span> <span class="pre">bool</span></code>. The first one is solved by the instance <code class="docutils literal notranslate"><span class="pre">nat_inhabited</span></code>. The second uses <code class="docutils literal notranslate"><span class="pre">bool_inhabited</span></code>.</p>
<p>Similarly, we can inhabit function spaces with suitable constant functions:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Adef%20default%20(%CE%B1%20%3A%20Type*)%20%5Bs%20%3A%20inhabited%20%CE%B1%5D%20%3A%20%CE%B1%20%3A%3D%0A%40inhabited.default%20%CE%B1%20s%0A--%20BEGIN%0Ainstance%20inhabited_fun%20(%CE%B1%20%3A%20Type*)%20%7B%CE%B2%20%3A%20Type*%7D%20%5Binhabited%20%CE%B2%5D%20%3A%0A%20%20inhabited%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%3A%3D%0A%E2%9F%A8(%CE%BB%20a%20%3A%20%CE%B1%2C%20default%20%CE%B2)%E2%9F%A9%0A%0A%23check%20default%20(nat%20%E2%86%92%20nat%20%C3%97%20bool)%0A%23reduce%20default%20(nat%20%E2%86%92%20nat%20%C3%97%20bool)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">inhabited_fun</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#946;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)&#10217;</span>

<span class="k">#check</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">(</span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">bool</span><span class="o">)</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">(</span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">bool</span><span class="o">)</span>
</pre></div>
</div>
</div><p>In this case, type class inference finds the default element
<code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">(a</span> <span class="pre">:</span> <span class="pre">nat),</span> <span class="pre">(0,</span> <span class="pre">tt)</span></code>.</p>
<p>As an exercise, try defining default instances for other types, such as sum types and the list type.</p>
</section>
<section id="inferring-notation">
<h2><span class="section-number">10.3. </span>Inferring Notation<a class="headerlink" href="#inferring-notation" title="Link to this heading">&#182;</a></h2>
<p>We now consider the application of type classes that motivates their use in functional programming languages like Haskell, namely, to overload notation in a principled way. In Lean, a symbol like <code class="docutils literal notranslate"><span class="pre">+</span></code> can be given entirely unrelated meanings, a phenomenon that is sometimes called &#8220;ad-hoc&#8221; overloading. Typically, however, we use the <code class="docutils literal notranslate"><span class="pre">+</span></code> symbol to denote a binary function from a type to itself, that is, a function of type <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#945;</span></code> for some type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. We can use type classes to infer an appropriate addition function for suitable types <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. We will see in the next section that this is especially useful for developing algebraic hierarchies of structures in a formal setting.</p>
<p>The standard library declares a type class <code class="docutils literal notranslate"><span class="pre">has_add</span> <span class="pre">&#945;</span></code> as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Aclass%20has_add%20(%CE%B1%20%3A%20Type*)%20%3A%3D%0A(add%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20%CE%B1)%0A%0Adef%20add%20%7B%CE%B1%20%3A%20Type*%7D%20%5Bhas_add%20%CE%B1%5D%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20%CE%B1%20%3A%3D%20has_add.add%0A%0Anotation%20a%20%60%20%2B%20%60%20b%20%3A%3D%20add%20a%20b%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="n">has_add</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">has_add.add</span>

<span class="kd">notation</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">`</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">`</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
</div><p>The class <code class="docutils literal notranslate"><span class="pre">has_add</span> <span class="pre">&#945;</span></code> is supposed to be inhabited exactly when there is an appropriate addition function for <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. The <code class="docutils literal notranslate"><span class="pre">add</span></code> function is designed to find an instance of <code class="docutils literal notranslate"><span class="pre">has_add</span> <span class="pre">&#945;</span></code> for the given type, <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, and apply the corresponding binary addition function. The notation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> thus refers to the addition that is appropriate to the type of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. We can then declare instances for <code class="docutils literal notranslate"><span class="pre">nat</span></code>, and <code class="docutils literal notranslate"><span class="pre">bool</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Ainstance%20nat_has_add%20%3A%20has_add%20nat%20%3A%3D%0A%E2%9F%A8nat.add%E2%9F%A9%0A%0Ainstance%20bool_has_add%20%3A%20has_add%20bool%20%3A%3D%0A%E2%9F%A8bor%E2%9F%A9%0A%0A%23check%202%20%2B%202%20%20%20%20--%20nat%0A%23check%20tt%20%2B%20ff%20%20--%20bool%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">nat_has_add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_add</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">nat.add</span><span class="o">&#10217;</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">bool_has_add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_add</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">bor</span><span class="o">&#10217;</span>

<span class="k">#check</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="w">    </span><span class="c1">-- nat</span>
<span class="k">#check</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">ff</span><span class="w">  </span><span class="c1">-- bool</span>
</pre></div>
</div>
</div><p>As with <code class="docutils literal notranslate"><span class="pre">inhabited</span></code>, the power of type class inference stems not only from the fact that the class enables the elaborator to look up appropriate instances, but also from the fact that it can chain instances to infer complex addition operations. For example, assuming that there are appropriate addition functions for types <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>, we can define addition on <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#215;</span> <span class="pre">&#946;</span></code> pointwise:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Auniverses%20u%20v%0A--%20BEGIN%0Ainstance%20prod_has_add%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7B%CE%B2%20%3A%20Type%20v%7D%0A%20%20%20%20%5Bhas_add%20%CE%B1%5D%20%5Bhas_add%20%CE%B2%5D%20%3A%0A%20%20has_add%20(%CE%B1%20%C3%97%20%CE%B2)%20%3A%3D%0A%E2%9F%A8%CE%BB%20%E2%9F%A8a%E2%82%81%2C%20b%E2%82%81%E2%9F%A9%20%E2%9F%A8a%E2%82%82%2C%20b%E2%82%82%E2%9F%A9%2C%20%E2%9F%A8a%E2%82%81%2Ba%E2%82%82%2C%20b%E2%82%81%2Bb%E2%82%82%E2%9F%A9%E2%9F%A9%0A%0A%23check%20(1%2C%202)%20%2B%20(3%2C%204)%20%20%20%20--%20%E2%84%95%20%C3%97%20%E2%84%95%0A%23reduce%20%20(1%2C%202)%20%2B%20(3%2C%204)%20%20--%20(4%2C%206)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">prod_has_add</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">}</span>
<span class="w">    </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#946;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">has_add</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="bp">&#955;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8321;</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">&#10217;,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;</span><span class="bp">+</span><span class="n">a&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8321;</span><span class="bp">+</span><span class="n">b&#8322;</span><span class="o">&#10217;&#10217;</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">)</span><span class="w">    </span><span class="c1">-- &#8469; &#215; &#8469;</span>
<span class="k">#reduce</span><span class="w">  </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">)</span><span class="w">  </span><span class="c1">-- (4, 6)</span>
</pre></div>
</div>
</div><p>We can similarly define pointwise addition of functions:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Auniverses%20u%20v%0A--%20BEGIN%0Ainstance%20fun_has_add%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7B%CE%B2%20%3A%20Type%20v%7D%20%5Bhas_add%20%CE%B2%5D%20%3A%0A%20%20has_add%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%3A%3D%0A%E2%9F%A8%CE%BB%20f%20g%20x%2C%20f%20x%20%2B%20g%20x%E2%9F%A9%0A%0A%23check%20(%CE%BB%20x%20%3A%20nat%2C%201)%20%2B%20(%CE%BB%20x%2C%202)%20%20%20--%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%23reduce%20(%CE%BB%20x%20%3A%20nat%2C%201)%20%2B%20(%CE%BB%20x%2C%202)%20%20%20%20--%20%CE%BB%20(x%20%3A%20%E2%84%95)%2C%203%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">fun_has_add</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#946;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">has_add</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="o">&#10217;</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w">   </span><span class="c1">-- &#8469; &#8594; &#8469;</span>
<span class="k">#reduce</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w">    </span><span class="c1">-- &#955; (x : &#8469;), 3</span>
</pre></div>
</div>
</div><p>As an exercise, try defining instances of <code class="docutils literal notranslate"><span class="pre">has_add</span></code> for lists, and show that they work as expected.</p>
</section>
<section id="decidable-propositions">
<span id="id2"></span><h2><span class="section-number">10.4. </span>Decidable Propositions<a class="headerlink" href="#decidable-propositions" title="Link to this heading">&#182;</a></h2>
<p>Let us consider another example of a type class defined in the standard library, namely the type class of <code class="docutils literal notranslate"><span class="pre">decidable</span></code> propositions. Roughly speaking, an element of <code class="docutils literal notranslate"><span class="pre">Prop</span></code> is said to be decidable if we can decide whether it is true or false. The distinction is only useful in constructive mathematics; classically, every proposition is decidable. But if we use the classical principle, say, to define a function by cases, that function will not be computable. Algorithmically speaking, the <code class="docutils literal notranslate"><span class="pre">decidable</span></code> type class can be used to infer a procedure that effectively determines whether or not the proposition is true. As a result, the type class supports such computational definitions when they are possible while at the same time allowing a smooth transition to the use of classical definitions and classical reasoning.</p>
<p>In the standard library, <code class="docutils literal notranslate"><span class="pre">decidable</span></code> is defined formally as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aclass%20inductive%20decidable%20(p%20%3A%20Prop)%20%3A%20Type%0A%7C%20is_false%20%3A%20%C2%ACp%20%E2%86%92%20decidable%0A%7C%20is_true%20%20%3A%20%20p%20%E2%86%92%20decidable%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">is_false</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">decidable</span>
<span class="bp">|</span><span class="w"> </span><span class="n">is_true</span><span class="w">  </span><span class="o">:</span><span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">decidable</span>
</pre></div>
</div>
</div><p>Logically speaking, having an element <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">decidable</span> <span class="pre">p</span></code> is stronger than having an element <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;p</span></code>; it enables us to define values of an arbitrary type depending on the truth value of <code class="docutils literal notranslate"><span class="pre">p</span></code>. For example, for the expression <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">p</span> <span class="pre">then</span> <span class="pre">a</span> <span class="pre">else</span> <span class="pre">b</span></code> to make sense, we need to know that <code class="docutils literal notranslate"><span class="pre">p</span></code> is decidable. That expression is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">ite</span> <span class="pre">p</span> <span class="pre">a</span> <span class="pre">b</span></code>, where <code class="docutils literal notranslate"><span class="pre">ite</span></code> is defined as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20ite%20(c%20%3A%20Prop)%20%5Bd%20%3A%20decidable%20c%5D%20%7B%CE%B1%20%3A%20Type*%7D%0A%20%20(t%20e%20%3A%20%CE%B1)%20%3A%20%CE%B1%20%3A%3D%0Adecidable.rec_on%20d%20(%CE%BB%20hnc%2C%20e)%20(%CE%BB%20hc%2C%20t)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">ite</span><span class="w"> </span><span class="o">(</span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="w">  </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">decidable.rec_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hnc</span><span class="o">,</span><span class="w"> </span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hc</span><span class="o">,</span><span class="w"> </span><span class="n">t</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The standard library also contains a variant of <code class="docutils literal notranslate"><span class="pre">ite</span></code> called <code class="docutils literal notranslate"><span class="pre">dite</span></code>, the dependent if-then-else expression. It is defined as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20dite%20(c%20%3A%20Prop)%20%5Bd%20%3A%20decidable%20c%5D%20%7B%CE%B1%20%3A%20Type*%7D%0A%20%20(t%20%3A%20c%20%E2%86%92%20%CE%B1)%20(e%20%3A%20%C2%AC%20c%20%E2%86%92%20%CE%B1)%20%3A%20%CE%B1%20%3A%3D%0Adecidable.rec_on%20d%20(%CE%BB%20hnc%20%3A%20%C2%AC%20c%2C%20e%20hnc)%20(%CE%BB%20hc%20%3A%20c%2C%20t%20hc)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">dite</span><span class="w"> </span><span class="o">(</span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="w">  </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">decidable.rec_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hnc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="w"> </span><span class="n">c</span><span class="o">,</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">hnc</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="o">,</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">hc</span><span class="o">)</span>
</pre></div>
</div>
</div><p>That is, in <code class="docutils literal notranslate"><span class="pre">dite</span> <span class="pre">c</span> <span class="pre">t</span> <span class="pre">e</span></code>, we can assume <code class="docutils literal notranslate"><span class="pre">hc</span> <span class="pre">:</span> <span class="pre">c</span></code> in the &#8220;then&#8221; branch, and <code class="docutils literal notranslate"><span class="pre">hnc</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">c</span></code> in the &#8220;else&#8221; branch. To make <code class="docutils literal notranslate"><span class="pre">dite</span></code> more convenient to use, Lean allows us to write <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">c</span> <span class="pre">then</span> <span class="pre">t</span> <span class="pre">else</span> <span class="pre">e</span></code> instead of <code class="docutils literal notranslate"><span class="pre">dite</span> <span class="pre">c</span> <span class="pre">(&#955;</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">c,</span> <span class="pre">t)</span> <span class="pre">(&#955;</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">c,</span> <span class="pre">e)</span></code>.</p>
<p>Without classical logic, we cannot prove that every proposition is decidable. But we can prove that <em>certain</em> propositions are decidable. For example, we can prove the decidability of basic operations like equality and comparisons on the natural numbers and the integers. Moreover, decidability is preserved under propositional connectives:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40and.decidable%0A--%20%CE%A0%20%7Bp%20q%20%3A%20Prop%7D%20%5Bhp%20%3A%20decidable%20p%5D%20%5Bhq%20%3A%20decidable%20q%5D%2C%0A--%20%20%20decidable%20(p%20%E2%88%A7%20q)%0A%0A%23check%20%40or.decidable%0A%23check%20%40not.decidable%0A%23check%20%40implies.decidable" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">and.decidable</span>
<span class="c1">-- &#928; {p q : Prop} [hp : decidable p] [hq : decidable q],</span>
<span class="c1">--   decidable (p &#8743; q)</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">or.decidable</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">not.decidable</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">implies.decidable</span>
</pre></div>
</div>
</div><p>Thus we can carry out definitions by cases on decidable predicates on the natural numbers:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0Adef%20step%20(a%20b%20x%20%3A%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Aif%20x%20%3C%20a%20%E2%88%A8%20x%20%3E%20b%20then%200%20else%201%0A%0Aset_option%20pp.implicit%20true%0A%23print%20definition%20step" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">def</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">1</span>

<span class="kd">set_option</span><span class="w"> </span><span class="n">pp.implicit</span><span class="w"> </span><span class="n">true</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">definition</span><span class="w"> </span><span class="n">step</span>
</pre></div>
</div>
</div><p>Turning on implicit arguments shows that the elaborator has inferred the decidability of the proposition <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">a</span> <span class="pre">&#8744;</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>, simply by applying appropriate instances.</p>
<p>With the classical axioms, we can prove that every proposition is decidable. You can import the classical axioms and make the generic instance of decidability available by including this at the top of your file:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Alocal%20attribute%20%5Binstance%5D%20prop_decidable" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">classical</span>
<span class="kn">local</span><span class="w"> </span><span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="kd">instance</span><span class="o">]</span><span class="w"> </span><span class="n">prop_decidable</span>
</pre></div>
</div>
</div><p>Thereafter <code class="docutils literal notranslate"><span class="pre">decidable</span> <span class="pre">p</span></code> has an instance for every <code class="docutils literal notranslate"><span class="pre">p</span></code>, and the elaborator infers that value quickly. Thus all theorems in the library that rely on decidability assumptions are freely available when you want to reason classically. In <a class="reference internal" href="axioms_and_computation.html#axioms-and-computation"><span class="std std-numref">Chapter 11</span></a>, we will see that using the law of the excluded middle to define functions can prevent them from being used computationally. If that is important to you, it is best to use sections to limit the use of <code class="docutils literal notranslate"><span class="pre">prop_decidable</span></code> to places where it is really needed. Alternatively, you can can assign <code class="docutils literal notranslate"><span class="pre">prop_decidable</span></code> a low priority:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Alocal%20attribute%20%5Binstance%2C%20priority%2010%5D%20prop_decidable" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">classical</span>
<span class="kn">local</span><span class="w"> </span><span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="kd">instance</span><span class="o">,</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="mi">10</span><span class="o">]</span><span class="w"> </span><span class="n">prop_decidable</span>
</pre></div>
</div>
</div><p>The guarantees that Lean will favor other instances and fall back on <code class="docutils literal notranslate"><span class="pre">prop_decidable</span></code> only after other attempts to infer decidability have failed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">decidable</span></code> type class also provides a bit of small-scale automation for proving theorems. The standard library introduces the following definitions and notation:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20as_true%20(c%20%3A%20Prop)%20%5Bdecidable%20c%5D%20%3A%20Prop%20%3A%3D%0Aif%20c%20then%20true%20else%20false%0A%0Adef%20of_as_true%20%7Bc%20%3A%20Prop%7D%20%5Bh%E2%82%81%20%3A%20decidable%20c%5D%20(h%E2%82%82%20%3A%20as_true%20c)%20%3A%0A%20%20c%20%3A%3D%0Amatch%20h%E2%82%81%2C%20h%E2%82%82%20with%0A%7C%20(is_true%20h_c)%2C%20%20h%E2%82%82%20%3A%3D%20h_c%0A%7C%20(is_false%20h_c)%2C%20h%E2%82%82%20%3A%3D%20false.elim%20h%E2%82%82%0Aend%0A%0Anotation%20%60dec_trivial%60%20%3A%3D%20of_as_true%20(by%20tactic.triv)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">as_true</span><span class="w"> </span><span class="o">(</span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="n">decidable</span><span class="w"> </span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">false</span>

<span class="kd">def</span><span class="w"> </span><span class="n">of_as_true</span><span class="w"> </span><span class="o">{</span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">as_true</span><span class="w"> </span><span class="n">c</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">:=</span>
<span class="k">match</span><span class="w"> </span><span class="n">h&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="k">with</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">is_true</span><span class="w"> </span><span class="n">h_c</span><span class="o">),</span><span class="w">  </span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h_c</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">is_false</span><span class="w"> </span><span class="n">h_c</span><span class="o">),</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">false.elim</span><span class="w"> </span><span class="n">h&#8322;</span>
<span class="kd">end</span>

<span class="kd">notation</span><span class="w"> </span><span class="ss">`dec_trivial</span><span class="bp">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">of_as_true</span><span class="w"> </span><span class="o">(</span><span class="kd">by</span><span class="w"> </span><span class="n">tactic.triv</span><span class="o">)</span>
</pre></div>
</div>
</div><p>They work as follows. The expression <code class="docutils literal notranslate"><span class="pre">as_true</span> <span class="pre">c</span></code> tries to infer a decision procedure for <code class="docutils literal notranslate"><span class="pre">c</span></code>, and, if it is successful, evaluates to either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>. In particular, if <code class="docutils literal notranslate"><span class="pre">c</span></code> is a true closed expression, <code class="docutils literal notranslate"><span class="pre">as_true</span> <span class="pre">c</span></code> will reduce definitionally to <code class="docutils literal notranslate"><span class="pre">true</span></code>. On the assumption that <code class="docutils literal notranslate"><span class="pre">as_true</span> <span class="pre">c</span></code> holds, <code class="docutils literal notranslate"><span class="pre">of_as_true</span></code> produces a proof of <code class="docutils literal notranslate"><span class="pre">c</span></code>. The notation <code class="docutils literal notranslate"><span class="pre">dec_trivial</span></code> puts it all together: to prove a target <code class="docutils literal notranslate"><span class="pre">c</span></code>, it applies <code class="docutils literal notranslate"><span class="pre">of_as_true</span></code> and then uses the <code class="docutils literal notranslate"><span class="pre">triv</span></code> tactic to prove <code class="docutils literal notranslate"><span class="pre">as_true</span> <span class="pre">c</span></code>. By the previous observations, <code class="docutils literal notranslate"><span class="pre">dec_trivial</span></code> will succeed any time the inferred decision procedure for <code class="docutils literal notranslate"><span class="pre">c</span></code> has enough information to evaluate, definitionally, to the <code class="docutils literal notranslate"><span class="pre">is_true</span></code> case. Here is an example of how <code class="docutils literal notranslate"><span class="pre">dec_trivial</span></code> can be used:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%201%20%E2%89%A0%200%20%E2%88%A7%20(5%20%3C%202%20%E2%88%A8%203%20%3C%207)%20%3A%3D%20dec_trivial" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">&#8800;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="mi">5</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="mi">7</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">dec_trivial</span>
</pre></div>
</div>
</div><p>Try changing the <code class="docutils literal notranslate"><span class="pre">3</span></code> to <code class="docutils literal notranslate"><span class="pre">10</span></code>, thereby rendering the expression false. The resulting error message complains that <code class="docutils literal notranslate"><span class="pre">of_as_true</span> <span class="pre">(1</span> <span class="pre">&#8800;</span> <span class="pre">0</span> <span class="pre">&#8743;</span> <span class="pre">(5</span> <span class="pre">&lt;</span> <span class="pre">2</span> <span class="pre">&#8744;</span> <span class="pre">10</span> <span class="pre">&lt;</span> <span class="pre">7))</span></code> is not definitionally equal to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</section>
<section id="managing-type-class-inference">
<h2><span class="section-number">10.5. </span>Managing Type Class Inference<a class="headerlink" href="#managing-type-class-inference" title="Link to this heading">&#182;</a></h2>
<p>You can ask Lean for information about the classes and instances that are currently in scope:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23print%20classes%0A%23print%20instances%20inhabited" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#print</span><span class="w"> </span><span class="n">classes</span>
<span class="k">#print</span><span class="w"> </span><span class="n">instances</span><span class="w"> </span><span class="n">inhabited</span>
</pre></div>
</div>
</div><p>If you are ever in a situation where you need to supply an expression that Lean can infer by type class inference, you can ask Lean to carry out the inference using the tactic <code class="docutils literal notranslate"><span class="pre">apply_instance</span></code> or the expression <code class="docutils literal notranslate"><span class="pre">infer_instance</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20%3A%20has_add%20nat%20%3A%3D%20by%20apply_instance%0Adef%20bar%20%3A%20inhabited%20(nat%20%E2%86%92%20nat)%20%3A%3D%20by%20apply_instance%0A%0Adef%20baz%20%3A%20has_add%20nat%20%3A%3D%20infer_instance%0Adef%20bla%20%3A%20inhabited%20(nat%20%E2%86%92%20nat)%20%3A%3D%20infer_instance%0A%0A%23print%20foo%20%20%20%20--%20nat.has_add%0A%23reduce%20foo%20%20%20--%20(unreadable)%0A%0A%23print%20bar%20%20%20%20--%20pi.inhabited%20%E2%84%95%0A%23reduce%20bar%20%20%20--%20%7Bdefault%20%3A%3D%20%CE%BB%20(a%20%3A%20%E2%84%95)%2C%200%7D%0A%0A%23print%20baz%20%20%20%20--%20infer_instance%0A%23reduce%20baz%20%20%20--%20(same%20as%20for%20%23reduce%20foo)%0A%0A%23print%20bla%20%20%20%20--%20infer_instance%0A%23reduce%20bla%20%20%20--%20%7Bdefault%20%3A%3D%20%CE%BB%20(a%20%3A%20%E2%84%95)%2C%200%7D" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_add</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">apply_instance</span>
<span class="kd">def</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">apply_instance</span>

<span class="kd">def</span><span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_add</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">infer_instance</span>
<span class="kd">def</span><span class="w"> </span><span class="n">bla</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">infer_instance</span>

<span class="k">#print</span><span class="w"> </span><span class="n">foo</span><span class="w">    </span><span class="c1">-- nat.has_add</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">foo</span><span class="w">   </span><span class="c1">-- (unreadable)</span>

<span class="k">#print</span><span class="w"> </span><span class="n">bar</span><span class="w">    </span><span class="c1">-- pi.inhabited &#8469;</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">bar</span><span class="w">   </span><span class="c1">-- {default := &#955; (a : &#8469;), 0}</span>

<span class="k">#print</span><span class="w"> </span><span class="n">baz</span><span class="w">    </span><span class="c1">-- infer_instance</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">baz</span><span class="w">   </span><span class="c1">-- (same as for #reduce foo)</span>

<span class="k">#print</span><span class="w"> </span><span class="n">bla</span><span class="w">    </span><span class="c1">-- infer_instance</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">bla</span><span class="w">   </span><span class="c1">-- {default := &#955; (a : &#8469;), 0}</span>
</pre></div>
</div>
</div><p>In fact, you can use Lean&#8217;s <code class="docutils literal notranslate"><span class="pre">(t</span> <span class="pre">:</span> <span class="pre">T)</span></code> notation to specify the class whose instance you are looking for, in a concise manner:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23reduce%20(by%20apply_instance%20%3A%20inhabited%20%E2%84%95)%0A%23reduce%20(infer_instance%20%3A%20inhabited%20%E2%84%95)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span><span class="w"> </span><span class="o">(</span><span class="kd">by</span><span class="w"> </span><span class="n">apply_instance</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>
<span class="k">#reduce</span><span class="w"> </span><span class="o">(</span><span class="n">infer_instance</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Sometimes Lean can&#8217;t find an instance because the class is buried under a definition. For example, with the core library, Lean cannot find an instance of <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">(set</span> <span class="pre">&#945;)</span></code>. We can declare one explicitly:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20fails%0A--%20example%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20inhabited%20(set%20%CE%B1)%20%3A%3D%0A--%20by%20apply_instance%0A%0Adef%20inhabited.set%20(%CE%B1%20%3A%20Type*)%20%3A%20inhabited%20(set%20%CE%B1)%20%3A%3D%20%E2%9F%A8%E2%88%85%E2%9F%A9%0A%0A%23print%20inhabited.set%20%20%20%20%20--%20%CE%BB%20%7B%CE%B1%20%3A%20Type%20u%7D%2C%20%7Bdefault%20%3A%3D%20%E2%88%85%7D%0A%23reduce%20inhabited.set%20%E2%84%95%20%20--%20%7Bdefault%20%3A%3D%20%CE%BB%20(a%20%3A%20%E2%84%95)%2C%20false%7D" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- fails</span>
<span class="c1">-- example {&#945; : Type*} : inhabited (set &#945;) :=</span>
<span class="c1">-- by apply_instance</span>

<span class="kd">def</span><span class="w"> </span><span class="n">inhabited.set</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="bp">&#8709;</span><span class="o">&#10217;</span>

<span class="k">#print</span><span class="w"> </span><span class="n">inhabited.set</span><span class="w">     </span><span class="c1">-- &#955; {&#945; : Type u}, {default := &#8709;}</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">inhabited.set</span><span class="w"> </span><span class="n">&#8469;</span><span class="w">  </span><span class="c1">-- {default := &#955; (a : &#8469;), false}</span>
</pre></div>
</div>
</div><p>Alternatively, we can help Lean out by unfolding the definition. The type <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&#945;</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">Prop</span></code>. Lean knows that <code class="docutils literal notranslate"><span class="pre">Prop</span></code> is inhabited, and this is enough for it to be able to infer an element of the function type.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20inhabited.set%20(%CE%B1%20%3A%20Type*)%20%3A%20inhabited%20(set%20%CE%B1)%20%3A%3D%0Aby%20unfold%20set%3B%20apply_instance%0A%0A%23print%20inhabited.set%0A%20%20--%20%CE%BB%20(%CE%B1%20%3A%20Type%20u)%2C%20eq.mpr%20_%20(pi.inhabited%20%CE%B1)%0A%23reduce%20inhabited.set%20%E2%84%95%0A%20%20--%20%7Bdefault%20%3A%3D%20%CE%BB%20(a%20%3A%20%E2%84%95)%2C%20true%7D" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">inhabited.set</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">unfold</span><span class="w"> </span><span class="n">set</span><span class="bp">;</span><span class="w"> </span><span class="n">apply_instance</span>

<span class="k">#print</span><span class="w"> </span><span class="n">inhabited.set</span>
<span class="w">  </span><span class="c1">-- &#955; (&#945; : Type u), eq.mpr _ (pi.inhabited &#945;)</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">inhabited.set</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="w">  </span><span class="c1">-- {default := &#955; (a : &#8469;), true}</span>
</pre></div>
</div>
</div><p>Using the <code class="docutils literal notranslate"><span class="pre">dunfold</span></code> tactic instead of <code class="docutils literal notranslate"><span class="pre">unfold</span></code> yields a slightly different expression (try it!), since <code class="docutils literal notranslate"><span class="pre">dunfold</span></code> uses definitional reduction to unfold the definition, rather than an explicit rewrite.</p>
<p>At times, you may find that the type class inference fails to find an expected instance, or, worse, falls into an infinite loop and times out. To help debug in these situations, Lean enables you to request a trace of the search:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=set_option%20trace.class_instances%20true" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">set_option</span><span class="w"> </span><span class="n">trace.class_instances</span><span class="w"> </span><span class="n">true</span>
</pre></div>
</div>
</div><p>If you are using VS Code, you can read the results by hovering over the relevant theorem or definition, or opening the messages window with <code class="docutils literal notranslate"><span class="pre">Ctrl-Shift-Enter</span></code>. In Emacs, you can use <code class="docutils literal notranslate"><span class="pre">C-c</span> <span class="pre">C-x</span></code> to run an independent Lean process on your file, and the output buffer will show a trace every time the type class resolution procedure is subsequently triggered.</p>
<p>You can also limit the search depth (the default is 32):</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=set_option%20class.instance_max_depth%205" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">set_option</span><span class="w"> </span><span class="kd">class</span><span class="bp">.</span><span class="n">instance_max_depth</span><span class="w"> </span><span class="mi">5</span>
</pre></div>
</div>
</div><p>Remember also that in both the VS Code and Emacs editor modes, tab completion works in <code class="docutils literal notranslate"><span class="pre">set_option</span></code>, to help you find suitable options.</p>
<p>As noted above, the type class instances in a given context represent a Prolog-like program, which gives rise to a backtracking search. Both the efficiency of the program and the solutions that are found can depend on the order in which the system tries the instance. Instances which are declared last are tried first. Moreover, if instances are declared in other modules, the order in which they are tried depends on the order in which namespaces are opened. Instances declared in namespaces which are opened later are tried earlier.</p>
<p>You can change the order that type classes instances are tried by assigning them a <em>priority</em>. When an instance is declared, it is assigned a priority value <code class="docutils literal notranslate"><span class="pre">std.priority.default</span></code>, defined to be 1000 in module <code class="docutils literal notranslate"><span class="pre">init.core</span></code> in the standard library. You can assign other priorities when defining an instance, and you can later change the priority with the <code class="docutils literal notranslate"><span class="pre">attribute</span></code> command. The following example illustrates how this is done:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=class%20foo%20%3A%3D%0A(a%20%3A%20nat)%20(b%20%3A%20nat)%0A%0A%40%5Bpriority%20std.priority.default%2B1%5D%0Ainstance%20i1%20%3A%20foo%20%3A%3D%0A%E2%9F%A81%2C%201%E2%9F%A9%0A%0Ainstance%20i2%20%3A%20foo%20%3A%3D%0A%E2%9F%A82%2C%202%E2%9F%A9%0A%0Aexample%20%3A%20foo.a%20%3D%201%20%3A%3D%20rfl%0A%0A%40%5Bpriority%20std.priority.default%2B20%5D%0Ainstance%20i3%20%3A%20foo%20%3A%3D%0A%E2%9F%A83%2C%203%E2%9F%A9%0A%0Aexample%20%3A%20foo.a%20%3D%203%20%3A%3D%20rfl%0A%0Aattribute%20%5Binstance%2C%20priority%2010%5D%20i3%0A%0Aexample%20%3A%20foo.a%20%3D%201%20%3A%3D%20rfl%0A%0Aattribute%20%5Binstance%2C%20priority%20std.priority.default-10%5D%20i1%0A%0Aexample%20%3A%20foo.a%20%3D%202%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span>

<span class="kd">@[</span><span class="n">priority</span><span class="w"> </span><span class="n">std.priority.default</span><span class="bp">+</span><span class="mi">1</span><span class="kd">]</span>
<span class="kd">instance</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&#10217;</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo.a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">@[</span><span class="n">priority</span><span class="w"> </span><span class="n">std.priority.default</span><span class="bp">+</span><span class="mi">20</span><span class="kd">]</span>
<span class="kd">instance</span><span class="w"> </span><span class="n">i3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo.a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="kd">instance</span><span class="o">,</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="mi">10</span><span class="o">]</span><span class="w"> </span><span class="n">i3</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo.a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="kd">instance</span><span class="o">,</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="n">std.priority.default</span><span class="bp">-</span><span class="mi">10</span><span class="o">]</span><span class="w"> </span><span class="n">i1</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo.a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div></section>
<section id="coercions-using-type-classes">
<span id="id3"></span><h2><span class="section-number">10.6. </span>Coercions using Type Classes<a class="headerlink" href="#coercions-using-type-classes" title="Link to this heading">&#182;</a></h2>
<p>The most basic type of coercion maps elements of one type to another. For example, a coercion from <code class="docutils literal notranslate"><span class="pre">nat</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code> allows us to view any element <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat</span></code> as an element of <code class="docutils literal notranslate"><span class="pre">int</span></code>. But some coercions depend on parameters; for example, for any type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, we can view any element <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">:</span> <span class="pre">list</span> <span class="pre">&#945;</span></code> as an element of <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&#945;</span></code>, namely, the set of elements occurring in the list. The corresponding coercion is defined on the &#8220;family&#8221; of types <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">&#945;</span></code>, parameterized by <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.</p>
<p>Lean allows us to declare three kinds of coercions:</p>
<ul class="simple">
<li><p>from a family of types to another family of types</p></li>
<li><p>from a family of types to the class of sorts</p></li>
<li><p>from a family of types to the class of function types</p></li>
</ul>
<p>The first kind of coercion allows us to view any element of a member of the source family as an element of a corresponding member of the target family. The second kind of coercion allows us to view any element of a member of the source family as a type. The third kind of coercion allows us to view any element of the source family as a function. Let us consider each of these in turn.</p>
<p>In Lean, coercions are implemented on top of the type class resolution framework. We define a coercion from <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> to <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> by declaring an instance of <code class="docutils literal notranslate"><span class="pre">has_coe</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span></code>. For example, we can define a coercion from <code class="docutils literal notranslate"><span class="pre">bool</span></code> to <code class="docutils literal notranslate"><span class="pre">Prop</span></code> as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=instance%20bool_to_Prop%20%3A%20has_coe%20bool%20Prop%20%3A%3D%0A%E2%9F%A8%CE%BB%20b%2C%20b%20%3D%20tt%E2%9F%A9" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">bool_to_Prop</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_coe</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">tt</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>This enables us to use boolean terms in if-then-else expressions:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=instance%20bool_to_Prop%20%3A%20has_coe%20bool%20Prop%20%3A%3D%0A%E2%9F%A8%CE%BB%20b%2C%20b%20%3D%20tt%E2%9F%A9%0A--%20BEGIN%0A%23reduce%20if%20tt%20then%203%20else%205%0A%23reduce%20if%20ff%20then%203%20else%205%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">5</span>
<span class="k">#reduce</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">5</span>
</pre></div>
</div>
</div><p>We can define a coercion from <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">&#945;</span></code> to <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&#945;</span></code> as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.set.basic%0A%0Adef%20list.to_set%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20set%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%3A%3D%20%E2%88%85%0A%7C%20(h%3A%3At)%20%3A%3D%20%7Bh%7D%20%E2%88%AA%20list.to_set%20t%0A%0Ainstance%20list_to_set_coe%20(%CE%B1%20%3A%20Type*)%20%3A%0A%20%20has_coe%20(list%20%CE%B1)%20(set%20%CE%B1)%20%3A%3D%0A%E2%9F%A8list.to_set%E2%9F%A9%0A%0Adef%20s%20%3A%20set%20nat%20%20%3A%3D%20%7B1%2C%202%7D%0Adef%20l%20%3A%20list%20nat%20%3A%3D%20%5B3%2C%204%5D%0A%0A%23check%20s%20%E2%88%AA%20l%20--%20set%20nat" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">data.set.basic</span>

<span class="kd">def</span><span class="w"> </span><span class="n">list.to_set</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#8709;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">{</span><span class="n">h</span><span class="o">}</span><span class="w"> </span><span class="bp">&#8746;</span><span class="w"> </span><span class="n">list.to_set</span><span class="w"> </span><span class="n">t</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">list_to_set_coe</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">has_coe</span><span class="w"> </span><span class="o">(</span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">list.to_set</span><span class="o">&#10217;</span>

<span class="kd">def</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">nat</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">}</span>
<span class="kd">def</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">]</span>

<span class="k">#check</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="bp">&#8746;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="c1">-- set nat</span>
</pre></div>
</div>
</div><p>Coercions are only considered if the given and expected types do not contain metavariables at elaboration time. In the following example, when we elaborate the union operator, the type of <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">2]</span></code> is <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">?m</span></code>, and a coercion will not be considered since it contains metavariables.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.set.basic%0A%0Adef%20list.to_set%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20set%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%3A%3D%20%E2%88%85%0A%7C%20(h%3A%3At)%20%3A%3D%20%7Bh%7D%20%E2%88%AA%20list.to_set%20t%0A%0Ainstance%20list_to_set_coe%20(%CE%B1%20%3A%20Type*)%20%3A%0A%20%20has_coe%20(list%20%CE%B1)%20(set%20%CE%B1)%20%3A%3D%0A%E2%9F%A8list.to_set%E2%9F%A9%0A%0Adef%20s%20%3A%20set%20nat%20%20%3A%3D%20%7B1%2C%202%7D%0A%0A--%20BEGIN%0A%2F-%20The%20following%20%23check%20command%20produces%20an%20error.%20-%2F%0A--%20%23check%20s%20%E2%88%AA%20%5B3%2C%202%5D%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span><span class="cm"> The following #check command produces an error. -/</span>
<span class="c1">-- #check s &#8746; [3, 2]</span>
</pre></div>
</div>
</div><p>We can work around this issue by using a type ascription.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.set.basic%0A%0Adef%20list.to_set%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20set%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%3A%3D%20%E2%88%85%0A%7C%20(h%3A%3At)%20%3A%3D%20%7Bh%7D%20%E2%88%AA%20list.to_set%20t%0A%0Ainstance%20list_to_set_coe%20(%CE%B1%20%3A%20Type*)%20%3A%0A%20%20has_coe%20(list%20%CE%B1)%20(set%20%CE%B1)%20%3A%3D%0A%E2%9F%A8list.to_set%E2%9F%A9%0A%0Adef%20s%20%3A%20set%20nat%20%20%3A%3D%20%7B1%2C%202%7D%0A%0A--%20BEGIN%0A%23check%20s%20%E2%88%AA%20%5B(3%3Anat)%2C%202%5D%0A--%20or%0A%23check%20s%20%E2%88%AA%20(%5B3%2C%202%5D%20%3A%20list%20nat)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="bp">&#8746;</span><span class="w"> </span><span class="o">[(</span><span class="mi">3</span><span class="o">:</span><span class="n">nat</span><span class="o">),</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span>
<span class="c1">-- or</span>
<span class="k">#check</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="bp">&#8746;</span><span class="w"> </span><span class="o">([</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span>
</pre></div>
</div>
</div><p>In the examples above, you may have noticed the symbol <code class="docutils literal notranslate"><span class="pre">&#8593;</span></code> produced by the <code class="docutils literal notranslate"><span class="pre">#check</span></code> commands. It is the lift operator, <code class="docutils literal notranslate"><span class="pre">&#8593;t</span></code> is notation for <code class="docutils literal notranslate"><span class="pre">coe</span> <span class="pre">t</span></code>. We can use this operator to force a coercion to be introduced in a particular place. It is also helpful to make our intent clear, and work around limitations of the coercion resolution system.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.set.basic%0A%0Adef%20list.to_set%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20set%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%3A%3D%20%E2%88%85%0A%7C%20(h%3A%3At)%20%3A%3D%20%7Bh%7D%20%E2%88%AA%20list.to_set%20t%0A%0Ainstance%20list_to_set_coe%20(%CE%B1%20%3A%20Type*)%20%3A%0A%20%20has_coe%20(list%20%CE%B1)%20(set%20%CE%B1)%20%3A%3D%0A%E2%9F%A8list.to_set%E2%9F%A9%0A%0Adef%20s%20%3A%20set%20nat%20%20%3A%3D%20%7B1%2C%202%7D%0A%0A--%20BEGIN%0A%23check%20s%20%E2%88%AA%20%E2%86%91%5B3%2C%202%5D%0A%0Avariables%20n%20m%20%3A%20nat%0Avariable%20i%20%3A%20int%0A%23check%20i%20%2B%20%E2%86%91n%20%2B%20%E2%86%91m%0A%23check%20i%20%2B%20%E2%86%91(n%20%2B%20m)%0A%23check%20%E2%86%91n%20%2B%20i%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="bp">&#8746;</span><span class="w"> </span><span class="bp">&#8593;</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="k">#check</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">&#8593;</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">&#8593;</span><span class="n">m</span>
<span class="k">#check</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">&#8593;</span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="o">)</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">&#8593;</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">i</span>
</pre></div>
</div>
</div><p>In the first two examples, the coercions are not strictly necessary since Lean will insert implicit nat &#8594; int coercions. However, <code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">i</span></code> would raise an error, because the expected type of <code class="docutils literal notranslate"><span class="pre">i</span></code> is nat in order to match the type of n, and no int &#8594; nat coercion exists). In the third example, we therefore insert an explicit <code class="docutils literal notranslate"><span class="pre">&#8593;</span></code> to coerce <code class="docutils literal notranslate"><span class="pre">n</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>The standard library defines a coercion from subtype <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">//</span> <span class="pre">p</span> <span class="pre">x}</span></code> to <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Ainstance%20coe_subtype%20%7B%CE%B1%20%3A%20Type*%7D%20%7Bp%20%3A%20%CE%B1%20%E2%86%92%20Prop%7D%20%3A%0A%20%20has_coe%20%7Bx%20%2F%2F%20p%20x%7D%20%CE%B1%20%3A%3D%0A%E2%9F%A8%CE%BB%20s%2C%20subtype.val%20s%E2%9F%A9%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">coe_subtype</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">has_coe</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="bp">//</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">}</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="n">subtype.val</span><span class="w"> </span><span class="n">s</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>Lean will also chain coercions as necessary. Actually, the type class <code class="docutils literal notranslate"><span class="pre">has_coe_t</span></code> is the transitive closure of <code class="docutils literal notranslate"><span class="pre">has_coe</span></code>. You may have noticed that the type of <code class="docutils literal notranslate"><span class="pre">coe</span></code> depends on <code class="docutils literal notranslate"><span class="pre">has_lift_t</span></code>, the transitive closure of the type class <code class="docutils literal notranslate"><span class="pre">has_lift</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">has_coe_t</span></code>. Every instance of <code class="docutils literal notranslate"><span class="pre">has_coe_t</span></code> is also an instance of <code class="docutils literal notranslate"><span class="pre">has_lift_t</span></code>, but the elaborator only introduces automatically instances of <code class="docutils literal notranslate"><span class="pre">has_coe_t</span></code>. That is, to be able to coerce using an instance of <code class="docutils literal notranslate"><span class="pre">has_lift_t</span></code>, we must use the operator <code class="docutils literal notranslate"><span class="pre">&#8593;</span></code>. In the standard library, we have the following instance:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Auniverses%20u%20v%0A%0Ainstance%20lift_list%20%7Ba%20%3A%20Type%20u%7D%20%7Bb%20%3A%20Type%20v%7D%20%5Bhas_lift_t%20a%20b%5D%20%3A%0A%20%20has_lift%20(list%20a)%20(list%20b)%20%3A%3D%0A%E2%9F%A8%CE%BB%20l%2C%20list.map%20(%40coe%20a%20b%20_)%20l%E2%9F%A9%0A%0Avariables%20s%20%3A%20list%20nat%0Avariables%20r%20%3A%20list%20int%0A%23check%20%E2%86%91s%20%2B%2B%20r%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">hidden</span>
<span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">lift_list</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">has_lift_t</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">has_lift</span><span class="w"> </span><span class="o">(</span><span class="n">list</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">list</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">l</span><span class="o">,</span><span class="w"> </span><span class="n">list.map</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">coe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">_</span><span class="o">)</span><span class="w"> </span><span class="n">l</span><span class="o">&#10217;</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">nat</span>
<span class="kd">variables</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">int</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">&#8593;</span><span class="n">s</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">r</span>

<span class="kd">end</span><span class="w"> </span><span class="n">hidden</span>
</pre></div>
</div>
</div><p>It is not an instance of <code class="docutils literal notranslate"><span class="pre">has_coe</span></code> because lists are frequently used for writing programs, and we do not want a linear-time operation to be silently introduced by Lean, and potentially mask mistakes performed by the user. By forcing the user to write <code class="docutils literal notranslate"><span class="pre">&#8593;</span></code>, she is making her intent clear to Lean.</p>
<p>Let us now consider the second kind of coercion. By the <em>class of sorts</em>, we mean the collection of universes <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u</span></code>. A coercion of the second kind is of the form</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>c : &#928; x1 : A1, ..., xn : An, F x1 ... xn &#8594; Type u
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">F</span></code> is a family of types as above. This allows us to write <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">t</span></code> whenever <code class="docutils literal notranslate"><span class="pre">t</span></code> is of type <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code>. In other words, the coercion allows us to view the elements of <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code> as types. This is very useful when defining algebraic structures in which one component, the carrier of the structure, is a <code class="docutils literal notranslate"><span class="pre">Type</span></code>. For example, we can define a semigroup as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Astructure%20Semigroup%20%3A%20Type%20(u%2B1)%20%3A%3D%0A(carrier%20%3A%20Type%20u)%0A(mul%20%3A%20carrier%20%E2%86%92%20carrier%20%E2%86%92%20carrier)%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20carrier%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20mul%20(mul%20a%20b)%20c%20%3D%20mul%20a%20(mul%20b%20c))%0A%0Ainstance%20Semigroup_has_mul%20(S%20%3A%20Semigroup)%20%3A%0A%20%20has_mul%20(S.carrier)%20%3A%3D%0A%E2%9F%A8S.mul%E2%9F%A9" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span><span class="w"> </span><span class="n">u</span>

<span class="kd">structure</span><span class="w"> </span><span class="n">Semigroup</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">carrier</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">carrier</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">carrier</span><span class="o">,</span>
<span class="w">               </span><span class="n">mul</span><span class="w"> </span><span class="o">(</span><span class="n">mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">(</span><span class="n">mul</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">))</span>

<span class="kd">instance</span><span class="w"> </span><span class="n">Semigroup_has_mul</span><span class="w"> </span><span class="o">(</span><span class="n">S</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Semigroup</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">has_mul</span><span class="w"> </span><span class="o">(</span><span class="n">S.carrier</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">S.mul</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>In other words, a semigroup consists of a type, <code class="docutils literal notranslate"><span class="pre">carrier</span></code>, and a multiplication, <code class="docutils literal notranslate"><span class="pre">mul</span></code>, with the property that the multiplication is associative. The <code class="docutils literal notranslate"><span class="pre">instance</span></code> command allows us to write <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Semigroup.mul</span> <span class="pre">S</span> <span class="pre">a</span> <span class="pre">b</span></code> whenever we have <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">S.carrier</span></code>; notice that Lean can infer the argument <code class="docutils literal notranslate"><span class="pre">S</span></code> from the types of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. The function <code class="docutils literal notranslate"><span class="pre">Semigroup.carrier</span></code> maps the class <code class="docutils literal notranslate"><span class="pre">Semigroup</span></code> to the sort <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Astructure%20Semigroup%20%3A%20Type%20(u%2B1)%20%3A%3D%0A(carrier%20%3A%20Type%20u)%0A(mul%20%3A%20carrier%20%E2%86%92%20carrier%20%E2%86%92%20carrier)%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20carrier%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20mul%20(mul%20a%20b)%20c%20%3D%20mul%20a%20(mul%20b%20c))%0A%0Ainstance%20Semigroup_has_mul%20(S%20%3A%20Semigroup)%20%3A%20has_mul%20(S.carrier)%20%3A%3D%0A%E2%9F%A8S.mul%E2%9F%A9%0A--%20BEGIN%0A%23check%20Semigroup.carrier%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="n">Semigroup.carrier</span>
</pre></div>
</div>
</div><p>If we declare this function to be a coercion, then whenever we have a semigroup <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">:</span> <span class="pre">Semigroup</span></code>, we can write <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">S</span></code> instead of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">S.carrier</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Astructure%20Semigroup%20%3A%20Type%20(u%2B1)%20%3A%3D%0A(carrier%20%3A%20Type%20u)%0A(mul%20%3A%20carrier%20%E2%86%92%20carrier%20%E2%86%92%20carrier)%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20carrier%2C%20mul%20(mul%20a%20b)%20c%20%3D%20mul%20a%20(mul%20b%20c))%0A%0Ainstance%20Semigroup_has_mul%20(S%20%3A%20Semigroup)%20%3A%20has_mul%20(S.carrier)%20%3A%3D%0A%E2%9F%A8S.mul%E2%9F%A9%0A%0A--%20BEGIN%0Ainstance%20Semigroup_to_sort%20%3A%20has_coe_to_sort%20Semigroup%20(Type%20u)%20%3A%3D%0A%7B%20coe%20%3A%3D%20%CE%BB%20S%2C%20S.carrier%20%7D%0A%0Aexample%20(S%20%3A%20Semigroup)%20(a%20b%20c%20%3A%20S)%20%3A%0A%20%20(a%20*%20b)%20*%20c%20%3D%20a%20*%20(b%20*%20c)%20%3A%3D%0ASemigroup.mul_assoc%20_%20a%20b%20c%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">Semigroup_to_sort</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_coe_to_sort</span><span class="w"> </span><span class="n">Semigroup</span><span class="w"> </span><span class="o">(</span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">{</span><span class="w"> </span><span class="n">coe</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">S</span><span class="o">,</span><span class="w"> </span><span class="n">S.carrier</span><span class="w"> </span><span class="o">}</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">S</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Semigroup</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">S</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">c</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">Semigroup.mul_assoc</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
</div><p>It is the coercion that makes it possible to write <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">b</span> <span class="pre">c</span> <span class="pre">:</span> <span class="pre">S)</span></code>. Note that, we define an instance of <code class="docutils literal notranslate"><span class="pre">has_coe_to_sort</span> <span class="pre">Semigroup</span> <span class="pre">(Type</span> <span class="pre">u)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">has_coe</span> <span class="pre">Semigroup</span> <span class="pre">(Type</span> <span class="pre">u)</span></code>. The reason is that when Lean needs a coercion to sort, it only knows it needs a type, but, in general, the universe is not known. The second argument to <code class="docutils literal notranslate"><span class="pre">has_coe_to_sort</span></code> is used to specify the universe we are coercing too.</p>
<p>By the <em>class of function types</em>, we mean the collection of Pi types <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">z</span> <span class="pre">:</span> <span class="pre">B,</span> <span class="pre">C</span></code>. The third kind of coercion has the form</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>c : &#928; x1 : A1, ..., xn : An, y : F x1 ... xn, &#928; z : B, C
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">F</span></code> is again a family of types and <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> can depend on <code class="docutils literal notranslate"><span class="pre">x1,</span> <span class="pre">...,</span> <span class="pre">xn,</span> <span class="pre">y</span></code>. This makes it possible to write <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">s</span></code> whenever <code class="docutils literal notranslate"><span class="pre">t</span></code> is an element of <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code>. In other words, the coercion enables us to view elements of <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">a1</span> <span class="pre">...</span> <span class="pre">an</span></code> as functions. Continuing the example above, we can define the notion of a morphism between semigroups <code class="docutils literal notranslate"><span class="pre">S1</span></code> and <code class="docutils literal notranslate"><span class="pre">S2</span></code>. That is, a function from the carrier of <code class="docutils literal notranslate"><span class="pre">S1</span></code> to the carrier of <code class="docutils literal notranslate"><span class="pre">S2</span></code> (note the implicit coercion) that respects the multiplication. The projection <code class="docutils literal notranslate"><span class="pre">morphism.mor</span></code> takes a morphism to the underlying function:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Astructure%20Semigroup%20%3A%20Type%20(u%2B1)%20%3A%3D%0A(carrier%20%3A%20Type%20u)%0A(mul%20%3A%20carrier%20%E2%86%92%20carrier%20%E2%86%92%20carrier)%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20carrier%2C%20mul%20(mul%20a%20b)%20c%20%3D%20mul%20a%20(mul%20b%20c))%0A%0Ainstance%20Semigroup_has_mul%20(S%20%3A%20Semigroup)%20%3A%20has_mul%20(S.carrier)%20%3A%3D%0A%E2%9F%A8S.mul%E2%9F%A9%0A%0A--%20BEGIN%0Ainstance%20Semigroup_to_sort%20%3A%20has_coe_to_sort%20Semigroup%20(Type%20u)%20%3A%3D%0A%7B%20coe%20%3A%3D%20%CE%BB%20S%2C%20S.carrier%20%7D%0A%0Astructure%20morphism%20(S1%20S2%20%3A%20Semigroup)%20%3A%3D%0A(mor%20%3A%20S1%20%E2%86%92%20S2)%0A(resp_mul%20%3A%20%E2%88%80%20a%20b%20%3A%20S1%2C%20mor%20(a%20*%20b)%20%3D%20(mor%20a)%20*%20(mor%20b))%0A%0A%23check%20%40morphism.mor%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">Semigroup_to_sort</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_coe_to_sort</span><span class="w"> </span><span class="n">Semigroup</span><span class="w"> </span><span class="o">(</span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">{</span><span class="w"> </span><span class="n">coe</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">S</span><span class="o">,</span><span class="w"> </span><span class="n">S.carrier</span><span class="w"> </span><span class="o">}</span>

<span class="kd">structure</span><span class="w"> </span><span class="n">morphism</span><span class="w"> </span><span class="o">(</span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Semigroup</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">mor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">S2</span><span class="o">)</span>
<span class="o">(</span><span class="n">resp_mul</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">S1</span><span class="o">,</span><span class="w"> </span><span class="n">mor</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">(</span><span class="n">mor</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="o">(</span><span class="n">mor</span><span class="w"> </span><span class="n">b</span><span class="o">))</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">morphism.mor</span>
</pre></div>
</div>
</div><p>As a result, it is a prime candidate for the third type of coercion.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Astructure%20Semigroup%20%3A%20Type%20(u%2B1)%20%3A%3D%0A(carrier%20%3A%20Type%20u)%0A(mul%20%3A%20carrier%20%E2%86%92%20carrier%20%E2%86%92%20carrier)%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20carrier%2C%20mul%20(mul%20a%20b)%20c%20%3D%20mul%20a%20(mul%20b%20c))%0A%0Ainstance%20Semigroup_has_mul%20(S%20%3A%20Semigroup)%20%3A%20has_mul%20(S.carrier)%20%3A%3D%0A%E2%9F%A8S.mul%E2%9F%A9%0A%0A%0Ainstance%20Semigroup_to_sort%20%3A%20has_coe_to_sort%20Semigroup%20(Type%20u)%20%3A%3D%0A%7B%20coe%20%3A%3D%20%CE%BB%20S%2C%20S.carrier%20%7D%0A%0Astructure%20morphism%20(S1%20S2%20%3A%20Semigroup)%20%3A%3D%0A(mor%20%3A%20S1%20%E2%86%92%20S2)%0A(resp_mul%20%3A%20%E2%88%80%20a%20b%20%3A%20S1%2C%20mor%20(a%20*%20b)%20%3D%20(mor%20a)%20*%20(mor%20b))%0A%0A--%20BEGIN%0Ainstance%20morphism_to_fun%20(S1%20S2%20%3A%20Semigroup)%20%3A%0A%20%20has_coe_to_fun%20(morphism%20S1%20S2)%20(%CE%BB%20_%2C%20S1%20%E2%86%92%20S2)%20%3A%3D%0A%7B%20coe%20%3A%3D%20%CE%BB%20m%2C%20m.mor%20%7D%0A%0Alemma%20resp_mul%20%7BS1%20S2%20%3A%20Semigroup%7D%0A%20%20%20%20(f%20%3A%20morphism%20S1%20S2)%20(a%20b%20%3A%20S1)%20%3A%0A%20%20f%20(a%20*%20b)%20%3D%20f%20a%20*%20f%20b%20%3A%3D%0Af.resp_mul%20a%20b%0A%0Aexample%20(S1%20S2%20%3A%20Semigroup)%20(f%20%3A%20morphism%20S1%20S2)%20(a%20%3A%20S1)%20%3A%0A%20%20f%20(a%20*%20a%20*%20a)%20%3D%20f%20a%20*%20f%20a%20*%20f%20a%20%3A%3D%0Acalc%0A%20%20f%20(a%20*%20a%20*%20a)%20%3D%20f%20(a%20*%20a)%20*%20f%20a%20%3A%20by%20rw%20%5Bresp_mul%20f%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20...%20%3D%20f%20a%20*%20f%20a%20*%20f%20a%20%3A%20by%20rw%20%5Bresp_mul%20f%5D%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">morphism_to_fun</span><span class="w"> </span><span class="o">(</span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Semigroup</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">has_coe_to_fun</span><span class="w"> </span><span class="o">(</span><span class="n">morphism</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">_</span><span class="o">,</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">S2</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">{</span><span class="w"> </span><span class="n">coe</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">m</span><span class="o">,</span><span class="w"> </span><span class="n">m.mor</span><span class="w"> </span><span class="o">}</span>

<span class="kd">lemma</span><span class="w"> </span><span class="n">resp_mul</span><span class="w"> </span><span class="o">{</span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Semigroup</span><span class="o">}</span>
<span class="w">    </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">morphism</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">S1</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span>
<span class="n">f.resp_mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Semigroup</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">morphism</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">S1</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="k">calc</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">resp_mul</span><span class="w"> </span><span class="n">f</span><span class="o">]</span>
<span class="w">            </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">resp_mul</span><span class="w"> </span><span class="n">f</span><span class="o">]</span>
</pre></div>
</div>
</div><p>With the coercion in place, we can write <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">a)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">morphism.mor</span> <span class="pre">f</span> <span class="pre">(a</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">a)</span></code>. When the <code class="docutils literal notranslate"><span class="pre">morphism</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span></code>, is used where a function is expected, Lean inserts the coercion. Similar to <code class="docutils literal notranslate"><span class="pre">has_coe_to_sort</span></code>, we have yet another class <code class="docutils literal notranslate"><span class="pre">has_coe_to_fun</span></code> for this class of coercions. The second argument <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">_,</span> <span class="pre">S1</span> <span class="pre">&#8594;</span> <span class="pre">S2</span></code> is used to specify the function type we are coercing to. This type may depend on the type we are coercing from.</p>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">&#8657;f</span></code> and <code class="docutils literal notranslate"><span class="pre">&#8613;S</span></code> are notations for <code class="docutils literal notranslate"><span class="pre">coe_fn</span> <span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">coe_sort</span> <span class="pre">S</span></code>. They are the coercion operators for the function and sort classes.</p>
<p>We can instruct Lean&#8217;s pretty-printer to hide the operators <code class="docutils literal notranslate"><span class="pre">&#8593;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#8657;</span></code> with <code class="docutils literal notranslate"><span class="pre">set_option</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Astructure%20Semigroup%20%3A%20Type%20(u%2B1)%20%3A%3D%0A(carrier%20%3A%20Type%20u)%0A(mul%20%3A%20carrier%20%E2%86%92%20carrier%20%E2%86%92%20carrier)%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20carrier%2C%20mul%20(mul%20a%20b)%20c%20%3D%20mul%20a%20(mul%20b%20c))%0A%0Ainstance%20Semigroup_has_mul%20(S%20%3A%20Semigroup)%20%3A%20has_mul%20(S.carrier)%20%3A%3D%0A%E2%9F%A8S.mul%E2%9F%A9%0A%0Ainstance%20Semigroup_to_sort%20%3A%20has_coe_to_sort%20Semigroup%20(Type%20u)%20%3A%3D%0A%7B%20coe%20%3A%3D%20%CE%BB%20S%2C%20S.carrier%20%7D%0A%0Astructure%20morphism%20(S1%20S2%20%3A%20Semigroup)%20%3A%3D%0A(mor%20%3A%20S1%20%E2%86%92%20S2)%0A(resp_mul%20%3A%20%E2%88%80%20a%20b%20%3A%20S1%2C%20mor%20(a%20*%20b)%20%3D%20(mor%20a)%20*%20(mor%20b))%0A%0Ainstance%20morphism_to_fun%20(S1%20S2%20%3A%20Semigroup)%20%3A%0A%20%20has_coe_to_fun%20(morphism%20S1%20S2)%20(%CE%BB%20_%2C%20S1%20%E2%86%92%20S2)%20%3A%3D%0A%7B%20coe%20%3A%3D%20%CE%BB%20m%2C%20m.mor%20%7D%0A%0Alemma%20resp_mul%20%7BS1%20S2%20%3A%20Semigroup%7D%20(f%20%3A%20morphism%20S1%20S2)%20(a%20b%20%3A%20S1)%20%3A%20f%20(a%20*%20b)%20%3D%20f%20a%20*%20f%20b%20%3A%3D%0Af.resp_mul%20a%20b%0A%0A--%20BEGIN%0Atheorem%20test%20(S1%20S2%20%3A%20Semigroup)%0A%20%20%20%20(f%20%3A%20morphism%20S1%20S2)%20(a%20%3A%20S1)%20%3A%0A%20%20f%20(a%20*%20a%20*%20a)%20%3D%20f%20a%20*%20f%20a%20*%20f%20a%20%3A%3D%0Acalc%0A%20%20f%20(a%20*%20a%20*%20a)%20%3D%20f%20(a%20*%20a)%20*%20f%20a%20%3A%20by%20rw%20%5Bresp_mul%20f%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20...%20%3D%20f%20a%20*%20f%20a%20*%20f%20a%20%3A%20by%20rw%20%5Bresp_mul%20f%5D%0A%0A%23check%20%40test%0Aset_option%20pp.coercions%20false%0A%23check%20%40test%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">(</span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Semigroup</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">morphism</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">S1</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="k">calc</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">resp_mul</span><span class="w"> </span><span class="n">f</span><span class="o">]</span>
<span class="w">            </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">resp_mul</span><span class="w"> </span><span class="n">f</span><span class="o">]</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">test</span>
<span class="kd">set_option</span><span class="w"> </span><span class="n">pp.coercions</span><span class="w"> </span><span class="n">false</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">test</span>
</pre></div>
</div>
</div></section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean 3 (outdated)</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositions_and_proofs.html">3. Propositions and Proofs</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. Type Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#type-classes-and-instances">10.1. Type Classes and Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chaining-instances">10.2. Chaining Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inferring-notation">10.3. Inferring Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#decidable-propositions">10.4. Decidable Propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#managing-type-class-inference">10.5. Managing Type Class Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coercions-using-type-classes">10.6. Coercions using Type Classes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/type_classes.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>