<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>11. Axioms and Computation &#8212; Theorem Proving in Lean 3 (outdated) 3.23.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=5ca61e87" />
    <script src="_static/documentation_options.js?v=5de50469"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="10. Type Classes" href="type_classes.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="axioms-and-computation">
<span id="id1"></span><h1><span class="section-number">11. </span>Axioms and Computation<a class="headerlink" href="#axioms-and-computation" title="Link to this heading">&#182;</a></h1>
<p>We have seen that the version of the Calculus of Constructions that has been implemented in Lean includes dependent function types, inductive types, and a hierarchy of universes that starts with an impredicative, proof-irrelevant <code class="docutils literal notranslate"><span class="pre">Prop</span></code> at the bottom. In this chapter, we consider ways of extending the CIC with additional axioms and rules. Extending a foundational system in such a way is often convenient; it can make it possible to prove more theorems, as well as make it easier to prove theorems that could have been proved otherwise. But there can be negative consequences of adding additional axioms, consequences which may go beyond concerns about their correctness. In particular, the use of axioms bears on the computational content of definitions and theorems, in ways we will explore here.</p>
<p>Lean is designed to support both computational and classical reasoning. Users that are so inclined can stick to a &#8220;computationally pure&#8221; fragment, which guarantees that closed expressions in the system evaluate to canonical normal forms. In particular, any closed computationally pure expression of type <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code>, for example, will reduce to a numeral.</p>
<p>Lean&#8217;s standard library defines an additional axiom, propositional extensionality, and a quotient construction which in turn implies the principle of function extensionality. These extensions are used, for example, to develop theories of sets and finite sets. We will see below that using these theorems can block evaluation in Lean&#8217;s kernel, so that closed terms of type <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> no longer evaluate to numerals. But Lean erases types and propositional information when compiling definitions to bytecode for its virtual machine evaluator, and since these axioms only add new propositions, they are compatible with that computational interpretation. Even computationally inclined users may wish to use the classical law of the excluded middle to reason about computation. This also blocks evaluation in the kernel, but it is compatible with compilation to bytecode.</p>
<p>The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces &#8220;data&#8221; from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions as <code class="docutils literal notranslate"><span class="pre">noncomputable</span></code> to flag that fact.</p>
<p>Using a clever trick (known as Diaconescu&#8217;s theorem), one can use propositional extensionality, function extensionality, and choice to derive the law of the excluded middle. As noted above, however, use of the law of the excluded middle is still compatible with bytecode compilation and code extraction, as are other classical principles, as long as they are not used to manufacture data.</p>
<p>To summarize, then, on top of the underlying framework of universes, dependent function types, and inductive types, the standard library adds three additional components:</p>
<ul class="simple">
<li><p>the axiom of propositional extensionality</p></li>
<li><p>a quotient construction, which implies function extensionality</p></li>
<li><p>a choice principle, which produces data from an existential proposition.</p></li>
</ul>
<p>The first two of these block normalization within Lean, but are compatible with bytecode evaluation, whereas the third is not amenable to computational interpretation. We will spell out the details more precisely below.</p>
<section id="historical-and-philosophical-context">
<h2><span class="section-number">11.1. </span>Historical and Philosophical Context<a class="headerlink" href="#historical-and-philosophical-context" title="Link to this heading">&#182;</a></h2>
<p>For most of its history, mathematics was essentially computational: geometry dealt with constructions of geometric objects, algebra was concerned with algorithmic solutions to systems of equations, and analysis provided means to compute the future behavior of systems evolving over time. From the proof of a theorem to the effect that &#8220;for every <code class="docutils literal notranslate"><span class="pre">x</span></code>, there is a <code class="docutils literal notranslate"><span class="pre">y</span></code> such that &#8230;&#8221;, it was generally straightforward to extract an algorithm to compute such a <code class="docutils literal notranslate"><span class="pre">y</span></code> given <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>In the nineteenth century, however, increases in the complexity of mathematical arguments pushed mathematicians to develop new styles of reasoning that suppress algorithmic information and invoke descriptions of mathematical objects that abstract away the details of how those objects are represented. The goal was to obtain a powerful &#8220;conceptual&#8221; understanding without getting bogged down in computational details, but this had the effect of admitting mathematical theorems that are simply <em>false</em> on a direct computational reading.</p>
<p>There is still fairly uniform agreement today that computation is important to mathematics. But there are different views as to how best to address computational concerns. From a <em>constructive</em> point of view, it is a mistake to separate mathematics from its computational roots; every meaningful mathematical theorem should have a direct computational interpretation. From a <em>classical</em> point of view, it is more fruitful to maintain a separation of concerns: we can use one language and body of methods to write computer programs, while maintaining the freedom to use a nonconstructive theories and methods to reason about them. Lean is designed to support both of these approaches. Core parts of the library are developed constructively, but the system also provides support for carrying out classical mathematical reasoning.</p>
<p>Computationally, the purest part of dependent type theory avoids the use of <code class="docutils literal notranslate"><span class="pre">Prop</span></code> entirely. Inductive types and dependent function types can be viewed as data types, and terms of these types can be &#8220;evaluated&#8221; by applying reduction rules until no more rules can be applied. In principle, any closed term (that is, term with no free variables) of type <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> should evaluate to a numeral, <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(...</span> <span class="pre">(succ</span> <span class="pre">zero)...)</span></code>.</p>
<p>Introducing a proof-irrelevant <code class="docutils literal notranslate"><span class="pre">Prop</span></code> and marking theorems irreducible represents a first step towards separation of concerns. The intention is that elements of a type <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code> should play no role in computation, and so the particular construction of a term <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> is &#8220;irrelevant&#8221; in that sense. One can still define computational objects that incorporate elements of type <code class="docutils literal notranslate"><span class="pre">Prop</span></code>; the point is that these elements can help us reason about the effects of the computation, but can be ignored when we extract &#8220;code&#8221; from the term. Elements of type <code class="docutils literal notranslate"><span class="pre">Prop</span></code> are not entirely innocuous, however. They include equations <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">t</span> <span class="pre">:</span> <span class="pre">&#945;</span></code> for any type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, and such equations can be used as casts, to type check terms. Below, we will see examples of how such casts can block computation in the system. However, computation is still possible under an evaluation scheme that erases propositional content, ignores intermediate typing constraints, and reduces terms until they reach a normal form. This is precisely what Lean&#8217;s virtual machine does.</p>
<p>Having adopted a proof-irrelevant <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, one might consider it legitimate to use, for example, the law of the excluded middle, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;p</span></code>, where <code class="docutils literal notranslate"><span class="pre">p</span></code> is any proposition. Of course, this, too, can block computation according to the rules of CIC, but it does not block bytecode evaluation, as described above. It is only the choice principles discussed in <a class="reference internal" href="#choice"><span class="std std-numref">Section 11.5</span></a> that completely erase the distinction between the proof-irrelevant and data-relevant parts of the theory.</p>
</section>
<section id="propositional-extensionality">
<h2><span class="section-number">11.2. </span>Propositional Extensionality<a class="headerlink" href="#propositional-extensionality" title="Link to this heading">&#182;</a></h2>
<p>Propositional extensionality is the following axiom:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aaxiom%20propext%20%7Ba%20b%20%3A%20Prop%7D%20%3A%20(a%20%E2%86%94%20b)%20%E2%86%92%20a%20%3D%20b%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">axiom</span><span class="w"> </span><span class="n">propext</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
</div><p>It asserts that when two propositions imply one another, they are actually equal. This is consistent with set-theoretic interpretations in which any element <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">Prop</span></code> is either empty or the singleton set <code class="docutils literal notranslate"><span class="pre">{*}</span></code>, for some distinguished element <code class="docutils literal notranslate"><span class="pre">*</span></code>. The axiom has the effect that equivalent propositions can be substituted for one another in any context:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=section%0Avariables%20a%20b%20c%20d%20e%20%3A%20Prop%0Avariable%20p%20%3A%20Prop%20%E2%86%92%20Prop%0A%0Atheorem%20thm%E2%82%81%20(h%20%3A%20a%20%E2%86%94%20b)%20%3A%20(c%20%E2%88%A7%20a%20%E2%88%A7%20d%20%E2%86%92%20e)%20%E2%86%94%20(c%20%E2%88%A7%20b%20%E2%88%A7%20d%20%E2%86%92%20e)%20%3A%3D%0Apropext%20h%20%E2%96%B8%20iff.refl%20_%0A%0Atheorem%20thm%E2%82%82%20(h%20%3A%20a%20%E2%86%94%20b)%20(h%E2%82%81%20%3A%20p%20a)%20%3A%20p%20b%20%3A%3D%0Apropext%20h%20%E2%96%B8%20h%E2%82%81%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">variables</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">thm&#8321;</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">c</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="o">(</span><span class="n">c</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">propext</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="bp">&#9656;</span><span class="w"> </span><span class="n">iff.refl</span><span class="w"> </span><span class="n">_</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">thm&#8322;</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span>
<span class="n">propext</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="bp">&#9656;</span><span class="w"> </span><span class="n">h&#8321;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The first example could be proved more laboriously without <code class="docutils literal notranslate"><span class="pre">propext</span></code> using the fact that the propositional connectives respect propositional equivalence. The second example represents a more essential use of <code class="docutils literal notranslate"><span class="pre">propext</span></code>. In fact, it is equivalent to <code class="docutils literal notranslate"><span class="pre">propext</span></code> itself, a fact which we encourage you to prove.</p>
<p>Given any definition or theorem in Lean, you can use the <code class="docutils literal notranslate"><span class="pre">#print</span> <span class="pre">axioms</span></code> command to display the axioms it depends on.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20a%20b%20c%20d%20e%20%3A%20Prop%0Avariable%20p%20%3A%20Prop%20%E2%86%92%20Prop%0A%0Atheorem%20thm%E2%82%81%20(h%20%3A%20a%20%E2%86%94%20b)%20%3A%20(c%20%E2%88%A7%20a%20%E2%88%A7%20d%20%E2%86%92%20e)%20%E2%86%94%20(c%20%E2%88%A7%20b%20%E2%88%A7%20d%20%E2%86%92%20e)%20%3A%3D%0Apropext%20h%20%E2%96%B8%20iff.refl%20_%0A%0Atheorem%20thm%E2%82%82%20(h%20%3A%20a%20%E2%86%94%20b)%20(h%E2%82%81%20%3A%20p%20a)%20%3A%20p%20b%20%3A%3D%0Apropext%20h%20%E2%96%B8%20h%E2%82%81%0A%0A--%20BEGIN%0A%23print%20axioms%20thm%E2%82%81%20%20--%20propext%0A%23print%20axioms%20thm%E2%82%82%20%20--%20propext%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#print</span><span class="w"> </span><span class="kd">axioms</span><span class="w"> </span><span class="n">thm&#8321;</span><span class="w">  </span><span class="c1">-- propext</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">axioms</span><span class="w"> </span><span class="n">thm&#8322;</span><span class="w">  </span><span class="c1">-- propext</span>
</pre></div>
</div>
</div></section>
<section id="function-extensionality">
<h2><span class="section-number">11.3. </span>Function Extensionality<a class="headerlink" href="#function-extensionality" title="Link to this heading">&#182;</a></h2>
<p>Similar to propositional extensionality, function extensionality asserts that any two functions of type <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">&#946;</span> <span class="pre">x</span></code> that agree on all their inputs are equal.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universes%20u%E2%82%81%20u%E2%82%82%0A%0A%23check%20(%40funext%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%20u%E2%82%81%7D%20%7B%CE%B2%20%3A%20%CE%B1%20%E2%86%92%20Type%20u%E2%82%82%7D%0A%20%20%20%20%20%20%20%20%20%20%20%7Bf%E2%82%81%20f%E2%82%82%20%3A%20%CE%A0%20(x%20%3A%20%CE%B1)%2C%20%CE%B2%20x%7D%2C%0A%20%20%20%20%20%20%20%20%20(%E2%88%80%20(x%20%3A%20%CE%B1)%2C%20f%E2%82%81%20x%20%3D%20f%E2%82%82%20x)%20%E2%86%92%20f%E2%82%81%20%3D%20f%E2%82%82)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universes</span><span class="w"> </span><span class="n">u&#8321;</span><span class="w"> </span><span class="n">u&#8322;</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">funext</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u&#8321;</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u&#8322;</span><span class="o">}</span>
<span class="w">           </span><span class="o">{</span><span class="n">f&#8321;</span><span class="w"> </span><span class="n">f&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="n">x</span><span class="o">},</span>
<span class="w">         </span><span class="o">(</span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">f&#8321;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f&#8322;</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">f&#8321;</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f&#8322;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>From a classical, set-theoretic perspective, this is exactly what it means for two functions to be equal. This is known as an &#8220;extensional&#8221; view of functions. From a constructive perspective, however, it is sometimes more natural to think of functions as algorithms, or computer programs, that are presented in some explicit way. It is certainly the case that two computer programs can compute the same answer for every input despite the fact that they are syntactically quite different. In much the same way, you might want to maintain a view of functions that does not force you to identify two functions that have the same input / output behavior. This is known as an &#8220;intensional&#8221; view of functions.</p>
<p>In fact, function extensionality follows from the existence of quotients, which we describe in the next section. In the Lean standard library, therefore, <code class="docutils literal notranslate"><span class="pre">funext</span></code> is thus <a class="reference external" href="https://github.com/leanprover/lean/blob/master/library/init/funext.lean">proved from the quotient construction</a>.</p>
<p>Suppose that for <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">:</span> <span class="pre">Type</span></code> we define the <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&#945;</span> <span class="pre">:=</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">Prop</span></code> to denote the type of subsets of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, essentially identifying subsets with predicates. By combining <code class="docutils literal notranslate"><span class="pre">funext</span></code> and <code class="docutils literal notranslate"><span class="pre">propext</span></code>, we obtain an extensional theory of such sets:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20set%20(%CE%B1%20%3A%20Type*)%20%3A%3D%20%CE%B1%20%E2%86%92%20Prop%0A%0Anamespace%20set%0A%0Avariable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adefinition%20mem%20(x%20%3A%20%CE%B1)%20(a%20%3A%20set%20%CE%B1)%20%3A%3D%20a%20x%0Anotation%20(name%20%3A%3D%20mem)%20e%20%E2%88%88%20a%20%3A%3D%20mem%20e%20a%0A%0Atheorem%20setext%20%7Ba%20b%20%3A%20set%20%CE%B1%7D%20(h%20%3A%20%E2%88%80%20x%2C%20x%20%E2%88%88%20a%20%E2%86%94%20x%20%E2%88%88%20b)%20%3A%20a%20%3D%20b%20%3A%3D%0Afunext%20(assume%20x%2C%20propext%20(h%20x))%0A%0Aend%20set%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">set</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">definition</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">x</span>
<span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span><span class="o">)</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">a</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">setext</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span>
<span class="n">funext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">propext</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="n">x</span><span class="o">))</span>

<span class="kd">end</span><span class="w"> </span><span class="n">set</span>
</pre></div>
</div>
</div><p>We can then proceed to define the empty set and set intersection, for example, and prove set identities:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Adefinition%20set%20(%CE%B1%20%3A%20Type*)%20%3A%3D%20%CE%B1%20%E2%86%92%20Prop%0A%0Anamespace%20set%0A%0Avariable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20mem%20(x%20%3A%20%CE%B1)%20(a%20%3A%20set%20%CE%B1)%20%3A%3D%20a%20x%0A%0Ainstance%20has_mem_set%20(%CE%B1%20%3A%20Type*)%20%3A%20has_mem%20%CE%B1%20(set%20%CE%B1)%20%3A%3D%20%E2%9F%A8mem%E2%9F%A9%0A%0Atheorem%20setext%20%7Ba%20b%20%3A%20set%20%CE%B1%7D%20(h%20%3A%20%E2%88%80%20x%2C%20x%20%E2%88%88%20a%20%E2%86%94%20x%20%E2%88%88%20b)%20%3A%20a%20%3D%20b%20%3A%3D%0Afunext%20(assume%20x%2C%20propext%20(h%20x))%0A%0A--%20BEGIN%0Adefinition%20empty%20%3A%20set%20%CE%B1%20%3A%3D%20%CE%BB%20x%2C%20false%0Alocal%20notation%20(name%20%3A%3D%20empty)%20%60%E2%88%85%60%20%3A%3D%20empty%0A%0Adefinition%20inter%20(a%20b%20%3A%20set%20%CE%B1)%20%3A%20set%20%CE%B1%20%3A%3D%20%CE%BB%20x%2C%20x%20%E2%88%88%20a%20%E2%88%A7%20x%20%E2%88%88%20b%0Anotation%20(name%20%3A%3D%20inter)%20a%20%E2%88%A9%20b%20%3A%3D%20inter%20a%20b%0A%0Atheorem%20inter_self%20(a%20%3A%20set%20%CE%B1)%20%3A%20a%20%E2%88%A9%20a%20%3D%20a%20%3A%3D%0Asetext%20(assume%20x%2C%20and_self%20_)%0A%0Atheorem%20inter_empty%20(a%20%3A%20set%20%CE%B1)%20%3A%20a%20%E2%88%A9%20%E2%88%85%20%3D%20%E2%88%85%20%3A%3D%0Asetext%20(assume%20x%2C%20and_false%20_)%0A%0Atheorem%20empty_inter%20(a%20%3A%20set%20%CE%B1)%20%3A%20%E2%88%85%20%E2%88%A9%20a%20%3D%20%E2%88%85%20%3A%3D%0Asetext%20(assume%20x%2C%20false_and%20_)%0A%0Atheorem%20inter.comm%20(a%20b%20%3A%20set%20%CE%B1)%20%3A%20a%20%E2%88%A9%20b%20%3D%20b%20%E2%88%A9%20a%20%3A%3D%0Asetext%20(assume%20x%2C%20and_comm%20_%20_)%0A--%20END%0A%0Aend%20set%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">definition</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">false</span>
<span class="kn">local</span><span class="w"> </span><span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">empty</span><span class="o">)</span><span class="w"> </span><span class="bp">`&#8709;`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">empty</span>

<span class="kd">definition</span><span class="w"> </span><span class="n">inter</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="n">b</span>
<span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">inter</span><span class="o">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8745;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">inter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">inter_self</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8745;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="n">setext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">and_self</span><span class="w"> </span><span class="n">_</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">inter_empty</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8745;</span><span class="w"> </span><span class="bp">&#8709;</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="bp">&#8709;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">setext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">and_false</span><span class="w"> </span><span class="n">_</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">empty_inter</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8709;</span><span class="w"> </span><span class="bp">&#8745;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="bp">&#8709;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">setext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">false_and</span><span class="w"> </span><span class="n">_</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">inter.comm</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8745;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8745;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="n">setext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">and_comm</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The following is an example of how function extensionality blocks computation inside the Lean kernel.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Adef%20f%E2%82%81%20%20(x%20%3A%20%E2%84%95)%20%3A%3D%20x%0Adef%20f%E2%82%82%20(x%20%3A%20%E2%84%95)%20%3A%3D%200%20%2B%20x%0A%0Atheorem%20feq%20%3A%20f%E2%82%81%20%3D%20f%E2%82%82%20%3A%3D%20funext%20(assume%20x%2C%20(zero_add%20x).symm)%0A%0Adef%20val%20%3A%20%E2%84%95%20%3A%3D%20eq.rec_on%20feq%20(0%20%3A%20%E2%84%95)%0A%0A--%20complicated!%0A%23reduce%20val%0A%0A--%20evaluates%20to%200%0A%23eval%20val" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">data.nat.basic</span>

<span class="kd">def</span><span class="w"> </span><span class="n">f&#8321;</span><span class="w">  </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span>
<span class="kd">def</span><span class="w"> </span><span class="n">f&#8322;</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">x</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">feq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f&#8321;</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f&#8322;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">funext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="n">zero_add</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">eq.rec_on</span><span class="w"> </span><span class="n">feq</span><span class="w"> </span><span class="o">(</span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>

<span class="c1">-- complicated!</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">val</span>

<span class="c1">-- evaluates to 0</span>
<span class="k">#eval</span><span class="w"> </span><span class="n">val</span>
</pre></div>
</div>
</div><p>First, we show that the two functions <code class="docutils literal notranslate"><span class="pre">f&#8321;</span></code> and <code class="docutils literal notranslate"><span class="pre">f&#8322;</span></code> are equal using function extensionality, and then we cast <code class="docutils literal notranslate"><span class="pre">0</span></code> of type <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> by replacing <code class="docutils literal notranslate"><span class="pre">f&#8321;</span></code> by <code class="docutils literal notranslate"><span class="pre">f&#8322;</span></code> in the type. Of course, the cast is vacuous, because <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> does not depend on <code class="docutils literal notranslate"><span class="pre">f&#8321;</span></code>. But that is enough to do the damage: under the computational rules of the system, we now have a closed term of <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> that does not reduce to a numeral. In this case, we may be tempted to reduce the expression to <code class="docutils literal notranslate"><span class="pre">0</span></code>. But in nontrivial examples, eliminating cast changes the type of the term, which might make an ambient expression type incorrect. The virtual machine, however, has no trouble evaluating the expression to <code class="docutils literal notranslate"><span class="pre">0</span></code>. Here is a similarly contrived example that shows how <code class="docutils literal notranslate"><span class="pre">propext</span></code> can get in the way.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20tteq%20%3A%20(true%20%E2%88%A7%20true)%20%3D%20true%20%3A%3D%20propext%20(and_true%20true)%0A%0Adef%20val%20%3A%20%E2%84%95%20%3A%3D%20eq.rec_on%20tteq%200%0A%0A--%20complicated!%0A%23reduce%20val%0A%0A--%20evaluates%20to%200%0A%23eval%20val" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">tteq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">true</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">true</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">propext</span><span class="w"> </span><span class="o">(</span><span class="n">and_true</span><span class="w"> </span><span class="n">true</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">eq.rec_on</span><span class="w"> </span><span class="n">tteq</span><span class="w"> </span><span class="mi">0</span>

<span class="c1">-- complicated!</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">val</span>

<span class="c1">-- evaluates to 0</span>
<span class="k">#eval</span><span class="w"> </span><span class="n">val</span>
</pre></div>
</div>
</div><p>Current research programs, including work on <em>observational type theory</em> and <em>cubical type theory</em>, aim to extend type theory in ways that permit reductions for casts involving function extensionality, quotients, and more. But the solutions are not so clear cut, and the rules of Lean&#8217;s underlying calculus do not sanction such reductions.</p>
<p>In a sense, however, a cast does not change the meaning of an expression. Rather, it is a mechanism to reason about the expression&#8217;s type. Given an appropriate semantics, it then makes sense to reduce terms in ways that preserve their meaning, ignoring the intermediate bookkeeping needed to make the reductions type correct. In that case, adding new axioms in <code class="docutils literal notranslate"><span class="pre">Prop</span></code> does not matter; by proof irrelevance, an expression in <code class="docutils literal notranslate"><span class="pre">Prop</span></code> carries no information, and can be safely ignored by the reduction procedures.</p>
</section>
<section id="quotients">
<h2><span class="section-number">11.4. </span>Quotients<a class="headerlink" href="#quotients" title="Link to this heading">&#182;</a></h2>
<p>Let <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> be any type, and let <code class="docutils literal notranslate"><span class="pre">r</span></code> be an equivalence relation on <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. It is mathematically common to form the &#8220;quotient&#8221; <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">/</span> <span class="pre">r</span></code>, that is, the type of elements of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> &#8220;modulo&#8221; <code class="docutils literal notranslate"><span class="pre">r</span></code>. Set theoretically, one can view <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">/</span> <span class="pre">r</span></code> as the set of equivalence classes of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> modulo <code class="docutils literal notranslate"><span class="pre">r</span></code>. If <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code> is any function that respects the equivalence relation in the sense that for every <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">x</span> <span class="pre">y</span></code> implies <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">y</span></code>, then <code class="docutils literal notranslate"><span class="pre">f</span></code> &#8220;lifts&#8221; to a function <code class="docutils literal notranslate"><span class="pre">f'</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">/</span> <span class="pre">r</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code> defined on each equivalence class <code class="docutils literal notranslate"><span class="pre">&#10214;x&#10215;</span></code> by <code class="docutils literal notranslate"><span class="pre">f'</span> <span class="pre">&#10214;x&#10215;</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">x</span></code>. Lean&#8217;s standard library extends the Calculus of Constructions with additional constants that perform exactly these constructions, and installs this last equation as a definitional reduction rule.</p>
<p>In its most basic form, the quotient construction does not even require <code class="docutils literal notranslate"><span class="pre">r</span></code> to be an equivalence relation. The following constants are built into Lean:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Auniverses%20u%20v%0A%0Aconstant%20quot%20%3A%20%CE%A0%20%7B%CE%B1%20%3A%20Sort%20u%7D%2C%20(%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop)%20%E2%86%92%20Sort%20u%0A%0Aconstant%20quot.mk%20%3A%0A%20%20%CE%A0%20%7B%CE%B1%20%3A%20Sort%20u%7D%20(r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop)%2C%20%CE%B1%20%E2%86%92%20quot%20r%0A%0Aaxiom%20quot.ind%20%3A%0A%20%20%E2%88%80%20%7B%CE%B1%20%3A%20Sort%20u%7D%20%7Br%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop%7D%20%7B%CE%B2%20%3A%20quot%20r%20%E2%86%92%20Prop%7D%2C%0A%20%20%20%20(%E2%88%80%20a%2C%20%CE%B2%20(quot.mk%20r%20a))%20%E2%86%92%20%E2%88%80%20(q%20%3A%20quot%20r)%2C%20%CE%B2%20q%0A%0Aconstant%20quot.lift%20%3A%0A%20%20%CE%A0%20%7B%CE%B1%20%3A%20Sort%20u%7D%20%7Br%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop%7D%20%7B%CE%B2%20%3A%20Sort%20u%7D%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2)%2C%0A%20%20%20%20(%E2%88%80%20a%20b%2C%20r%20a%20b%20%E2%86%92%20f%20a%20%3D%20f%20b)%20%E2%86%92%20quot%20r%20%E2%86%92%20%CE%B2%0A%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>

<span class="kd">constant</span><span class="w"> </span><span class="n">quot</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">},</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span>

<span class="kd">constant</span><span class="w"> </span><span class="n">quot.mk</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">),</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">quot</span><span class="w"> </span><span class="n">r</span>

<span class="kd">axiom</span><span class="w"> </span><span class="n">quot.ind</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">quot</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">},</span>
<span class="w">    </span><span class="o">(</span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">(</span><span class="n">quot.mk</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="o">))</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">quot</span><span class="w"> </span><span class="n">r</span><span class="o">),</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="n">q</span>

<span class="kd">constant</span><span class="w"> </span><span class="n">quot.lift</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">),</span>
<span class="w">    </span><span class="o">(</span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">quot</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span>
</pre></div>
</div>
</div><p>The first one forms a type <code class="docutils literal notranslate"><span class="pre">quot</span> <span class="pre">r</span></code> given a type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> by any binary relation <code class="docutils literal notranslate"><span class="pre">r</span></code> on <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. The second maps <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> to <code class="docutils literal notranslate"><span class="pre">quot</span> <span class="pre">&#945;</span></code>, so that if <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">Prop</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, then <code class="docutils literal notranslate"><span class="pre">quot.mk</span> <span class="pre">r</span> <span class="pre">a</span></code> is an element of <code class="docutils literal notranslate"><span class="pre">quot</span> <span class="pre">r</span></code>. The third principle, <code class="docutils literal notranslate"><span class="pre">quot.ind</span></code>, says that every element of <code class="docutils literal notranslate"><span class="pre">quot.mk</span> <span class="pre">r</span> <span class="pre">a</span></code> is of this form.  As for <code class="docutils literal notranslate"><span class="pre">quot.lift</span></code>, given a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code>, if <code class="docutils literal notranslate"><span class="pre">h</span></code> is a proof that <code class="docutils literal notranslate"><span class="pre">f</span></code> respects the relation <code class="docutils literal notranslate"><span class="pre">r</span></code>, then <code class="docutils literal notranslate"><span class="pre">quot.lift</span> <span class="pre">f</span> <span class="pre">h</span></code> is the corresponding function on <code class="docutils literal notranslate"><span class="pre">quot</span> <span class="pre">r</span></code>. The idea is that for each element <code class="docutils literal notranslate"><span class="pre">a</span></code> in <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, the function <code class="docutils literal notranslate"><span class="pre">quot.lift</span> <span class="pre">f</span> <span class="pre">h</span></code> maps <code class="docutils literal notranslate"><span class="pre">quot.mk</span> <span class="pre">r</span> <span class="pre">a</span></code> (the <code class="docutils literal notranslate"><span class="pre">r</span></code>-class containing <code class="docutils literal notranslate"><span class="pre">a</span></code>) to <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>, wherein <code class="docutils literal notranslate"><span class="pre">h</span></code> shows that this function is well defined. In fact, the computation principle is declared as a reduction rule, as the proof below makes clear.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%CE%B1%20%CE%B2%20%3A%20Type*%0Avariable%20%20r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop%0Avariable%20%20a%20%3A%20%CE%B1%0A%0A--%20the%20quotient%20type%0A%23check%20(quot%20r%20%3A%20Type*)%0A%0A--%20the%20class%20of%20a%0A%23check%20(quot.mk%20r%20a%20%3A%20quot%20r)%0A%0Avariable%20%20f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%0Avariable%20%20%20h%20%3A%20%E2%88%80%20a%E2%82%81%20a%E2%82%82%2C%20r%20a%E2%82%81%20a%E2%82%82%20%E2%86%92%20f%20a%E2%82%81%20%3D%20f%20a%E2%82%82%0A%0A--%20the%20corresponding%20function%20on%20quot%20r%0A%23check%20(quot.lift%20f%20h%20%3A%20quot%20r%20%E2%86%92%20%CE%B2)%0A%0A--%20the%20computation%20principle%0Atheorem%20thm%20%3A%20quot.lift%20f%20h%20(quot.mk%20r%20a)%20%3D%20f%20a%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span>
<span class="kd">variable</span><span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">variable</span><span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span>

<span class="c1">-- the quotient type</span>
<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">quot</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="c1">-- the class of a</span>
<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">quot.mk</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">quot</span><span class="w"> </span><span class="n">r</span><span class="o">)</span>

<span class="kd">variable</span><span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span>
<span class="kd">variable</span><span class="w">   </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="n">a&#8322;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a&#8322;</span>

<span class="c1">-- the corresponding function on quot r</span>
<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">quot.lift</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">quot</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span>

<span class="c1">-- the computation principle</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">thm</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">quot.lift</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">(</span><span class="n">quot.mk</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>The four constants, <code class="docutils literal notranslate"><span class="pre">quot</span></code>, <code class="docutils literal notranslate"><span class="pre">quot.mk</span></code>, <code class="docutils literal notranslate"><span class="pre">quot.ind</span></code>, and <code class="docutils literal notranslate"><span class="pre">quot.lift</span></code> in and of themselves are not very strong. You can check that the <code class="docutils literal notranslate"><span class="pre">quot.ind</span></code> is satisfied if we take <code class="docutils literal notranslate"><span class="pre">quot</span> <span class="pre">r</span></code> to be simply <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, and take <code class="docutils literal notranslate"><span class="pre">quot.lift</span></code> to be the identity function (ignoring <code class="docutils literal notranslate"><span class="pre">h</span></code>). For that reason, these four constants are not viewed as additional axioms:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%CE%B1%20%CE%B2%20%3A%20Type%0Avariable%20%20r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop%0Avariable%20%20a%20%3A%20%CE%B1%0Avariable%20%20f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%0Avariable%20%20%20h%20%3A%20%E2%88%80%20a%E2%82%81%20a%E2%82%82%2C%20r%20a%E2%82%81%20a%E2%82%82%20%E2%86%92%20f%20a%E2%82%81%20%3D%20f%20a%E2%82%82%0Atheorem%20thm%20%3A%20quot.lift%20f%20h%20(quot.mk%20r%20a)%20%3D%20f%20a%20%3A%3D%20rfl%0A%0A--%20BEGIN%0A%23print%20axioms%20thm%20%20%20--%20no%20axioms%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#print</span><span class="w"> </span><span class="kd">axioms</span><span class="w"> </span><span class="n">thm</span><span class="w">   </span><span class="c1">-- no axioms</span>
</pre></div>
</div>
</div><p>They are, like inductively defined types and the associated constructors and recursors, viewed as part of the logical framework.</p>
<p>What makes the <code class="docutils literal notranslate"><span class="pre">quot</span></code> construction into a bona fide quotient is the following additional axiom:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aaxiom%20quot.sound%20%3A%0A%20%20%E2%88%80%20%7B%CE%B1%20%3A%20Type*%7D%20%7Br%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop%7D%20%7Ba%20b%20%3A%20%CE%B1%7D%2C%0A%20%20%20%20r%20a%20b%20%E2%86%92%20quot.mk%20r%20a%20%3D%20quot.mk%20r%20b%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">axiom</span><span class="w"> </span><span class="n">quot.sound</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">},</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">quot.mk</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">quot.mk</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
</div><p>This is the axiom that asserts that any two elements of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> that are related by <code class="docutils literal notranslate"><span class="pre">r</span></code> become identified in the quotient. If a theorem or definition makes use of <code class="docutils literal notranslate"><span class="pre">quot.sound</span></code>, it will show up in the <code class="docutils literal notranslate"><span class="pre">#print</span> <span class="pre">axioms</span></code> command.</p>
<p>Of course, the quotient construction is most commonly used in situations when <code class="docutils literal notranslate"><span class="pre">r</span></code> is an equivalence relation. Given <code class="docutils literal notranslate"><span class="pre">r</span></code> as above, if we define <code class="docutils literal notranslate"><span class="pre">r'</span></code> according to the rule <code class="docutils literal notranslate"><span class="pre">r'</span> <span class="pre">a</span> <span class="pre">b</span></code> iff <code class="docutils literal notranslate"><span class="pre">quot.mk</span> <span class="pre">r</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">quot.mk</span> <span class="pre">r</span> <span class="pre">b</span></code>, then it&#8217;s clear that <code class="docutils literal notranslate"><span class="pre">r'</span></code> is an equivalence relation. Indeed, <code class="docutils literal notranslate"><span class="pre">r'</span></code> is the <em>kernel</em> of the function <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8614;</span> <span class="pre">quot.mk</span> <span class="pre">r</span> <span class="pre">a</span></code>.  The axiom <code class="docutils literal notranslate"><span class="pre">quot.sound</span></code> says that <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">a</span> <span class="pre">b</span></code> implies <code class="docutils literal notranslate"><span class="pre">r'</span> <span class="pre">a</span> <span class="pre">b</span></code>. Using <code class="docutils literal notranslate"><span class="pre">quot.lift</span></code> and <code class="docutils literal notranslate"><span class="pre">quot.ind</span></code>, we can show that <code class="docutils literal notranslate"><span class="pre">r'</span></code> is the smallest equivalence relation containing <code class="docutils literal notranslate"><span class="pre">r</span></code>, in the sense that if <code class="docutils literal notranslate"><span class="pre">r''</span></code> is any equivalence relation containing <code class="docutils literal notranslate"><span class="pre">r</span></code>, then <code class="docutils literal notranslate"><span class="pre">r'</span> <span class="pre">a</span> <span class="pre">b</span></code> implies <code class="docutils literal notranslate"><span class="pre">r''</span> <span class="pre">a</span> <span class="pre">b</span></code>. In particular, if <code class="docutils literal notranslate"><span class="pre">r</span></code> was an equivalence relation to start with, then for all <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> we have <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">a</span> <span class="pre">b</span></code> iff <code class="docutils literal notranslate"><span class="pre">r'</span> <span class="pre">a</span> <span class="pre">b</span></code>.</p>
<p>To support this common use case, the standard library defines the notion of a <em>setoid</em>, which is simply a type with an associated equivalence relation:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aclass%20setoid%20(%CE%B1%20%3A%20Type*)%20%3A%3D%0A(r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop)%20(iseqv%20%3A%20equivalence%20r)%0A%0Anamespace%20setoid%0Ainfix%20(name%20%3A%3D%20r)%20%60%E2%89%88%60%20%3A%3D%20setoid.r%0A%0Avariable%20%7B%CE%B1%20%3A%20Type*%7D%0Avariable%20%5Bs%20%3A%20setoid%20%CE%B1%5D%0Ainclude%20s%0A%0Atheorem%20refl%20(a%20%3A%20%CE%B1)%20%3A%20a%20%E2%89%88%20a%20%3A%3D%0A(%40setoid.iseqv%20%CE%B1%20s).left%20a%0A%0Atheorem%20symm%20%7Ba%20b%20%3A%20%CE%B1%7D%20%3A%20a%20%E2%89%88%20b%20%E2%86%92%20b%20%E2%89%88%20a%20%3A%3D%0A%CE%BB%20h%2C%20(%40setoid.iseqv%20%CE%B1%20s).right.left%20h%0A%0Atheorem%20trans%20%7Ba%20b%20c%20%3A%20%CE%B1%7D%20%3A%20a%20%E2%89%88%20b%20%E2%86%92%20b%20%E2%89%88%20c%20%E2%86%92%20a%20%E2%89%88%20c%20%3A%3D%0A%CE%BB%20h%E2%82%81%20h%E2%82%82%2C%20(%40setoid.iseqv%20%CE%B1%20s).right.right%20h%E2%82%81%20h%E2%82%82%0Aend%20setoid%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="n">setoid</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">iseqv</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">equivalence</span><span class="w"> </span><span class="n">r</span><span class="o">)</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">setoid</span>
<span class="kd">infix</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="bp">`&#8776;`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">setoid.r</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variable</span><span class="w"> </span><span class="o">[</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">setoid</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span>
<span class="kn">include</span><span class="w"> </span><span class="n">s</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">refl</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8776;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="bp">@</span><span class="n">setoid.iseqv</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span><span class="w"> </span><span class="n">a</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">symm</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8776;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8776;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">setoid.iseqv</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">right.left</span><span class="w"> </span><span class="n">h</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">trans</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8776;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8776;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8776;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">setoid.iseqv</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">right.right</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span>
<span class="kd">end</span><span class="w"> </span><span class="n">setoid</span>
</pre></div>
</div>
</div><p>Given a type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, a relation <code class="docutils literal notranslate"><span class="pre">r</span></code> on <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, and a proof <code class="docutils literal notranslate"><span class="pre">p</span></code> that <code class="docutils literal notranslate"><span class="pre">r</span></code> is an equivalence relation, we can define <code class="docutils literal notranslate"><span class="pre">setoid.mk</span> <span class="pre">p</span></code> as an instance of the setoid class.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20quotient%20%7B%CE%B1%20%3A%20Type*%7D%20(s%20%3A%20setoid%20%CE%B1)%20%3A%3D%0A%40quot%20%CE%B1%20setoid.r%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">quotient</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">setoid</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">@</span><span class="n">quot</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">setoid.r</span>
</pre></div>
</div>
</div><p>The constants <code class="docutils literal notranslate"><span class="pre">quotient.mk</span></code>, <code class="docutils literal notranslate"><span class="pre">quotient.ind</span></code>, <code class="docutils literal notranslate"><span class="pre">quotient.lift</span></code>, and <code class="docutils literal notranslate"><span class="pre">quotient.sound</span></code> are nothing more than the specializations of the corresponding elements of <code class="docutils literal notranslate"><span class="pre">quot</span></code>. The fact that type class inference can find the setoid associated to a type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> brings a number of benefits. First, we can use the notation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8776;</span> <span class="pre">b</span></code> (entered with <code class="docutils literal notranslate"><span class="pre">\approx</span></code>) for <code class="docutils literal notranslate"><span class="pre">setoid.r</span> <span class="pre">a</span> <span class="pre">b</span></code>, where the instance of <code class="docutils literal notranslate"><span class="pre">setoid</span></code> is implicit in the notation <code class="docutils literal notranslate"><span class="pre">setoid.r</span></code>. We can use the generic theorems <code class="docutils literal notranslate"><span class="pre">setoid.refl</span></code>, <code class="docutils literal notranslate"><span class="pre">setoid.symm</span></code>, <code class="docutils literal notranslate"><span class="pre">setoid.trans</span></code> to reason about the relation. Specifically with quotients we can use the generic notation <code class="docutils literal notranslate"><span class="pre">&#10214;a&#10215;</span></code> for <code class="docutils literal notranslate"><span class="pre">quot.mk</span> <span class="pre">setoid.r</span></code> where the instance of <code class="docutils literal notranslate"><span class="pre">setoid</span></code> is implicit in the notation <code class="docutils literal notranslate"><span class="pre">setoid.r</span></code>, as well as the theorem <code class="docutils literal notranslate"><span class="pre">quotient.exact</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7B%CE%B1%20%3A%20Type*%7D%20%5Bsetoid%20%CE%B1%5D%20(a%20b%20%3A%20%CE%B1)%0A%0A%23check%20(quotient.exact%20%3A%20%E2%9F%A6a%E2%9F%A7%20%3D%20%E2%9F%A6b%E2%9F%A7%20%E2%86%92%20a%20%E2%89%88%20b)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">setoid</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">quotient.exact</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#10214;</span><span class="n">a</span><span class="bp">&#10215;</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="bp">&#10214;</span><span class="n">b</span><span class="bp">&#10215;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8776;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Together with <code class="docutils literal notranslate"><span class="pre">quotient.sound</span></code>, this implies that the elements of the quotient correspond exactly to the equivalence classes of elements in <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.</p>
<p>Recall that in the standard library, <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#215;</span> <span class="pre">&#946;</span></code> represents the Cartesian product of the types <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>. To illustrate the use of quotients, let us define the type of <em>unordered</em> pairs of elements of a type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> as a quotient of the type <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#215;</span> <span class="pre">&#945;</span></code>. First, we define the relevant equivalence relation:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=private%20definition%20eqv%20%7B%CE%B1%20%3A%20Type*%7D%20(p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1)%20%3A%20Prop%20%3A%3D%0A(p%E2%82%81.1%20%3D%20p%E2%82%82.1%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.2)%20%E2%88%A8%20(p%E2%82%81.1%20%3D%20p%E2%82%82.2%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.1)%0A%0Ainfix%20(name%20%3A%3D%20eqv)%20%60~%60%3A50%20%3A%3D%20eqv" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">private</span><span class="w"> </span><span class="kd">definition</span><span class="w"> </span><span class="n">eqv</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p&#8321;</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">p&#8321;</span><span class="bp">.</span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p&#8322;</span><span class="bp">.</span><span class="mi">1</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p&#8321;</span><span class="bp">.</span><span class="mi">2</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p&#8322;</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">p&#8321;</span><span class="bp">.</span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p&#8322;</span><span class="bp">.</span><span class="mi">2</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p&#8321;</span><span class="bp">.</span><span class="mi">2</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">p&#8322;</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>

<span class="kd">infix</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">eqv</span><span class="o">)</span><span class="w"> </span><span class="bp">`~`</span><span class="o">:</span><span class="mi">50</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">eqv</span>
</pre></div>
</div>
</div><p>The next step is to prove that <code class="docutils literal notranslate"><span class="pre">eqv</span></code> is in fact an equivalence relation, which is to say, it is reflexive, symmetric and transitive. We can prove these three facts in a convenient and readable way by using dependent pattern matching to perform case-analysis and break the hypotheses into pieces that are then reassembled to produce the conclusion.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=private%20definition%20eqv%20%7B%CE%B1%20%3A%20Type*%7D%20(p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1)%20%3A%20Prop%20%3A%3D%0A(p%E2%82%81.1%20%3D%20p%E2%82%82.1%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.2)%20%E2%88%A8%20(p%E2%82%81.1%20%3D%20p%E2%82%82.2%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.1)%0A%0Alocal%20infix%20(name%20%3A%3D%20eqv)%20%60~%60%3A50%20%3A%3D%20eqv%0A%0A--%20BEGIN%0Aopen%20or%0A%0Aprivate%20theorem%20eqv.refl%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%0A%20%20%E2%88%80%20p%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%20~%20p%20%3A%3D%0Aassume%20p%2C%20inl%20%E2%9F%A8rfl%2C%20rfl%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.symm%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%0A%20%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%81%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20%20%20inl%20%E2%9F%A8symm%20a%E2%82%81b%E2%82%81%2C%20symm%20a%E2%82%82b%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20%20%20inr%20%E2%9F%A8symm%20a%E2%82%82b%E2%82%81%2C%20symm%20a%E2%82%81b%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.trans%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%0A%20%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20p%E2%82%83%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%83%20%E2%86%92%20p%E2%82%81%20~%20p%E2%82%83%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%0A%20%20%20%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%0A%20%20%20%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%0A%20%20%20%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%0A%20%20%20%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20is_equivalence%20(%CE%B1%20%3A%20Type*)%20%3A%0A%20%20equivalence%20(%40eqv%20%CE%B1)%20%3A%3D%0Amk_equivalence%20(%40eqv%20%CE%B1)%20(%40eqv.refl%20%CE%B1)%20(%40eqv.symm%20%CE%B1)%0A%20%20(%40eqv.trans%20%CE%B1)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">or</span>

<span class="kn">private</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">eqv.refl</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">~</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">rfl</span><span class="o">,</span><span class="w"> </span><span class="n">rfl</span><span class="o">&#10217;</span>

<span class="kn">private</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">eqv.symm</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">p&#8321;</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">p&#8321;</span><span class="w"> </span><span class="bp">~</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="bp">~</span><span class="w"> </span><span class="n">p&#8321;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">    </span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">symm</span><span class="w"> </span><span class="n">a&#8321;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">symm</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="o">&#10217;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">    </span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">symm</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">symm</span><span class="w"> </span><span class="n">a&#8321;b&#8322;</span><span class="o">&#10217;</span>

<span class="kn">private</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">eqv.trans</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">p&#8321;</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="n">p&#8323;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">p&#8321;</span><span class="w"> </span><span class="bp">~</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="bp">~</span><span class="w"> </span><span class="n">p&#8323;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p&#8321;</span><span class="w"> </span><span class="bp">~</span><span class="w"> </span><span class="n">p&#8323;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">c&#8322;</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">(</span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">b&#8321;c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;c&#8322;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8321;b&#8321;</span><span class="w"> </span><span class="n">b&#8321;c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="w"> </span><span class="n">b&#8322;c&#8322;</span><span class="o">&#10217;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">c&#8322;</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">(</span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">b&#8321;c&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;c&#8321;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8321;b&#8321;</span><span class="w"> </span><span class="n">b&#8321;c&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="w"> </span><span class="n">b&#8322;c&#8321;</span><span class="o">&#10217;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">c&#8322;</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">(</span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">b&#8321;c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;c&#8322;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8321;b&#8322;</span><span class="w"> </span><span class="n">b&#8322;c&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="w"> </span><span class="n">b&#8321;c&#8321;</span><span class="o">&#10217;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">c&#8322;</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">(</span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">b&#8321;c&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;c&#8321;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8321;b&#8322;</span><span class="w"> </span><span class="n">b&#8322;c&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">trans</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="w"> </span><span class="n">b&#8321;c&#8322;</span><span class="o">&#10217;</span>

<span class="kn">private</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">is_equivalence</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">equivalence</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">eqv</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">mk_equivalence</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">eqv</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">eqv.refl</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">eqv.symm</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="bp">@</span><span class="n">eqv.trans</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>We open the namespaces <code class="docutils literal notranslate"><span class="pre">or</span></code> and <code class="docutils literal notranslate"><span class="pre">eq</span></code> to be able to use <code class="docutils literal notranslate"><span class="pre">or.inl</span></code>, <code class="docutils literal notranslate"><span class="pre">or.inr</span></code>, and <code class="docutils literal notranslate"><span class="pre">eq.trans</span></code> more conveniently.</p>
<p>Now that we have proved that <code class="docutils literal notranslate"><span class="pre">eqv</span></code> is an equivalence relation, we can construct a <code class="docutils literal notranslate"><span class="pre">setoid</span> <span class="pre">(&#945;</span> <span class="pre">&#215;</span> <span class="pre">&#945;)</span></code>, and use it to define the type <code class="docutils literal notranslate"><span class="pre">uprod</span> <span class="pre">&#945;</span></code> of unordered pairs.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=private%20definition%20eqv%20%7B%CE%B1%20%3A%20Type*%7D%20(p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1)%20%3A%20Prop%20%3A%3D%0A(p%E2%82%81.1%20%3D%20p%E2%82%82.1%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.2)%20%E2%88%A8%20(p%E2%82%81.1%20%3D%20p%E2%82%82.2%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.1)%0A%0Alocal%20infix%20(name%20%3A%3D%20eqv)%20%60~%60%3A50%20%3A%3D%20eqv%0A%0Aopen%20or%0A%0Aprivate%20theorem%20eqv.refl%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%20~%20p%20%3A%3D%0Aassume%20p%2C%20inl%20%E2%9F%A8rfl%2C%20rfl%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.symm%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%81%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20%3A%3D%20inl%20%E2%9F%A8symm%20a%E2%82%81b%E2%82%81%2C%20symm%20a%E2%82%82b%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20%3A%3D%20inr%20%E2%9F%A8symm%20a%E2%82%82b%E2%82%81%2C%20symm%20a%E2%82%81b%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.trans%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20p%E2%82%83%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%83%20%E2%86%92%20p%E2%82%81%20~%20p%E2%82%83%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20is_equivalence%20(%CE%B1%20%3A%20Type*)%20%3A%20equivalence%20(%40eqv%20%CE%B1)%20%3A%3D%0Amk_equivalence%20(%40eqv%20%CE%B1)%20(%40eqv.refl%20%CE%B1)%20(%40eqv.symm%20%CE%B1)%20(%40eqv.trans%20%CE%B1)%0A%0A--%20BEGIN%0Ainstance%20uprod.setoid%20(%CE%B1%20%3A%20Type*)%20%3A%20setoid%20(%CE%B1%20%C3%97%20%CE%B1)%20%3A%3D%0Asetoid.mk%20(%40eqv%20%CE%B1)%20(is_equivalence%20%CE%B1)%0A%0Adefinition%20uprod%20(%CE%B1%20%3A%20Type*)%20%3A%20Type*%20%3A%3D%0Aquotient%20(uprod.setoid%20%CE%B1)%0A%0Anamespace%20uprod%0Adefinition%20mk%20%7B%CE%B1%20%3A%20Type*%7D%20(a%E2%82%81%20a%E2%82%82%20%3A%20%CE%B1)%20%3A%20uprod%20%CE%B1%20%3A%3D%0A%E2%9F%A6(a%E2%82%81%2C%20a%E2%82%82)%E2%9F%A7%0A%0Alocal%20notation%20%60%7B%60%20a%E2%82%81%20%60%2C%60%20a%E2%82%82%20%60%7D%60%20%3A%3D%20mk%20a%E2%82%81%20a%E2%82%82%0Aend%20uprod%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">uprod.setoid</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">setoid</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">setoid.mk</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">eqv</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">is_equivalence</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>

<span class="kd">definition</span><span class="w"> </span><span class="n">uprod</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="w"> </span><span class="o">:=</span>
<span class="n">quotient</span><span class="w"> </span><span class="o">(</span><span class="n">uprod.setoid</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">uprod</span>
<span class="kd">definition</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="w"> </span><span class="n">a&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">uprod</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#10214;</span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="bp">&#10215;</span>

<span class="kn">local</span><span class="w"> </span><span class="kd">notation</span><span class="w"> </span><span class="bp">`</span><span class="o">{</span><span class="bp">`</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="bp">`</span><span class="o">,</span><span class="bp">`</span><span class="w"> </span><span class="n">a&#8322;</span><span class="w"> </span><span class="bp">`</span><span class="o">}</span><span class="bp">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="n">a&#8322;</span>
<span class="kd">end</span><span class="w"> </span><span class="n">uprod</span>
</pre></div>
</div>
</div><p>Notice that we locally define the notation <code class="docutils literal notranslate"><span class="pre">{a&#8321;,</span> <span class="pre">a&#8322;}</span></code> for ordered pairs as <code class="docutils literal notranslate"><span class="pre">&#10214;(a&#8321;,</span> <span class="pre">a&#8322;)&#10215;</span></code>. This is useful for illustrative purposes, but it is not a good idea in general, since the notation will shadow other uses of curly brackets, such as for records and sets.</p>
<p>We can easily prove that <code class="docutils literal notranslate"><span class="pre">{a&#8321;,</span> <span class="pre">a&#8322;}</span> <span class="pre">=</span> <span class="pre">{a&#8322;,</span> <span class="pre">a&#8321;}</span></code> using <code class="docutils literal notranslate"><span class="pre">quot.sound</span></code>, since we have <code class="docutils literal notranslate"><span class="pre">(a&#8321;,</span> <span class="pre">a&#8322;)</span> <span class="pre">~</span> <span class="pre">(a&#8322;,</span> <span class="pre">a&#8321;)</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=private%20definition%20eqv%20%7B%CE%B1%20%3A%20Type*%7D%20(p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1)%20%3A%20Prop%20%3A%3D%0A(p%E2%82%81.1%20%3D%20p%E2%82%82.1%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.2)%20%E2%88%A8%20(p%E2%82%81.1%20%3D%20p%E2%82%82.2%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.1)%0A%0Alocal%20infix%20(name%20%3A%3D%20eqv)%20%60~%60%3A50%20%3A%3D%20eqv%0A%0Aopen%20or%0A%0Aprivate%20theorem%20eqv.refl%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%20~%20p%20%3A%3D%0Aassume%20p%2C%20inl%20%E2%9F%A8rfl%2C%20rfl%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.symm%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%81%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20%3A%3D%20inl%20%E2%9F%A8symm%20a%E2%82%81b%E2%82%81%2C%20symm%20a%E2%82%82b%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20%3A%3D%20inr%20%E2%9F%A8symm%20a%E2%82%82b%E2%82%81%2C%20symm%20a%E2%82%81b%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.trans%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20p%E2%82%83%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%83%20%E2%86%92%20p%E2%82%81%20~%20p%E2%82%83%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20is_equivalence%20(%CE%B1%20%3A%20Type*)%20%3A%20equivalence%20(%40eqv%20%CE%B1)%20%3A%3D%0Amk_equivalence%20(%40eqv%20%CE%B1)%20(%40eqv.refl%20%CE%B1)%20(%40eqv.symm%20%CE%B1)%20(%40eqv.trans%20%CE%B1)%0A%0Ainstance%20uprod.setoid%20(%CE%B1%20%3A%20Type*)%20%3A%20setoid%20(%CE%B1%20%C3%97%20%CE%B1)%20%3A%3D%0Asetoid.mk%20(%40eqv%20%CE%B1)%20(is_equivalence%20%CE%B1)%0A%0Adefinition%20uprod%20(%CE%B1%20%3A%20Type*)%20%3A%3D%0Aquotient%20(uprod.setoid%20%CE%B1)%0A%0Anamespace%20uprod%0Adefinition%20mk%20%7B%CE%B1%20%3A%20Type*%7D%20(a%E2%82%81%20a%E2%82%82%20%3A%20%CE%B1)%20%3A%20uprod%20%CE%B1%20%3A%3D%0A%E2%9F%A6(a%E2%82%81%2C%20a%E2%82%82)%E2%9F%A7%0A%0Alocal%20notation%20%60%7B%60%20a%E2%82%81%20%60%2C%60%20a%E2%82%82%20%60%7D%60%20%3A%3D%20mk%20a%E2%82%81%20a%E2%82%82%0A%0A--%20BEGIN%0Atheorem%20mk_eq_mk%20%7B%CE%B1%20%3A%20Type*%7D%20(a%E2%82%81%20a%E2%82%82%20%3A%20%CE%B1)%20%3A%0A%20%20%7Ba%E2%82%81%2C%20a%E2%82%82%7D%20%3D%20%7Ba%E2%82%82%2C%20a%E2%82%81%7D%20%3A%3D%0Aquot.sound%20(inr%20%E2%9F%A8rfl%2C%20rfl%E2%9F%A9)%0A--%20END%0Aend%20uprod" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">mk_eq_mk</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="w"> </span><span class="n">a&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="o">{</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">}</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">{</span><span class="n">a&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8321;</span><span class="o">}</span><span class="w"> </span><span class="o">:=</span>
<span class="n">quot.sound</span><span class="w"> </span><span class="o">(</span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">rfl</span><span class="o">,</span><span class="w"> </span><span class="n">rfl</span><span class="o">&#10217;)</span>
</pre></div>
</div>
</div><p>To complete the example, given <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">:</span> <span class="pre">uprod</span> <span class="pre">&#945;</span></code>, we define the proposition <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8712;</span> <span class="pre">u</span></code> which should hold if <code class="docutils literal notranslate"><span class="pre">a</span></code> is one of the elements of the unordered pair <code class="docutils literal notranslate"><span class="pre">u</span></code>. First, we define a similar proposition <code class="docutils literal notranslate"><span class="pre">mem_fn</span> <span class="pre">a</span> <span class="pre">u</span></code> on (ordered) pairs; then we show that <code class="docutils literal notranslate"><span class="pre">mem_fn</span></code> respects the equivalence relation <code class="docutils literal notranslate"><span class="pre">eqv</span></code> with the lemma <code class="docutils literal notranslate"><span class="pre">mem_respects</span></code>. This is an idiom that is used extensively in the Lean standard library.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=private%20definition%20eqv%20%7B%CE%B1%20%3A%20Type*%7D%20(p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1)%20%3A%20Prop%20%3A%3D%0A(p%E2%82%81.1%20%3D%20p%E2%82%82.1%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.2)%20%E2%88%A8%20(p%E2%82%81.1%20%3D%20p%E2%82%82.2%20%E2%88%A7%20p%E2%82%81.2%20%3D%20p%E2%82%82.1)%0A%0Alocal%20infix%20(name%20%3A%3D%20eqv)%20%60~%60%3A50%20%3A%3D%20eqv%0A%0Aopen%20or%0A%0Aprivate%20theorem%20eqv.refl%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%20~%20p%20%3A%3D%0Aassume%20p%2C%20inl%20%E2%9F%A8rfl%2C%20rfl%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.symm%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%81%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20%3A%3D%20inl%20%E2%9F%A8symm%20a%E2%82%81b%E2%82%81%2C%20symm%20a%E2%82%82b%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20%3A%3D%20inr%20%E2%9F%A8symm%20a%E2%82%82b%E2%82%81%2C%20symm%20a%E2%82%81b%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20eqv.trans%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%E2%88%80%20p%E2%82%81%20p%E2%82%82%20p%E2%82%83%20%3A%20%CE%B1%20%C3%97%20%CE%B1%2C%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20p%E2%82%82%20~%20p%E2%82%83%20%E2%86%92%20p%E2%82%81%20~%20p%E2%82%83%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%82%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%81%20b%E2%82%81c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%82%20b%E2%82%82c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inl%20%E2%9F%A8b%E2%82%81c%E2%82%81%2C%20b%E2%82%82c%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20inr%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%82%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%81%E2%9F%A9%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20(c%E2%82%81%2C%20c%E2%82%82)%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20(inr%20%E2%9F%A8b%E2%82%81c%E2%82%82%2C%20b%E2%82%82c%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20inl%20%E2%9F%A8trans%20a%E2%82%81b%E2%82%82%20b%E2%82%82c%E2%82%81%2C%20trans%20a%E2%82%82b%E2%82%81%20b%E2%82%81c%E2%82%82%E2%9F%A9%0A%0Aprivate%20theorem%20is_equivalence%20(%CE%B1%20%3A%20Type*)%20%3A%20equivalence%20(%40eqv%20%CE%B1)%20%3A%3D%0Amk_equivalence%20(%40eqv%20%CE%B1)%20(%40eqv.refl%20%CE%B1)%20(%40eqv.symm%20%CE%B1)%20(%40eqv.trans%20%CE%B1)%0A%0Ainstance%20uprod.setoid%20(%CE%B1%20%3A%20Type*)%20%3A%20setoid%20(%CE%B1%20%C3%97%20%CE%B1)%20%3A%3D%0Asetoid.mk%20(%40eqv%20%CE%B1)%20(is_equivalence%20%CE%B1)%0A%0Adefinition%20uprod%20(%CE%B1%20%3A%20Type*)%20%3A%3D%0Aquotient%20(uprod.setoid%20%CE%B1)%0A%0Anamespace%20uprod%0Adefinition%20mk%20%7B%CE%B1%20%3A%20Type*%7D%20(a%E2%82%81%20a%E2%82%82%20%3A%20%CE%B1)%20%3A%20uprod%20%CE%B1%20%3A%3D%0A%E2%9F%A6(a%E2%82%81%2C%20a%E2%82%82)%E2%9F%A7%0A%0Alocal%20notation%20%60%7B%60%20a%E2%82%81%20%60%2C%60%20a%E2%82%82%20%60%7D%60%20%3A%3D%20mk%20a%E2%82%81%20a%E2%82%82%0A%0Atheorem%20mk_eq_mk%20%7B%CE%B1%20%3A%20Type*%7D%20(a%E2%82%81%20a%E2%82%82%20%3A%20%CE%B1)%20%3A%20%7Ba%E2%82%81%2C%20a%E2%82%82%7D%20%3D%20%7Ba%E2%82%82%2C%20a%E2%82%81%7D%20%3A%3D%0Aquot.sound%20(inr%20%E2%9F%A8rfl%2C%20rfl%E2%9F%A9)%0A%0A--%20BEGIN%0Aprivate%20definition%20mem_fn%20%7B%CE%B1%20%3A%20Type*%7D%20(a%20%3A%20%CE%B1)%20%3A%0A%20%20%CE%B1%20%C3%97%20%CE%B1%20%E2%86%92%20Prop%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20%3A%3D%20a%20%3D%20a%E2%82%81%20%E2%88%A8%20a%20%3D%20a%E2%82%82%0A%0A--%20auxiliary%20lemma%20for%20proving%20mem_respects%0Aprivate%20lemma%20mem_swap%20%7B%CE%B1%20%3A%20Type*%7D%20%7Ba%20%3A%20%CE%B1%7D%20%3A%0A%20%20%E2%88%80%20%7Bp%20%3A%20%CE%B1%20%C3%97%20%CE%B1%7D%2C%20mem_fn%20a%20p%20%3D%20mem_fn%20a%20(%E2%9F%A8p.2%2C%20p.1%E2%9F%A9)%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20%3A%3D%20propext%20(iff.intro%0A%20%20%20%20(%CE%BB%20l%20%3A%20a%20%3D%20a%E2%82%81%20%E2%88%A8%20a%20%3D%20a%E2%82%82%2C%0A%20%20%20%20%20%20or.elim%20l%20(%CE%BB%20h%E2%82%81%2C%20inr%20h%E2%82%81)%20(%CE%BB%20h%E2%82%82%2C%20inl%20h%E2%82%82))%0A%20%20%20%20(%CE%BB%20r%20%3A%20a%20%3D%20a%E2%82%82%20%E2%88%A8%20a%20%3D%20a%E2%82%81%2C%0A%20%20%20%20%20%20or.elim%20r%20(%CE%BB%20h%E2%82%81%2C%20inr%20h%E2%82%81)%20(%CE%BB%20h%E2%82%82%2C%20inl%20h%E2%82%82)))%0A%0Aprivate%20lemma%20mem_respects%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%0A%20%20%E2%88%80%20%7Bp%E2%82%81%20p%E2%82%82%20%3A%20%CE%B1%20%C3%97%20%CE%B1%7D%20(a%20%3A%20%CE%B1)%2C%0A%20%20%20%20p%E2%82%81%20~%20p%E2%82%82%20%E2%86%92%20mem_fn%20a%20p%E2%82%81%20%3D%20mem_fn%20a%20p%E2%82%82%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20a%20(inl%20%E2%9F%A8a%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%E2%9F%A9)%20%3A%3D%0A%20%20by%20%7B%20dsimp%20at%20a%E2%82%81b%E2%82%81%2C%20dsimp%20at%20a%E2%82%82b%E2%82%82%2C%20rw%20%5Ba%E2%82%81b%E2%82%81%2C%20a%E2%82%82b%E2%82%82%5D%20%7D%0A%7C%20(a%E2%82%81%2C%20a%E2%82%82)%20(b%E2%82%81%2C%20b%E2%82%82)%20a%20(inr%20%E2%9F%A8a%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%E2%9F%A9)%20%3A%3D%0A%20%20by%20%7B%20dsimp%20at%20a%E2%82%81b%E2%82%82%2C%20dsimp%20at%20a%E2%82%82b%E2%82%81%2C%20rw%20%5Ba%E2%82%81b%E2%82%82%2C%20a%E2%82%82b%E2%82%81%5D%2C%0A%20%20%20%20%20%20%20%20apply%20mem_swap%20%7D%0A%0Adef%20mem%20%7B%CE%B1%20%3A%20Type*%7D%20(a%20%3A%20%CE%B1)%20(u%20%3A%20uprod%20%CE%B1)%20%3A%20Prop%20%3A%3D%0Aquot.lift_on%20u%20(%CE%BB%20p%2C%20mem_fn%20a%20p)%20(%CE%BB%20p%E2%82%81%20p%E2%82%82%20e%2C%20mem_respects%20a%20e)%0A%0Alocal%20infix%20(name%20%3A%3D%20mem)%20%60%E2%88%88%60%20%3A%3D%20mem%0A%0Atheorem%20mem_mk_left%20%7B%CE%B1%20%3A%20Type*%7D%20(a%20b%20%3A%20%CE%B1)%20%3A%20a%20%E2%88%88%20%7Ba%2C%20b%7D%20%3A%3D%0Ainl%20rfl%0A%0Atheorem%20mem_mk_right%20%7B%CE%B1%20%3A%20Type*%7D%20(a%20b%20%3A%20%CE%B1)%20%3A%20b%20%E2%88%88%20%7Ba%2C%20b%7D%20%3A%3D%0Ainr%20rfl%0A%0Atheorem%20mem_or_mem_of_mem_mk%20%7B%CE%B1%20%3A%20Type*%7D%20%7Ba%20b%20c%20%3A%20%CE%B1%7D%20%3A%0A%20%20c%20%E2%88%88%20%7Ba%2C%20b%7D%20%E2%86%92%20c%20%3D%20a%20%E2%88%A8%20c%20%3D%20b%20%3A%3D%0A%CE%BB%20h%2C%20h%0A--%20END%0Aend%20uprod" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">private</span><span class="w"> </span><span class="kd">definition</span><span class="w"> </span><span class="n">mem_fn</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a&#8322;</span>

<span class="c1">-- auxiliary lemma for proving mem_respects</span>
<span class="kn">private</span><span class="w"> </span><span class="kd">lemma</span><span class="w"> </span><span class="n">mem_swap</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">},</span><span class="w"> </span><span class="n">mem_fn</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">mem_fn</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">(&#10216;</span><span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="o">&#10217;)</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">propext</span><span class="w"> </span><span class="o">(</span><span class="n">iff.intro</span>
<span class="w">    </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">,</span>
<span class="w">      </span><span class="n">or.elim</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">inr</span><span class="w"> </span><span class="n">h&#8321;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">inl</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">))</span>
<span class="w">    </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a&#8322;</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a&#8321;</span><span class="o">,</span>
<span class="w">      </span><span class="n">or.elim</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">inr</span><span class="w"> </span><span class="n">h&#8321;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">inl</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">)))</span>

<span class="kn">private</span><span class="w"> </span><span class="kd">lemma</span><span class="w"> </span><span class="n">mem_respects</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">p&#8321;</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span>
<span class="w">    </span><span class="n">p&#8321;</span><span class="w"> </span><span class="bp">~</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">mem_fn</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">p&#8321;</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">mem_fn</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">p&#8322;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">(</span><span class="n">inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="kd">by</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">dsimp</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">a&#8321;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">dsimp</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">a&#8321;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8322;</span><span class="o">]</span><span class="w"> </span><span class="o">}</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">b&#8322;</span><span class="o">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">(</span><span class="n">inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a&#8321;b&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="kd">by</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">dsimp</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">a&#8321;b&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">dsimp</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">a&#8321;b&#8322;</span><span class="o">,</span><span class="w"> </span><span class="n">a&#8322;b&#8321;</span><span class="o">],</span>
<span class="w">        </span><span class="n">apply</span><span class="w"> </span><span class="n">mem_swap</span><span class="w"> </span><span class="o">}</span>

<span class="kd">def</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">u</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">uprod</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="n">quot.lift_on</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">mem_fn</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">p&#8321;</span><span class="w"> </span><span class="n">p&#8322;</span><span class="w"> </span><span class="n">e</span><span class="o">,</span><span class="w"> </span><span class="n">mem_respects</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">e</span><span class="o">)</span>

<span class="kn">local</span><span class="w"> </span><span class="kd">infix</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span><span class="o">)</span><span class="w"> </span><span class="bp">`&#8712;`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">mem_mk_left</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">}</span><span class="w"> </span><span class="o">:=</span>
<span class="n">inl</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">mem_mk_right</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">}</span><span class="w"> </span><span class="o">:=</span>
<span class="n">inr</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">mem_or_mem_of_mem_mk</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8712;</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">}</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">h</span>
</pre></div>
</div>
</div><p>For convenience, the standard library also defines <code class="docutils literal notranslate"><span class="pre">quotient.lift&#8322;</span></code> for lifting binary functions, and <code class="docutils literal notranslate"><span class="pre">quotient.ind&#8322;</span></code> for induction on two variables.</p>
<p>We close this section with some hints as to why the quotient construction implies function extenionality. It is not hard to show that extensional equality on the <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">&#946;</span> <span class="pre">x</span></code> is an equivalence relation, and so we can consider the type <code class="docutils literal notranslate"><span class="pre">extfun</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span></code> of functions &#8220;up to equivalence.&#8221; Of course, application respects that equivalence in the sense that if <code class="docutils literal notranslate"><span class="pre">f&#8321;</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">f&#8322;</span></code>, then <code class="docutils literal notranslate"><span class="pre">f&#8321;</span> <span class="pre">a</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">f&#8322;</span> <span class="pre">a</span></code>. Thus application gives rise to a function <code class="docutils literal notranslate"><span class="pre">extfun_app</span> <span class="pre">:</span> <span class="pre">extfun</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span> <span class="pre">&#8594;</span> <span class="pre">&#928;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">&#946;</span> <span class="pre">x</span></code>. But for every <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">extfun_app</span> <span class="pre">&#10214;f&#10215;</span></code> is definitionally equal to <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">f</span> <span class="pre">x</span></code>, which is in turn definitionally equal to <code class="docutils literal notranslate"><span class="pre">f</span></code>. So, when <code class="docutils literal notranslate"><span class="pre">f&#8321;</span></code> and <code class="docutils literal notranslate"><span class="pre">f&#8322;</span></code> are extensionally equal, we have the following chain of equalities:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>f&#8321; = extfun_app &#10214;f&#8321;&#10215; = extfun_app &#10214;f&#8322;&#10215; = f&#8322;
</pre></div>
</div>
<p>As a result, <code class="docutils literal notranslate"><span class="pre">f&#8321;</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">f&#8322;</span></code>.</p>
</section>
<section id="choice">
<span id="id2"></span><h2><span class="section-number">11.5. </span>Choice<a class="headerlink" href="#choice" title="Link to this heading">&#182;</a></h2>
<p>To state the final axiom defined in the standard library, we need the <code class="docutils literal notranslate"><span class="pre">nonempty</span></code> type, which is defined as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aclass%20inductive%20nonempty%20(%CE%B1%20%3A%20Sort*)%20%3A%20Prop%0A%7C%20intro%20%3A%20%CE%B1%20%E2%86%92%20nonempty%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">nonempty</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nonempty</span>
</pre></div>
</div>
</div><p>Because <code class="docutils literal notranslate"><span class="pre">nonempty</span> <span class="pre">&#945;</span></code> has type <code class="docutils literal notranslate"><span class="pre">Prop</span></code> and its constructor contains data, it can only eliminate to <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. In fact, <code class="docutils literal notranslate"><span class="pre">nonempty</span> <span class="pre">&#945;</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">true</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20BEGIN%0Aexample%20(%CE%B1%20%3A%20Type*)%20%3A%20nonempty%20%CE%B1%20%E2%86%94%20%E2%88%83%20x%20%3A%20%CE%B1%2C%20true%20%3A%3D%0Aiff.intro%20(%CE%BB%20%E2%9F%A8a%E2%9F%A9%2C%20%E2%9F%A8a%2C%20trivial%E2%9F%A9)%20(%CE%BB%20%E2%9F%A8a%2C%20h%E2%9F%A9%2C%20%E2%9F%A8a%E2%9F%A9)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nonempty</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="o">:=</span>
<span class="n">iff.intro</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a</span><span class="o">&#10217;,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">trivial</span><span class="o">&#10217;)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">h</span><span class="o">&#10217;,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a</span><span class="o">&#10217;)</span>
</pre></div>
</div>
</div><p>Our axiom of choice is now expressed simply as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aaxiom%20choice%20%7B%CE%B1%20%3A%20Sort*%7D%20%3A%20nonempty%20%CE%B1%20%E2%86%92%20%CE%B1%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">axiom</span><span class="w"> </span><span class="n">choice</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nonempty</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span>
</pre></div>
</div>
</div><p>Given only the assertion <code class="docutils literal notranslate"><span class="pre">h</span></code> that <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is nonempty, <code class="docutils literal notranslate"><span class="pre">choice</span> <span class="pre">h</span></code> magically produces an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. Of course, this blocks any meaningful computation: by the interpretation of <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, <code class="docutils literal notranslate"><span class="pre">h</span></code> contains no information at all as to how to find such an element.</p>
<p>This is found in the <code class="docutils literal notranslate"><span class="pre">classical</span></code> namespace, so the full name of the theorem is <code class="docutils literal notranslate"><span class="pre">classical.choice</span></code>. The choice principle is equivalent to the principle of <em>indefinite description</em>, which can be expressed with subtypes as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Aaxiom%20choice%20%7B%CE%B1%20%3A%20Sort*%7D%20%3A%20nonempty%20%CE%B1%20%E2%86%92%20%CE%B1%0A--%20BEGIN%0Anoncomputable%20theorem%20indefinite_description%0A%20%20%20%20%7B%CE%B1%20%3A%20Sort*%7D%20(p%20%3A%20%CE%B1%20%E2%86%92%20Prop)%20%3A%0A%20%20(%E2%88%83%20x%2C%20p%20x)%20%E2%86%92%20%7Bx%20%2F%2F%20p%20x%7D%20%3A%3D%0A%CE%BB%20h%2C%20choice%20(let%20%E2%9F%A8x%2C%20px%E2%9F%A9%20%3A%3D%20h%20in%20%E2%9F%A8%E2%9F%A8x%2C%20px%E2%9F%A9%E2%9F%A9)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">noncomputable</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">indefinite_description</span>
<span class="w">    </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="bp">//</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">}</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">choice</span><span class="w"> </span><span class="o">(</span><span class="k">let</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&#10216;&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">&#10217;&#10217;)</span>
</pre></div>
</div>
</div><p>Because it depends on <code class="docutils literal notranslate"><span class="pre">choice</span></code>, Lean cannot generate bytecode for <code class="docutils literal notranslate"><span class="pre">indefinite_description</span></code>, and so requires us to mark the definition as <code class="docutils literal notranslate"><span class="pre">noncomputable</span></code>. Also in the <code class="docutils literal notranslate"><span class="pre">classical</span></code> namespace, the function <code class="docutils literal notranslate"><span class="pre">some</span></code> and the property <code class="docutils literal notranslate"><span class="pre">some_spec</span></code> decompose the two parts of the output of <code class="docutils literal notranslate"><span class="pre">indefinite_description</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Anamespace%20hidden%0A%0A--%20BEGIN%0Anoncomputable%20def%20some%20%7Ba%20%3A%20Sort*%7D%20%7Bp%20%3A%20a%20%E2%86%92%20Prop%7D%0A%20%20(h%20%3A%20%E2%88%83%20x%2C%20p%20x)%20%3A%20a%20%3A%3D%0Asubtype.val%20(indefinite_description%20p%20h)%0A%0Atheorem%20some_spec%20%7Ba%20%3A%20Sort*%7D%20%7Bp%20%3A%20a%20%E2%86%92%20Prop%7D%0A%20%20(h%20%3A%20%E2%88%83%20x%2C%20p%20x)%20%3A%20p%20(some%20h)%20%3A%3D%0Asubtype.property%20(indefinite_description%20p%20h)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">noncomputable</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span>
<span class="w">  </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="n">subtype.val</span><span class="w"> </span><span class="o">(</span><span class="n">indefinite_description</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">h</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">some_spec</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span>
<span class="w">  </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="n">some</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">subtype.property</span><span class="w"> </span><span class="o">(</span><span class="n">indefinite_description</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">choice</span></code> principle also erases the distinction between the property of being <code class="docutils literal notranslate"><span class="pre">nonempty</span></code> and the more constructive property of being <code class="docutils literal notranslate"><span class="pre">inhabited</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0A--%20BEGIN%0Anoncomputable%20theorem%20inhabited_of_nonempty%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%0A%20%20nonempty%20%CE%B1%20%E2%86%92%20inhabited%20%CE%B1%20%3A%3D%0A%CE%BB%20h%2C%20choice%20(let%20%E2%9F%A8a%E2%9F%A9%20%3A%3D%20h%20in%20%E2%9F%A8%E2%9F%A8a%E2%9F%A9%E2%9F%A9)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">noncomputable</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">inhabited_of_nonempty</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">nonempty</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">choice</span><span class="w"> </span><span class="o">(</span><span class="k">let</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">a</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&#10216;&#10216;</span><span class="n">a</span><span class="o">&#10217;&#10217;)</span>
</pre></div>
</div>
</div><p>In the next section, we will see that <code class="docutils literal notranslate"><span class="pre">propext</span></code>, <code class="docutils literal notranslate"><span class="pre">funext</span></code>, and <code class="docutils literal notranslate"><span class="pre">choice</span></code>, taken together, imply the law of the excluded middle and the decidability of all propositions. Using those, one can strengthen the principle of indefinite description as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0A--%20BEGIN%0A%23check%20(%40strong_indefinite_description%20%3A%0A%20%20%20%20%20%20%20%20%CE%A0%20%7B%CE%B1%20%3A%20Sort*%7D%20(p%20%3A%20%CE%B1%20%E2%86%92%20Prop)%2C%0A%20%20%20%20%20%20%20%20%20%20nonempty%20%CE%B1%20%E2%86%92%20%7Bx%20%2F%2F%20(%E2%88%83%20(y%20%3A%20%CE%B1)%2C%20p%20y)%20%E2%86%92%20p%20x%7D)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">strong_indefinite_description</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">),</span>
<span class="w">          </span><span class="n">nonempty</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="bp">//</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="o">(</span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">})</span>
</pre></div>
</div>
</div><p>Assuming the ambient type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is nonempty, <code class="docutils literal notranslate"><span class="pre">strong_indefinite_description</span> <span class="pre">p</span></code> produces an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> satisfying <code class="docutils literal notranslate"><span class="pre">p</span></code> if there is one. The data component of this definition is conventionally known as <em>Hilbert&#8217;s epsilon function</em>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0A--%20BEGIN%0A%23check%20(%40epsilon%20%3A%20%CE%A0%20%7B%CE%B1%20%3A%20Sort*%7D%20%5Bnonempty%20%CE%B1%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(%CE%B1%20%E2%86%92%20Prop)%20%E2%86%92%20%CE%B1)%0A%0A%23check%20(%40epsilon_spec%20%3A%20%E2%88%80%20%7Ba%20%3A%20Sort*%7D%20%7Bp%20%3A%20a%20%E2%86%92%20Prop%7D%0A%20%20%20%20%20%20%20%20%20%20%20(hex%20%3A%20%E2%88%83%20(y%20%3A%20a)%2C%20p%20y)%2C%0A%20%20%20%20%20%20%20%20%20p%20(%40epsilon%20_%20(nonempty_of_exists%20hex)%20p))%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">epsilon</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">nonempty</span><span class="w"> </span><span class="n">&#945;</span><span class="o">],</span>
<span class="w">                     </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">epsilon_spec</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span>
<span class="w">           </span><span class="o">(</span><span class="n">hex</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="o">(</span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="o">),</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">y</span><span class="o">),</span>
<span class="w">         </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">epsilon</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">(</span><span class="n">nonempty_of_exists</span><span class="w"> </span><span class="n">hex</span><span class="o">)</span><span class="w"> </span><span class="n">p</span><span class="o">))</span>
</pre></div>
</div>
</div></section>
<section id="the-law-of-the-excluded-middle">
<h2><span class="section-number">11.6. </span>The Law of the Excluded Middle<a class="headerlink" href="#the-law-of-the-excluded-middle" title="Link to this heading">&#182;</a></h2>
<p>The law of the excluded middle is the following</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Anamespace%20hidden%0A--%20BEGIN%0A%23check%20(%40em%20%3A%20%E2%88%80%20(p%20%3A%20Prop)%2C%20p%20%E2%88%A8%20%C2%ACp)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">em</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">),</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span>
</pre></div>
</div>
</div><p><a class="reference external" href="http://en.wikipedia.org/wiki/Diaconescu%27s_theorem">Diaconescu&#8217;s theorem</a> states that the axiom of choice is sufficient to derive the law of excluded middle. More precisely, it shows that the law of the excluded middle follows from <code class="docutils literal notranslate"><span class="pre">classical.choice</span></code>, <code class="docutils literal notranslate"><span class="pre">propext</span></code>, and <code class="docutils literal notranslate"><span class="pre">funext</span></code>. We sketch the proof that is found in the standard library.</p>
<p>First, we import the necessary axioms, fix a parameter, <code class="docutils literal notranslate"><span class="pre">p</span></code>, and define two predicates <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Asection%20diaconescu%0Aparameter%20%20p%20%3A%20Prop%0A%0Adef%20U%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20true%20%E2%88%A8%20p%0Adef%20V%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20false%20%E2%88%A8%20p%0A%0Alemma%20exU%20%3A%20%E2%88%83%20x%2C%20U%20x%20%3A%3D%20%E2%9F%A8true%2C%20or.inl%20rfl%E2%9F%A9%0Alemma%20exV%20%3A%20%E2%88%83%20x%2C%20V%20x%20%3A%3D%20%E2%9F%A8false%2C%20or.inl%20rfl%E2%9F%A9%0A%0Aend%20diaconescu" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">classical</span>

<span class="kn">section</span><span class="w"> </span><span class="n">diaconescu</span>
<span class="kd">parameter</span><span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">def</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span>
<span class="kd">def</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span>

<span class="kd">lemma</span><span class="w"> </span><span class="n">exU</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">true</span><span class="o">,</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="n">rfl</span><span class="o">&#10217;</span>
<span class="kd">lemma</span><span class="w"> </span><span class="n">exV</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">false</span><span class="o">,</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="n">rfl</span><span class="o">&#10217;</span>

<span class="kd">end</span><span class="w"> </span><span class="n">diaconescu</span>
</pre></div>
</div>
</div><p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> is true, then every element of <code class="docutils literal notranslate"><span class="pre">Prop</span></code> is in both <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code>. If <code class="docutils literal notranslate"><span class="pre">p</span></code> is false, then <code class="docutils literal notranslate"><span class="pre">U</span></code> is the singleton <code class="docutils literal notranslate"><span class="pre">true</span></code>, and <code class="docutils literal notranslate"><span class="pre">V</span></code> is the singleton <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Next, we use <code class="docutils literal notranslate"><span class="pre">some</span></code> to choose an element from each of <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Asection%20diaconescu%0Aparameter%20%20p%20%3A%20Prop%0A%0Adef%20U%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20true%20%E2%88%A8%20p%0Adef%20V%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20false%20%E2%88%A8%20p%0A%0Alemma%20exU%20%3A%20%E2%88%83%20x%2C%20U%20x%20%3A%3D%20%E2%9F%A8true%2C%20or.inl%20rfl%E2%9F%A9%0Alemma%20exV%20%3A%20%E2%88%83%20x%2C%20V%20x%20%3A%3D%20%E2%9F%A8false%2C%20or.inl%20rfl%E2%9F%A9%0A%0A--%20BEGIN%0Anoncomputable%20def%20u%20%3A%3D%20some%20exU%0Anoncomputable%20def%20v%20%3A%3D%20some%20exV%0A%0Alemma%20u_def%20%3A%20U%20u%20%3A%3D%20some_spec%20exU%0Alemma%20v_def%20%3A%20V%20v%20%3A%3D%20some_spec%20exV%0A--%20END%0A%0Aend%20diaconescu" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">noncomputable</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">exU</span>
<span class="kd">noncomputable</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">exV</span>

<span class="kd">lemma</span><span class="w"> </span><span class="n">u_def</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">some_spec</span><span class="w"> </span><span class="n">exU</span>
<span class="kd">lemma</span><span class="w"> </span><span class="n">v_def</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">some_spec</span><span class="w"> </span><span class="n">exV</span>
</pre></div>
</div>
</div><p>Each of <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code> is a disjunction, so <code class="docutils literal notranslate"><span class="pre">u_def</span></code> and <code class="docutils literal notranslate"><span class="pre">v_def</span></code> represent four cases. In one of these cases, <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">false</span></code>, and in all the other cases, <code class="docutils literal notranslate"><span class="pre">p</span></code> is true. Thus we have:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Asection%20diaconescu%0Aparameter%20%20p%20%3A%20Prop%0A%0Adef%20U%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20true%20%E2%88%A8%20p%0Adef%20V%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20false%20%E2%88%A8%20p%0A%0Alemma%20exU%20%3A%20%E2%88%83%20x%2C%20U%20x%20%3A%3D%20%E2%9F%A8true%2C%20or.inl%20rfl%E2%9F%A9%0Alemma%20exV%20%3A%20%E2%88%83%20x%2C%20V%20x%20%3A%3D%20%E2%9F%A8false%2C%20or.inl%20rfl%E2%9F%A9%0A%0Anoncomputable%20def%20u%20%3A%3D%20some%20exU%0Anoncomputable%20def%20v%20%3A%3D%20some%20exV%0A%0Alemma%20u_def%20%3A%20U%20u%20%3A%3D%20some_spec%20exU%0Alemma%20v_def%20%3A%20V%20v%20%3A%3D%20some_spec%20exV%0A%0A--%20BEGIN%0Alemma%20not_uv_or_p%20%3A%20u%20%E2%89%A0%20v%20%E2%88%A8%20p%20%3A%3D%0Aor.elim%20u_def%0A%20%20(assume%20hut%20%3A%20u%20%3D%20true%2C%0A%20%20%20%20or.elim%20v_def%0A%20%20%20%20%20%20(assume%20hvf%20%3A%20v%20%3D%20false%2C%0A%20%20%20%20%20%20%20%20have%20hne%20%3A%20u%20%E2%89%A0%20v%2C%0A%20%20%20%20%20%20%20%20%20%20from%20eq.symm%20hvf%20%E2%96%B8%20eq.symm%20hut%20%E2%96%B8%20true_ne_false%2C%0A%20%20%20%20%20%20%20%20or.inl%20hne)%0A%20%20%20%20%20%20(assume%20hp%20%3A%20p%2C%20or.inr%20hp))%0A%20%20(assume%20hp%20%3A%20p%2C%20or.inr%20hp)%0A--%20END%0A%0Aend%20diaconescu" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">lemma</span><span class="w"> </span><span class="n">not_uv_or_p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="bp">&#8800;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">or.elim</span><span class="w"> </span><span class="n">u_def</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hut</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="o">,</span>
<span class="w">    </span><span class="n">or.elim</span><span class="w"> </span><span class="n">v_def</span>
<span class="w">      </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hvf</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">false</span><span class="o">,</span>
<span class="w">        </span><span class="k">have</span><span class="w"> </span><span class="n">hne</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="bp">&#8800;</span><span class="w"> </span><span class="n">v</span><span class="o">,</span>
<span class="w">          </span><span class="k">from</span><span class="w"> </span><span class="n">eq.symm</span><span class="w"> </span><span class="n">hvf</span><span class="w"> </span><span class="bp">&#9656;</span><span class="w"> </span><span class="n">eq.symm</span><span class="w"> </span><span class="n">hut</span><span class="w"> </span><span class="bp">&#9656;</span><span class="w"> </span><span class="n">true_ne_false</span><span class="o">,</span>
<span class="w">        </span><span class="n">or.inl</span><span class="w"> </span><span class="n">hne</span><span class="o">)</span>
<span class="w">      </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hp</span><span class="o">))</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>On the other hand, if <code class="docutils literal notranslate"><span class="pre">p</span></code> is true, then, by function extensionality
and propositional extensionality, <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code> are equal. By the
definition of <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code>, this implies that they are equal as well.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Asection%20diaconescu%0Aparameter%20%20p%20%3A%20Prop%0A%0Adef%20U%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20true%20%E2%88%A8%20p%0Adef%20V%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20false%20%E2%88%A8%20p%0A%0Alemma%20exU%20%3A%20%E2%88%83%20x%2C%20U%20x%20%3A%3D%20%E2%9F%A8true%2C%20or.inl%20rfl%E2%9F%A9%0Alemma%20exV%20%3A%20%E2%88%83%20x%2C%20V%20x%20%3A%3D%20%E2%9F%A8false%2C%20or.inl%20rfl%E2%9F%A9%0A%0Anoncomputable%20def%20u%20%3A%3D%20some%20exU%0Anoncomputable%20def%20v%20%3A%3D%20some%20exV%0A%0Alemma%20u_def%20%3A%20U%20u%20%3A%3D%20some_spec%20exU%0Alemma%20v_def%20%3A%20V%20v%20%3A%3D%20some_spec%20exV%0A%0Alemma%20not_uv_or_p%20%3A%20%C2%AC(u%20%3D%20v)%20%E2%88%A8%20p%20%3A%3D%0Aor.elim%20u_def%0A%20%20(assume%20hut%20%3A%20u%20%3D%20true%2C%0A%20%20%20%20or.elim%20v_def%0A%20%20%20%20%20%20(assume%20hvf%20%3A%20v%20%3D%20false%2C%0A%20%20%20%20%20%20%20%20have%20hne%20%3A%20u%20%E2%89%A0%20v%2C%0A%20%20%20%20%20%20%20%20%20%20from%20eq.symm%20hvf%20%E2%96%B8%20eq.symm%20hut%20%E2%96%B8%20true_ne_false%2C%0A%20%20%20%20%20%20%20%20or.inl%20hne)%0A%20%20%20%20%20%20(assume%20hp%20%3A%20p%2C%20or.inr%20hp))%0A%20%20(assume%20hp%20%3A%20p%2C%20or.inr%20hp)%0A%0A--%20BEGIN%0Alemma%20p_implies_uv%20%3A%20p%20%E2%86%92%20u%20%3D%20v%20%3A%3D%0Aassume%20hp%20%3A%20p%2C%0Ahave%20hpred%20%3A%20U%20%3D%20V%2C%20from%0A%20%20funext%20(assume%20x%20%3A%20Prop%2C%0A%20%20%20%20have%20hl%20%3A%20(x%20%3D%20true%20%E2%88%A8%20p)%20%E2%86%92%20(x%20%3D%20false%20%E2%88%A8%20p)%2C%20from%0A%20%20%20%20%20%20assume%20a%2C%20or.inr%20hp%2C%0A%20%20%20%20have%20hr%20%3A%20(x%20%3D%20false%20%E2%88%A8%20p)%20%E2%86%92%20(x%20%3D%20true%20%E2%88%A8%20p)%2C%20from%0A%20%20%20%20%20%20assume%20a%2C%20or.inr%20hp%2C%0A%20%20%20%20show%20(x%20%3D%20true%20%E2%88%A8%20p)%20%3D%20(x%20%3D%20false%20%E2%88%A8%20p)%2C%20from%0A%20%20%20%20%20%20propext%20(iff.intro%20hl%20hr))%2C%0Ahave%20h%E2%82%80%20%3A%20%E2%88%80%20exU%20exV%2C%0A%20%20%20%20%40classical.some%20_%20U%20exU%20%3D%20%40classical.some%20_%20V%20exV%2C%0A%20%20from%20hpred%20%E2%96%B8%20%CE%BB%20exU%20exV%2C%20rfl%2C%0Ashow%20u%20%3D%20v%2C%20from%20h%E2%82%80%20_%20_%0A--%20END%0Aend%20diaconescu" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">lemma</span><span class="w"> </span><span class="n">p_implies_uv</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="k">have</span><span class="w"> </span><span class="n">hpred</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">V</span><span class="o">,</span><span class="w"> </span><span class="k">from</span>
<span class="w">  </span><span class="n">funext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">,</span>
<span class="w">    </span><span class="k">have</span><span class="w"> </span><span class="n">hl</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">),</span><span class="w"> </span><span class="k">from</span>
<span class="w">      </span><span class="k">assume</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hp</span><span class="o">,</span>
<span class="w">    </span><span class="k">have</span><span class="w"> </span><span class="n">hr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">),</span><span class="w"> </span><span class="k">from</span>
<span class="w">      </span><span class="k">assume</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hp</span><span class="o">,</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">),</span><span class="w"> </span><span class="k">from</span>
<span class="w">      </span><span class="n">propext</span><span class="w"> </span><span class="o">(</span><span class="n">iff.intro</span><span class="w"> </span><span class="n">hl</span><span class="w"> </span><span class="n">hr</span><span class="o">)),</span>
<span class="k">have</span><span class="w"> </span><span class="n">h&#8320;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">exU</span><span class="w"> </span><span class="n">exV</span><span class="o">,</span>
<span class="w">    </span><span class="bp">@</span><span class="n">classical.some</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">exU</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="bp">@</span><span class="n">classical.some</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">exV</span><span class="o">,</span>
<span class="w">  </span><span class="k">from</span><span class="w"> </span><span class="n">hpred</span><span class="w"> </span><span class="bp">&#9656;</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">exU</span><span class="w"> </span><span class="n">exV</span><span class="o">,</span><span class="w"> </span><span class="n">rfl</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">v</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">h&#8320;</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span>
</pre></div>
</div>
</div><p>Putting these last two facts together yields the desired conclusion:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Asection%20diaconescu%0Aparameter%20%20p%20%3A%20Prop%0A%0Adef%20U%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20true%20%E2%88%A8%20p%0Adef%20V%20(x%20%3A%20Prop)%20%3A%20Prop%20%3A%3D%20x%20%3D%20false%20%E2%88%A8%20p%0A%0Alemma%20exU%20%3A%20%E2%88%83%20x%2C%20U%20x%20%3A%3D%20%E2%9F%A8true%2C%20or.inl%20rfl%E2%9F%A9%0Alemma%20exV%20%3A%20%E2%88%83%20x%2C%20V%20x%20%3A%3D%20%E2%9F%A8false%2C%20or.inl%20rfl%E2%9F%A9%0A%0Anoncomputable%20def%20u%20%3A%3D%20some%20exU%0Anoncomputable%20def%20v%20%3A%3D%20some%20exV%0A%0Alemma%20u_def%20%3A%20U%20u%20%3A%3D%20some_spec%20exU%0Alemma%20v_def%20%3A%20V%20v%20%3A%3D%20some_spec%20exV%0A%0Alemma%20not_uv_or_p%20%3A%20%C2%AC(u%20%3D%20v)%20%E2%88%A8%20p%20%3A%3D%0Aor.elim%20u_def%0A%20%20(assume%20hut%20%3A%20u%20%3D%20true%2C%0A%20%20%20%20or.elim%20v_def%0A%20%20%20%20%20%20(assume%20hvf%20%3A%20v%20%3D%20false%2C%0A%20%20%20%20%20%20%20%20have%20hne%20%3A%20%C2%AC(u%20%3D%20v)%2C%20from%20eq.symm%20hvf%20%E2%96%B8%20eq.symm%20hut%20%E2%96%B8%20true_ne_false%2C%0A%20%20%20%20%20%20%20%20or.inl%20hne)%0A%20%20%20%20%20%20(assume%20hp%20%3A%20p%2C%20or.inr%20hp))%0A%20%20(assume%20hp%20%3A%20p%2C%20or.inr%20hp)%0A%0Alemma%20p_implies_uv%20%3A%20p%20%E2%86%92%20u%20%3D%20v%20%3A%3D%0Aassume%20hp%20%3A%20p%2C%0Ahave%20hpred%20%3A%20U%20%3D%20V%2C%20from%0A%20%20funext%20(assume%20x%20%3A%20Prop%2C%0A%20%20%20%20have%20hl%20%3A%20(x%20%3D%20true%20%E2%88%A8%20p)%20%E2%86%92%20(x%20%3D%20false%20%E2%88%A8%20p)%2C%20from%0A%20%20%20%20%20%20assume%20a%2C%20or.inr%20hp%2C%0A%20%20%20%20have%20hr%20%3A%20(x%20%3D%20false%20%E2%88%A8%20p)%20%E2%86%92%20(x%20%3D%20true%20%E2%88%A8%20p)%2C%20from%0A%20%20%20%20%20%20assume%20a%2C%20or.inr%20hp%2C%0A%20%20%20%20show%20(x%20%3D%20true%20%E2%88%A8%20p)%20%3D%20(x%20%3D%20false%20%E2%88%A8%20p)%2C%20from%0A%20%20%20%20%20%20propext%20(iff.intro%20hl%20hr))%2C%0Ahave%20h%E2%82%80%20%3A%20%E2%88%80%20exU%20exV%2C%0A%20%20%20%20%40classical.some%20_%20U%20exU%20%3D%20%40classical.some%20_%20V%20exV%2C%0A%20%20from%20hpred%20%E2%96%B8%20%CE%BB%20exU%20exV%2C%20rfl%2C%0Ashow%20u%20%3D%20v%2C%20from%20h%E2%82%80%20_%20_%0A%0A--%20BEGIN%0Atheorem%20em%20%3A%20p%20%E2%88%A8%20%C2%ACp%20%3A%3D%0Ahave%20h%20%3A%20%C2%AC(u%20%3D%20v)%20%E2%86%92%20%C2%ACp%2C%20from%20mt%20p_implies_uv%2C%0A%20%20or.elim%20not_uv_or_p%0A%20%20%20%20(assume%20hne%20%3A%20%C2%AC(u%20%3D%20v)%2C%20or.inr%20(h%20hne))%0A%20%20%20%20(assume%20hp%20%3A%20p%2C%20or.inl%20hp)%0A--%20END%0A%0Aend%20diaconescu" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">have</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">u</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">mt</span><span class="w"> </span><span class="n">p_implies_uv</span><span class="o">,</span>
<span class="w">  </span><span class="n">or.elim</span><span class="w"> </span><span class="n">not_uv_or_p</span>
<span class="w">    </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hne</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">u</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">v</span><span class="o">),</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="n">hne</span><span class="o">))</span>
<span class="w">    </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Consequences of excluded middle include double-negation elimination, proof by cases, and proof by contradiction, all of which are described in <a class="reference internal" href="propositions_and_proofs.html#classical-logic"><span class="std std-numref">Section 3.5</span></a>. The law of the excluded middle and propositional extensionality imply propositional completeness:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0Anamespace%20hidden%0A%0A--%20BEGIN%0Atheorem%20prop_complete%20(a%20%3A%20Prop)%20%3A%20a%20%3D%20true%20%E2%88%A8%20a%20%3D%20false%20%3A%3D%0Aor.elim%20(em%20a)%0A%20%20(%CE%BB%20t%2C%20or.inl%20(propext%20(iff.intro%20(%CE%BB%20h%2C%20trivial)%20(%CE%BB%20h%2C%20t))))%0A%20%20(%CE%BB%20f%2C%20or.inr%20(propext%20(iff.intro%20(%CE%BB%20h%2C%20absurd%20h%20f)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(%CE%BB%20h%2C%20false.elim%20h))))%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">prop_complete</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="o">:=</span>
<span class="n">or.elim</span><span class="w"> </span><span class="o">(</span><span class="n">em</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">t</span><span class="o">,</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="o">(</span><span class="n">propext</span><span class="w"> </span><span class="o">(</span><span class="n">iff.intro</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">trivial</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">t</span><span class="o">))))</span>
<span class="w">  </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">f</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="o">(</span><span class="n">propext</span><span class="w"> </span><span class="o">(</span><span class="n">iff.intro</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">absurd</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">f</span><span class="o">)</span>
<span class="w">                                   </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">false.elim</span><span class="w"> </span><span class="n">h</span><span class="o">))))</span>
</pre></div>
</div>
</div><p>Together with choice, we also get the stronger principle that every proposition is decidable. Recall that the class of <code class="docutils literal notranslate"><span class="pre">decidable</span></code> propositions is defined as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aclass%20inductive%20decidable%20(p%20%3A%20Prop)%0A%7C%20is_false%20%3A%20%C2%AC%20p%20%E2%86%92%20decidable%0A%7C%20is_true%20%3A%20%20p%20%E2%86%92%20decidable%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">is_false</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">decidable</span>
<span class="bp">|</span><span class="w"> </span><span class="n">is_true</span><span class="w"> </span><span class="o">:</span><span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">decidable</span>
</pre></div>
</div>
</div><p>In contrast to <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;</span> <span class="pre">p</span></code>, which can only eliminate to <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, the type <code class="docutils literal notranslate"><span class="pre">decidable</span> <span class="pre">p</span></code> is equivalent to the sum type <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8853;</span> <span class="pre">&#172;</span> <span class="pre">p</span></code>, which can eliminate to any type. It is this data that is needed to write an if-then-else expression.</p>
<p>As an example of classical reasoning, we use <code class="docutils literal notranslate"><span class="pre">some</span></code> to show that if <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code> is injective and <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is inhabited, then <code class="docutils literal notranslate"><span class="pre">f</span></code> has a left inverse. To define the left inverse <code class="docutils literal notranslate"><span class="pre">linv</span></code>, we use a dependent if-then-else expression. Recall that <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">c</span> <span class="pre">then</span> <span class="pre">t</span> <span class="pre">else</span> <span class="pre">e</span></code> is notation for <code class="docutils literal notranslate"><span class="pre">dite</span> <span class="pre">c</span> <span class="pre">(&#955;</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">c,</span> <span class="pre">t)</span> <span class="pre">(&#955;</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">c,</span> <span class="pre">e)</span></code>. In the definition of <code class="docutils literal notranslate"><span class="pre">linv</span></code>, choice is used twice: first, to show that <code class="docutils literal notranslate"><span class="pre">(&#8707;</span> <span class="pre">a</span> <span class="pre">:</span> <span class="pre">A,</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">b)</span></code> is &#8220;decidable,&#8221; and then to choose an <code class="docutils literal notranslate"><span class="pre">a</span></code> such that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>. Notice that we make <code class="docutils literal notranslate"><span class="pre">prop_decidable</span></code> a local instance to justify the if-then-else expression. (See also the discussion in <a class="reference internal" href="type_classes.html#decidable-propositions"><span class="std std-numref">Section 10.4</span></a>.)</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%20function%0Alocal%20attribute%20%5Binstance%5D%20prop_decidable%0A%0Anoncomputable%20definition%20linv%20%7B%CE%B1%20%CE%B2%20%3A%20Type*%7D%20%5Bh%20%3A%20inhabited%20%CE%B1%5D%0A%20%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2)%20%3A%20%CE%B2%20%E2%86%92%20%CE%B1%20%3A%3D%0A%CE%BB%20b%20%3A%20%CE%B2%2C%20if%20ex%20%3A%20(%E2%88%83%20a%20%3A%20%CE%B1%2C%20f%20a%20%3D%20b)%20then%20some%20ex%20else%20arbitrary%20%CE%B1%0A%0Atheorem%20linv_comp_self%20%7B%CE%B1%20%CE%B2%20%3A%20Type*%7D%20%7Bf%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%7D%0A%20%20%20%20%5Binhabited%20%CE%B1%5D%20(inj%20%3A%20injective%20f)%20%3A%0A%20%20linv%20f%20%E2%88%98%20f%20%3D%20id%20%3A%3D%0Afunext%20(assume%20a%2C%0A%20%20have%20ex%20%20%3A%20%E2%88%83%20a%E2%82%81%20%3A%20%CE%B1%2C%20f%20a%E2%82%81%20%3D%20f%20a%2C%20from%20exists.intro%20a%20rfl%2C%0A%20%20have%20%20%20feq%20%3A%20f%20(some%20ex)%20%3D%20f%20a%2C%20from%20some_spec%20ex%2C%0A%20%20calc%20linv%20f%20(f%20a)%20%3D%20some%20ex%20%3A%20%20dif_pos%20ex%0A%20%20%20%20%20%20%20%20%20%20%20%20%20...%20%20%20%20%3D%20a%20%20%20%20%20%20%20%3A%20%20inj%20feq)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">classical</span><span class="w"> </span><span class="n">function</span>
<span class="kn">local</span><span class="w"> </span><span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="kd">instance</span><span class="o">]</span><span class="w"> </span><span class="n">prop_decidable</span>

<span class="kd">noncomputable</span><span class="w"> </span><span class="kd">definition</span><span class="w"> </span><span class="n">linv</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span>
<span class="w">  </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="o">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">arbitrary</span><span class="w"> </span><span class="n">&#945;</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">linv_comp_self</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">}</span>
<span class="w">    </span><span class="o">[</span><span class="n">inhabited</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="n">inj</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">injective</span><span class="w"> </span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">linv</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="bp">&#8728;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">:=</span>
<span class="n">funext</span><span class="w"> </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">a</span><span class="o">,</span>
<span class="w">  </span><span class="k">have</span><span class="w"> </span><span class="n">ex</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a&#8321;</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">exists.intro</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">rfl</span><span class="o">,</span>
<span class="w">  </span><span class="k">have</span><span class="w">   </span><span class="n">feq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">some</span><span class="w"> </span><span class="n">ex</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">some_spec</span><span class="w"> </span><span class="n">ex</span><span class="o">,</span>
<span class="w">  </span><span class="k">calc</span><span class="w"> </span><span class="n">linv</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">:</span><span class="w">  </span><span class="n">dif_pos</span><span class="w"> </span><span class="n">ex</span>
<span class="w">             </span><span class="bp">...</span><span class="w">    </span><span class="bp">=</span><span class="w"> </span><span class="n">a</span><span class="w">       </span><span class="o">:</span><span class="w">  </span><span class="n">inj</span><span class="w"> </span><span class="n">feq</span><span class="o">)</span>
</pre></div>
</div>
</div><p>From a classical point of view, <code class="docutils literal notranslate"><span class="pre">linv</span></code> is a function. From a constructive point of view, it is unacceptable; because there is no way to implement such a function in general, the construction is not informative.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean 3 (outdated)</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositions_and_proofs.html">3. Propositions and Proofs</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. Axioms and Computation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#historical-and-philosophical-context">11.1. Historical and Philosophical Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#propositional-extensionality">11.2. Propositional Extensionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-extensionality">11.3. Function Extensionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quotients">11.4. Quotients</a></li>
<li class="toctree-l2"><a class="reference internal" href="#choice">11.5. Choice</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-law-of-the-excluded-middle">11.6. The Law of the Excluded Middle</a></li>
</ul>
</li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/axioms_and_computation.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>