<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>8. Induction and Recursion &#8212; Theorem Proving in Lean 3 (outdated) 3.23.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=5ca61e87" />
    <script src="_static/documentation_options.js?v=5de50469"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="9. Structures and Records" href="structures_and_records.html" />
    <link rel="prev" title="7. Inductive Types" href="inductive_types.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="induction-and-recursion">
<span id="id1"></span><h1><span class="section-number">8. </span>Induction and Recursion<a class="headerlink" href="#induction-and-recursion" title="Link to this heading">&#182;</a></h1>
<p>In the previous chapter, we saw that inductive definitions provide a powerful means of introducing new types in Lean. Moreover, the constructors and the recursors provide the only means of defining functions on these types. By the propositions-as-types correspondence, this means that induction is the fundamental method of proof.</p>
<p>Lean provides natural ways of defining recursive functions, performing pattern matching, and writing inductive proofs. It allows you to define a function by specifying equations that it should satisfy, and it allows you to prove a theorem by specifying how to handle various cases that can arise. Behind the scenes, these descriptions are &#8220;compiled&#8221; down to primitive recursors, using a procedure that we refer to as the &#8220;equation compiler.&#8221; The equation compiler is not part of the trusted code base; its output consists of terms that are checked independently by the kernel.</p>
<section id="pattern-matching">
<span id="id2"></span><h2><span class="section-number">8.1. </span>Pattern Matching<a class="headerlink" href="#pattern-matching" title="Link to this heading">&#182;</a></h2>
<p>The interpretation of schematic patterns is the first step of the compilation process. We have seen that the <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> recursor can be used to define functions and prove theorems by cases, according to the constructors involved in an inductively defined type. But complicated definitions may use several nested <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> applications, and may be hard to read and understand. Pattern matching provides an approach that is more convenient, and familiar to users of functional programming languages.</p>
<p>Consider the inductively defined type of natural numbers. Every natural number is either <code class="docutils literal notranslate"><span class="pre">zero</span></code> or <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">x</span></code>, and so you can define a function from the natural numbers to an arbitrary type by specifying a value in each of those cases:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0Adef%20sub1%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20zero%20%20%20%20%20%3A%3D%20zero%0A%7C%20(succ%20x)%20%3A%3D%20x%0A%0Adef%20is_zero%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20zero%20%20%20%20%20%3A%3D%20true%0A%7C%20(succ%20x)%20%3A%3D%20false" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">def</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">zero</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span>

<span class="kd">def</span><span class="w"> </span><span class="n">is_zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">true</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">false</span>
</pre></div>
</div>
</div><p>The equations used to define these function hold definitionally:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0Adef%20sub1%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20zero%20%20%20%20%20%3A%3D%20zero%0A%7C%20(succ%20x)%20%3A%3D%20x%0A%0Adef%20is_zero%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20zero%20%20%20%20%20%3A%3D%20true%0A%7C%20(succ%20x)%20%3A%3D%20false%0A%0A--%20BEGIN%0Aexample%20%3A%20sub1%200%20%3D%200%20%3A%3D%20rfl%0Aexample%20(x%20%3A%20%E2%84%95)%20%3A%20sub1%20(succ%20x)%20%3D%20x%20%3A%3D%20rfl%0A%0Aexample%20%3A%20is_zero%200%20%3D%20true%20%3A%3D%20rfl%0Aexample%20(x%20%3A%20%E2%84%95)%20%3A%20is_zero%20(succ%20x)%20%3D%20false%20%3A%3D%20rfl%0A%0Aexample%20%3A%20sub1%207%20%3D%206%20%3A%3D%20rfl%0Aexample%20(x%20%3A%20%E2%84%95)%20%3A%20%C2%AC%20is_zero%20(x%20%2B%203)%20%3A%3D%20not_false%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">is_zero</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">is_zero</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="w"> </span><span class="n">is_zero</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">not_false</span>
</pre></div>
</div>
</div><p>Instead of <code class="docutils literal notranslate"><span class="pre">zero</span></code> and <code class="docutils literal notranslate"><span class="pre">succ</span></code>, we can use more familiar notation:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0Adef%20sub1%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20%3A%3D%200%0A%7C%20(x%2B1)%20%3A%3D%20x%0A%0Adef%20is_zero%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%200%20%20%20%20%20%3A%3D%20true%0A%7C%20(x%2B1)%20%3A%3D%20false" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">def</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span>

<span class="kd">def</span><span class="w"> </span><span class="n">is_zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">true</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">false</span>
</pre></div>
</div>
</div><p>Because addition and the zero notation have been assigned the <code class="docutils literal notranslate"><span class="pre">[pattern]</span></code> attribute, they can be used in pattern matching. Lean simply normalizes these expressions until the constructors <code class="docutils literal notranslate"><span class="pre">zero</span></code> and <code class="docutils literal notranslate"><span class="pre">succ</span></code> are exposed.</p>
<p>Pattern matching works with any inductive type, such as products and option types:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universes%20u%20v%0Avariables%20%7B%CE%B1%20%3A%20Type%20u%7D%20%20%7B%CE%B2%20%3A%20Type%20v%7D%0A%0Adef%20swap_pair%20%3A%20%CE%B1%20%C3%97%20%CE%B2%20%E2%86%92%20%CE%B2%20%C3%97%20%CE%B1%0A%7C%20(a%2C%20b)%20%3A%3D%20(b%2C%20a)%0A%0Adef%20foo%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20(m%2C%20n)%20%3A%3D%20m%20%2B%20n%0A%0Adef%20bar%20%3A%20option%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20(some%20n)%20%3A%3D%20n%20%2B%201%0A%7C%20none%20%20%20%20%20%3A%3D%200" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w">  </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">}</span>

<span class="kd">def</span><span class="w"> </span><span class="n">swap_pair</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span>

<span class="kd">def</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">some</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="n">none</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</div><p>Here we use it not only to define a function, but also to carry out a proof by cases:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Adef%20bnot%20%3A%20bool%20%E2%86%92%20bool%0A%7C%20tt%20%3A%3D%20ff%0A%7C%20ff%20%3A%3D%20tt%0A%0Atheorem%20bnot_bnot%20%3A%20%E2%88%80%20(b%20%3A%20bool)%2C%20bnot%20(bnot%20b)%20%3D%20b%0A%7C%20tt%20%3A%3D%20rfl%20%20%20%20--%20proof%20that%20bnot%20(bnot%20tt)%20%3D%20tt%0A%7C%20ff%20%3A%3D%20rfl%20%20%20%20--%20proof%20that%20bnot%20(bnot%20ff)%20%3D%20ff%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">bnot</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span>
<span class="bp">|</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">ff</span>
<span class="bp">|</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tt</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">bnot_bnot</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="o">),</span><span class="w"> </span><span class="n">bnot</span><span class="w"> </span><span class="o">(</span><span class="n">bnot</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span>
<span class="bp">|</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span><span class="w">    </span><span class="c1">-- proof that bnot (bnot tt) = tt</span>
<span class="bp">|</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span><span class="w">    </span><span class="c1">-- proof that bnot (bnot ff) = ff</span>
</pre></div>
</div>
</div><p>Pattern matching can also be used to destruct inductively defined propositions:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20(p%20q%20%3A%20Prop)%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%0A%7C%20(and.intro%20h%E2%82%81%20h%E2%82%82)%20%3A%3D%20and.intro%20h%E2%82%82%20h%E2%82%81%0A%0Aexample%20(p%20q%20%3A%20Prop)%20%3A%20p%20%E2%88%A8%20q%20%E2%86%92%20q%20%E2%88%A8%20p%0A%7C%20(or.inl%20hp)%20%3A%3D%20or.inr%20hp%0A%7C%20(or.inr%20hq)%20%3A%3D%20or.inl%20hq" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">and.intro</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="n">h&#8321;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">or.inl</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hp</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">or.inr</span><span class="w"> </span><span class="n">hq</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="n">hq</span>
</pre></div>
</div>
</div><p>This provides a compact way of unpacking hypotheses that make use of logical connectives.</p>
<p>In all these examples, pattern matching was used to carry out a single case distinction. More interestingly, patterns can involve nested constructors, as in the following examples.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0Adef%20sub2%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20zero%20%20%20%20%20%20%20%20%20%20%20%20%3A%3D%200%0A%7C%20(succ%20zero)%20%20%20%20%20%3A%3D%200%0A%7C%20(succ%20(succ%20a))%20%3A%3D%20a" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">def</span><span class="w"> </span><span class="n">sub2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">            </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">zero</span><span class="o">)</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">a</span><span class="o">))</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
</div><p>The equation compiler first splits on cases as to whether the input is <code class="docutils literal notranslate"><span class="pre">zero</span></code> or of the form <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">x</span></code>. It then does a case split on whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">zero</span></code> or <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">a</span></code>. It determines the necessary case splits from the patterns that are presented to it, and raises and error if the patterns fail to exhaust the cases. Once again, we can use arithmetic notation, as in the version below. In either case, the defining equations hold definitionally.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20sub2%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20%3A%3D%200%0A%7C%201%20%20%20%20%20%3A%3D%200%0A%7C%20(a%2B2)%20%3A%3D%20a%0A%0Aexample%20%3A%20sub2%200%20%3D%200%20%3A%3D%20rfl%0Aexample%20%3A%20sub2%201%20%3D%200%20%3A%3D%20rfl%0Aexample%20(a%20%3A%20nat)%20%3A%20sub2%20(a%20%2B%202)%20%3D%20a%20%3A%3D%20rfl%0A%0Aexample%20%3A%20sub2%205%20%3D%203%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">sub2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">1</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sub2</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sub2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sub2</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sub2</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>You can write <code class="docutils literal notranslate"><span class="pre">#print</span> <span class="pre">sub2</span></code> to see how the function was compiled to recursors. (Lean will tell you that <code class="docutils literal notranslate"><span class="pre">sub2</span></code> has been defined in terms of an internal auxiliary function, <code class="docutils literal notranslate"><span class="pre">sub2._main</span></code>, but you can print that out too.)</p>
<p>Here are some more examples of nested pattern matching:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%7B%CE%B1%20%3A%20Type*%7D%20(p%20q%20%3A%20%CE%B1%20%E2%86%92%20Prop)%20%3A%0A%20%20(%E2%88%83%20x%2C%20p%20x%20%E2%88%A8%20q%20x)%20%E2%86%92%20(%E2%88%83%20x%2C%20p%20x)%20%E2%88%A8%20(%E2%88%83%20x%2C%20q%20x)%0A%7C%20(exists.intro%20x%20(or.inl%20px))%20%3A%3D%20or.inl%20(exists.intro%20x%20px)%0A%7C%20(exists.intro%20x%20(or.inr%20qx))%20%3A%3D%20or.inr%20(exists.intro%20x%20qx)%0A%0Adef%20foo%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20(0%2C%20n)%20%20%20%20%20%3A%3D%200%0A%7C%20(m%2B1%2C%200)%20%20%20%3A%3D%201%0A%7C%20(m%2B1%2C%20n%2B1)%20%3A%3D%202" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">x</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">exists.intro</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">(</span><span class="n">or.inl</span><span class="w"> </span><span class="n">px</span><span class="o">))</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="o">(</span><span class="n">exists.intro</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">px</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">exists.intro</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">(</span><span class="n">or.inr</span><span class="w"> </span><span class="n">qx</span><span class="o">))</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="o">(</span><span class="n">exists.intro</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">qx</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w">   </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</div><p>The equation compiler can process multiple arguments sequentially. For example, it would be more natural to define the previous example as a function of two arguments:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20n%20%20%20%20%20%3A%3D%200%0A%7C%20(m%2B1)%200%20%20%20%20%20%3A%3D%201%0A%7C%20(m%2B1)%20(n%2B1)%20%3A%3D%202" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="n">n</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</div><p>Here is another example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20bar%20%3A%20list%20%E2%84%95%20%E2%86%92%20list%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20%5B%5D%20%20%20%20%20%20%20%5B%5D%20%20%20%20%20%20%20%3A%3D%200%0A%7C%20(a%20%3A%3A%20l)%20%5B%5D%20%20%20%20%20%20%20%3A%3D%20a%0A%7C%20%5B%5D%20%20%20%20%20%20%20(b%20%3A%3A%20l)%20%3A%3D%20b%0A%7C%20(a%20%3A%3A%20l)%20(b%20%3A%3A%20m)%20%3A%3D%20a%20%2B%20b" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="o">[]</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">l</span><span class="o">)</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">l</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">b</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">l</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
</div><p>Note that, with compound expressions, parentheses are used to separate the arguments.</p>
<p>In each of the following examples, splitting occurs on only the first argument, even though the others are included among the list of patterns.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20band%20%3A%20bool%20%E2%86%92%20bool%20%E2%86%92%20bool%0A%7C%20tt%20a%20%3A%3D%20a%0A%7C%20ff%20_%20%3A%3D%20ff%0A%0Adef%20bor%20%3A%20bool%20%E2%86%92%20bool%20%E2%86%92%20bool%0A%7C%20tt%20_%20%3A%3D%20tt%0A%7C%20ff%20a%20%3A%3D%20a%0A%0Adef%20%7Bu%7D%20cond%20%7Ba%20%3A%20Type%20u%7D%20%3A%20bool%20%E2%86%92%20a%20%E2%86%92%20a%20%E2%86%92%20a%0A%7C%20tt%20x%20y%20%3A%3D%20x%0A%7C%20ff%20x%20y%20%3A%3D%20y%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">band</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span>
<span class="bp">|</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span>
<span class="bp">|</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">ff</span>

<span class="kd">def</span><span class="w"> </span><span class="n">bor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span>
<span class="bp">|</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tt</span>
<span class="bp">|</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span>

<span class="kd">def</span><span class="w"> </span><span class="o">{</span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">a</span>
<span class="bp">|</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span>
<span class="bp">|</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">y</span>
</pre></div>
</div>
</div><p>Notice also that, when the value of an argument is not needed in the definition, you can use an underscore instead. This underscore is known as a <em>wildcard pattern</em>, or an <em>anonymous variable</em>. In contrast to usage outside the equation compiler, here the underscore does <em>not</em> indicate an implicit argument. The use of underscores for wildcards is common in functional programming languages, and so Lean adopts that notation. <a class="reference internal" href="#wildcards-and-overlapping-patterns"><span class="std std-numref">Section 8.2</span></a> expands on the notion of a wildcard, and <a class="reference internal" href="#inaccessible-terms"><span class="std std-numref">Section 8.7</span></a> explains how you can use implicit arguments in patterns as well.</p>
<p>As described in <a class="reference internal" href="inductive_types.html#inductive-types"><span class="std std-numref">Chapter 7</span></a>, inductive data types can depend on parameters. The following example defines the <code class="docutils literal notranslate"><span class="pre">tail</span></code> function using pattern matching. The argument <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">:</span> <span class="pre">Type</span></code> is a parameter and occurs before the colon to indicate it does not participate in the pattern matching. Lean also allows parameters to occur after <code class="docutils literal notranslate"><span class="pre">:</span></code>, but it cannot pattern match on them.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20BEGIN%0Adef%20tail1%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%20%20%3A%3D%20%5B%5D%0A%7C%20(h%20%3A%3A%20t)%20%3A%3D%20t%0A%0Adef%20tail2%20%3A%20%CE%A0%20%7B%CE%B1%20%3A%20Type*%7D%2C%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%CE%B1%20%5B%5D%20%20%20%20%20%20%20%3A%3D%20%5B%5D%0A%7C%20%CE%B1%20(h%20%3A%3A%20t)%20%3A%3D%20t%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">tail1</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="o">[]</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">t</span>

<span class="kd">def</span><span class="w"> </span><span class="n">tail2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">},</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="o">[]</span>
<span class="bp">|</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">t</span>
</pre></div>
</div>
</div><p>Despite the different placement of the parameter <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> in these two examples, in both cases it treated in the same way, in that it does not participate in a case split.</p>
<p>Lean can also handle more complex forms of pattern matching, in which arguments to dependent types pose additional constraints on the various cases. Such examples of <em>dependent pattern matching</em> are considered in <a class="reference internal" href="#dependent-pattern-matching"><span class="std std-numref">Section 8.6</span></a>.</p>
</section>
<section id="wildcards-and-overlapping-patterns">
<span id="id3"></span><h2><span class="section-number">8.2. </span>Wildcards and Overlapping Patterns<a class="headerlink" href="#wildcards-and-overlapping-patterns" title="Link to this heading">&#182;</a></h2>
<p>Consider one of the examples from the last section:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20n%20%20%20%20%20%3A%3D%200%0A%7C%20(m%2B1)%200%20%20%20%20%20%3A%3D%201%0A%7C%20(m%2B1)%20(n%2B1)%20%3A%3D%202" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="n">n</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</div><p>The example can be written more concisely:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20n%20%3A%3D%200%0A%7C%20m%200%20%3A%3D%201%0A%7C%20m%20n%20%3A%3D%202" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</div><p>In the second presentation, the patterns overlap; for example, the pair of arguments <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code> matches all three cases. But Lean handles the ambiguity by using the first applicable equation, so the net result is the same. In particular, the following equations hold definitionally:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20n%20%3A%3D%200%0A%7C%20m%200%20%3A%3D%201%0A%7C%20m%20n%20%3A%3D%202%0A%0A--%20BEGIN%0Avariables%20(m%20n%20%3A%20nat)%0A%0Aexample%20%3A%20foo%200%20%20%20%20%200%20%20%20%20%20%3D%200%20%3A%3D%20rfl%0Aexample%20%3A%20foo%200%20%20%20%20%20(n%2B1)%20%3D%200%20%3A%3D%20rfl%0Aexample%20%3A%20foo%20(m%2B1)%200%20%20%20%20%20%3D%201%20%3A%3D%20rfl%0Aexample%20%3A%20foo%20(m%2B1)%20(n%2B1)%20%3D%202%20%3A%3D%20rfl%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="mi">0</span><span class="w">     </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>Since the values of <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> are not needed, we can just as well use wildcard patterns instead.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20_%20%3A%3D%200%0A%7C%20_%200%20%3A%3D%201%0A%7C%20_%20_%20%3A%3D%202" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</div><p>You can check that this definition of <code class="docutils literal notranslate"><span class="pre">foo</span></code> satisfies the same definitional identities as before.</p>
<p>Some functional programming languages support <em>incomplete patterns</em>. In these languages, the interpreter produces an exception or returns an arbitrary value for incomplete cases. We can simulate the arbitrary value approach using the <code class="docutils literal notranslate"><span class="pre">inhabited</span></code> type class. Roughly, an element of <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">&#945;</span></code> is a witness to the fact that there is an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>; in <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a> we will see that Lean can be instructed that suitable base types are inhabited, and can automatically infer that other constructed types are inhabited on that basis. On this basis, the standard library provides an arbitrary element, <code class="docutils literal notranslate"><span class="pre">arbitrary</span> <span class="pre">&#945;</span></code>, of any inhabited type.</p>
<p>We can also use the type <code class="docutils literal notranslate"><span class="pre">option</span> <span class="pre">&#945;</span></code> to simulate incomplete patterns. The idea is to return <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">a</span></code> for the provided patterns, and use <code class="docutils literal notranslate"><span class="pre">none</span></code> for the incomplete cases. The following example demonstrates both approaches.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20f1%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20_%20%20%3A%3D%201%0A%7C%20_%20%200%20%20%3A%3D%202%0A%7C%20_%20%20_%20%20%3A%3D%20arbitrary%20%E2%84%95%20%20%20--%20the%20%22incomplete%22%20case%0A%0Avariables%20(a%20b%20%3A%20%E2%84%95)%0A%0Aexample%20%3A%20f1%200%20%20%20%20%200%20%20%20%20%20%3D%201%20%3A%3D%20rfl%0Aexample%20%3A%20f1%200%20%20%20%20%20(a%2B1)%20%3D%201%20%3A%3D%20rfl%0Aexample%20%3A%20f1%20(a%2B1)%200%20%20%20%20%20%3D%202%20%3A%3D%20rfl%0Aexample%20%3A%20f1%20(a%2B1)%20(b%2B1)%20%3D%20arbitrary%20nat%20%3A%3D%20rfl%0A%0Adef%20f2%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20option%20%E2%84%95%0A%7C%200%20%20_%20%20%3A%3D%20some%201%0A%7C%20_%20%200%20%20%3A%3D%20some%202%0A%7C%20_%20%20_%20%20%3A%3D%20none%20%20%20%20%20%20%20%20%20%20--%20the%20%22incomplete%22%20case%0A%0Aexample%20%3A%20f2%200%20%20%20%20%200%20%20%20%20%20%3D%20some%201%20%3A%3D%20rfl%0Aexample%20%3A%20f2%200%20%20%20%20%20(a%2B1)%20%3D%20some%201%20%3A%3D%20rfl%0Aexample%20%3A%20f2%20(a%2B1)%200%20%20%20%20%20%3D%20some%202%20%3A%3D%20rfl%0Aexample%20%3A%20f2%20(a%2B1)%20(b%2B1)%20%3D%20none%20%20%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">  </span><span class="n">_</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w">  </span><span class="mi">0</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w">  </span><span class="n">_</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">arbitrary</span><span class="w"> </span><span class="n">&#8469;</span><span class="w">   </span><span class="c1">-- the &quot;incomplete&quot; case</span>

<span class="kd">variables</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="mi">0</span><span class="w">     </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="bp">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">arbitrary</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">def</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">  </span><span class="n">_</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w">  </span><span class="mi">0</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="mi">2</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w">  </span><span class="n">_</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">none</span><span class="w">          </span><span class="c1">-- the &quot;incomplete&quot; case</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="mi">0</span><span class="w">     </span><span class="bp">=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="bp">=</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">none</span><span class="w">   </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>The equation compiler is clever. If you leave out any of the cases in the following definition, the error message will let you know what has not been covered.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20bar%20%3A%20%E2%84%95%20%E2%86%92%20list%20%E2%84%95%20%E2%86%92%20bool%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20_%20%20%20%20%20%20%20%20ff%20%3A%3D%200%0A%7C%200%20%20%20%20%20(b%20%3A%3A%20_)%20_%20%20%3A%3D%20b%0A%7C%200%20%20%20%20%20%5B%5D%20%20%20%20%20%20%20tt%20%3A%3D%207%0A%7C%20(a%2B1)%20%5B%5D%20%20%20%20%20%20%20ff%20%3A%3D%20a%0A%7C%20(a%2B1)%20%5B%5D%20%20%20%20%20%20%20tt%20%3A%3D%20a%20%2B%201%0A%7C%20(a%2B1)%20(b%20%3A%3A%20_)%20_%20%20%3A%3D%20a%20%2B%20b" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="n">_</span><span class="w">        </span><span class="n">ff</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">_</span><span class="o">)</span><span class="w"> </span><span class="n">_</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">b</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">[]</span><span class="w">       </span><span class="n">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">7</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="n">ff</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="n">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">_</span><span class="o">)</span><span class="w"> </span><span class="n">_</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
</div><p>It will also use an &#8220;if &#8230; then &#8230; else&#8221; instead of a <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> in appropriate situations.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20%3A%20char%20%E2%86%92%20%E2%84%95%0A%7C%20'A'%20%3A%3D%201%0A%7C%20'B'%20%3A%3D%202%0A%7C%20_%20%20%20%3A%3D%203%0A%0A%23print%20foo._main" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">char</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="sc">&#39;B&#39;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w">   </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span>

<span class="k">#print</span><span class="w"> </span><span class="n">foo._main</span>
</pre></div>
</div>
</div></section>
<section id="structural-recursion-and-induction">
<span id="id4"></span><h2><span class="section-number">8.3. </span>Structural Recursion and Induction<a class="headerlink" href="#structural-recursion-and-induction" title="Link to this heading">&#182;</a></h2>
<p>What makes the equation compiler powerful is that it also supports recursive definitions. In the next three sections, we will describe, respectively:</p>
<ul class="simple">
<li><p>structurally recursive definitions</p></li>
<li><p>well-founded recursive definitions</p></li>
<li><p>mutually recursive definitions</p></li>
</ul>
<p>Generally speaking, the equation compiler processes input of the following form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def foo (a : &#945;) : &#928; (b : &#946;), &#947;
| [patterns&#8321;] := t&#8321;
...
| [patterns&#8345;] := t&#8345;
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">:</span> <span class="pre">&#945;)</span></code> is a sequence of parameters, <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">&#946;)</span></code> is the sequence of arguments on which pattern matching takes place, and <code class="docutils literal notranslate"><span class="pre">&#947;</span></code> is any type, which can depend on <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. Each line should contain the same number of patterns, one for each element of &#946;. As we have seen, a pattern is either a variable, a constructor applied to other patterns, or an expression that normalizes to something of that form (where the non-constructors are marked with the <code class="docutils literal notranslate"><span class="pre">[pattern]</span></code> attribute). The appearances of constructors prompt case splits, with the arguments to the constructors represented by the given variables. In <a class="reference internal" href="#dependent-pattern-matching"><span class="std std-numref">Section 8.6</span></a>, we will see that it is sometimes necessary to include explicit terms in patterns that are needed to make an expression type check, though they do not play a role in pattern matching. These are called &#8220;inaccessible terms,&#8221; for that reason. But we will not need to use such inaccessible terms before <a class="reference internal" href="#dependent-pattern-matching"><span class="std std-numref">Section 8.6</span></a>.</p>
<p>As we saw in the last section, the terms <code class="docutils literal notranslate"><span class="pre">t&#8321;,</span> <span class="pre">...,</span> <span class="pre">t&#8345;</span></code> can make use of any of the parameters <code class="docutils literal notranslate"><span class="pre">a</span></code>, as well as any of the variables that are introduced in the corresponding patterns. What makes recursion and induction possible is that they can also involve recursive calls to <code class="docutils literal notranslate"><span class="pre">foo</span></code>. In this section, we will deal with <em>structural recursion</em>, in which the arguments to <code class="docutils literal notranslate"><span class="pre">foo</span></code> occurring on the right-hand side of the <code class="docutils literal notranslate"><span class="pre">:=</span></code> are subterms of the patterns on the left-hand side. The idea is that they are structurally smaller, and hence appear in the inductive type at an earlier stage. Here are some examples of structural recursion from the last chapter, now defined using the equation compiler:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A%0Anamespace%20nat%0A%0A--%20BEGIN%0Adef%20add%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20m%20zero%20%20%20%20%20%3A%3D%20m%0A%7C%20m%20(succ%20n)%20%3A%3D%20succ%20(add%20m%20n)%0A%0Alocal%20infix%20(name%20%3A%3D%20add)%20%60%20%2B%20%60%20%3A%3D%20add%0A%0Atheorem%20add_zero%20(m%20%3A%20nat)%20%3A%20m%20%2B%20zero%20%3D%20m%20%3A%3D%20rfl%0Atheorem%20add_succ%20(m%20n%20%3A%20nat)%20%3A%20m%20%2B%20succ%20n%20%3D%20succ%20(m%20%2B%20n)%20%3A%3D%20rfl%0A%0Atheorem%20zero_add%20%3A%20%E2%88%80%20n%2C%20zero%20%2B%20n%20%3D%20n%0A%7C%20zero%20%20%20%20%20%3A%3D%20rfl%0A%7C%20(succ%20n)%20%3A%3D%20congr_arg%20succ%20(zero_add%20n)%0A%0Adef%20mul%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20n%20zero%20%20%20%20%20%3A%3D%20zero%0A%7C%20n%20(succ%20m)%20%3A%3D%20mul%20n%20m%20%2B%20n%0A--%20END%0A%0Aend%20nat%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">m</span>
<span class="bp">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">add</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="o">)</span>

<span class="kn">local</span><span class="w"> </span><span class="kd">infix</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">add</span><span class="o">)</span><span class="w"> </span><span class="bp">`</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">add</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">add_zero</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">add_succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">congr_arg</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">zero_add</span><span class="w"> </span><span class="n">n</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">zero</span>
<span class="bp">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span>
</pre></div>
</div>
</div><p>The proof of <code class="docutils literal notranslate"><span class="pre">zero_add</span></code> makes it clear that proof by induction is really a form of induction in Lean.</p>
<p>The example above shows that the defining equations for <code class="docutils literal notranslate"><span class="pre">add</span></code> hold definitionally, and the same is true of <code class="docutils literal notranslate"><span class="pre">mul</span></code>. The equation compiler tries to ensure that this holds whenever possible, as is the case with straightforward structural induction. In other situations, however, reductions hold only <em>propositionally</em>, which is to say, they are equational theorems that must be applied explicitly. The equation compiler generates such theorems internally. They are not meant to be used directly by the user; rather, the <cite>simp</cite> and <cite>rewrite</cite> tactics are configured to use them when necessary. Thus both of the following proofs of <cite>zero_add</cite> work:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A%0Anamespace%20nat%0A%0Adef%20add%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20m%20zero%20%20%20%20%20%3A%3D%20m%0A%7C%20m%20(succ%20n)%20%3A%3D%20succ%20(add%20m%20n)%0A%0Alocal%20infix%20(name%20%3A%3D%20add)%20%60%20%2B%20%60%20%3A%3D%20add%0A%0A--%20BEGIN%0Atheorem%20zero_add%20%3A%20%E2%88%80%20n%2C%20zero%20%2B%20n%20%3D%20n%0A%7C%20zero%20%20%20%20%20%3A%3D%20by%20simp%20%5Badd%5D%0A%7C%20(succ%20n)%20%3A%3D%20by%20simp%20%5Badd%2C%20zero_add%20n%5D%0A%0Atheorem%20zero_add'%20%3A%20%E2%88%80%20n%2C%20zero%20%2B%20n%20%3D%20n%0A%7C%20zero%20%20%20%20%20%3A%3D%20by%20rw%20%5Badd%5D%0A%7C%20(succ%20n)%20%3A%3D%20by%20rw%20%5Badd%2C%20zero_add'%20n%5D%0A--%20END%0A%0Aend%20nat%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">add</span><span class="o">]</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">add</span><span class="o">,</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="n">n</span><span class="o">]</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">add</span><span class="o">]</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">add</span><span class="o">,</span><span class="w"> </span><span class="n">zero_add&#39;</span><span class="w"> </span><span class="n">n</span><span class="o">]</span>
</pre></div>
</div>
</div><p>In fact, because in this case the defining equations hold definitionally, we can use <cite>dsimp</cite>, the simplifier that uses definitional reductions only, to carry out the first step.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A%0Anamespace%20nat%0A%0Adef%20add%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20m%20zero%20%20%20%20%20%3A%3D%20m%0A%7C%20m%20(succ%20n)%20%3A%3D%20succ%20(add%20m%20n)%0A%0Alocal%20infix%20(name%20%3A%3D%20add)%20%60%20%2B%20%60%20%3A%3D%20add%0A%0A--%20BEGIN%0Atheorem%20zero_add%20%3A%20%E2%88%80%20n%2C%20zero%20%2B%20n%20%3D%20n%0A%7C%20zero%20%20%20%20%20%3A%3D%20by%20dsimp%20%5Badd%5D%3B%20reflexivity%0A%7C%20(succ%20n)%20%3A%3D%20by%20dsimp%20%5Badd%5D%3B%20rw%20%5Bzero_add%20n%5D%0A--%20END%0A%0Aend%20nat%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">dsimp</span><span class="w"> </span><span class="o">[</span><span class="n">add</span><span class="o">]</span><span class="bp">;</span><span class="w"> </span><span class="n">reflexivity</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">dsimp</span><span class="w"> </span><span class="o">[</span><span class="n">add</span><span class="o">]</span><span class="bp">;</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">zero_add</span><span class="w"> </span><span class="n">n</span><span class="o">]</span>
</pre></div>
</div>
</div><p>As with definition by pattern matching, parameters to a structural recursion or induction may appear before the colon. Such parameters are simply added to the local context before the definition is processed. For example, the definition of addition may also be written as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A%0Anamespace%20nat%0A%0A--%20BEGIN%0Adef%20add%20(m%20%3A%20nat)%20%3A%20nat%20%E2%86%92%20nat%0A%7C%20zero%20%20%20%20%20%3A%3D%20m%0A%7C%20(succ%20n)%20%3A%3D%20succ%20(add%20n)%0A--%20END%0A%0Aend%20nat%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">m</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">add</span><span class="w"> </span><span class="n">n</span><span class="o">)</span>
</pre></div>
</div>
</div><p>This may seem a little odd, but you should read the definition as follows: &#8220;Fix <code class="docutils literal notranslate"><span class="pre">m</span></code>, and define the function which adds something to <code class="docutils literal notranslate"><span class="pre">m</span></code> recursively, as follows. To add zero, return <code class="docutils literal notranslate"><span class="pre">m</span></code>. To add the successor of <code class="docutils literal notranslate"><span class="pre">n</span></code>, first add <code class="docutils literal notranslate"><span class="pre">n</span></code>, and then take the successor.&#8221; The mechanism for adding parameters to the local context is what makes it possible to process match expressions within terms, as described in <a class="reference internal" href="#match-expressions"><span class="std std-numref">Section 8.8</span></a>.</p>
<p>A more interesting example of structural recursion is given by the Fibonacci function <code class="docutils literal notranslate"><span class="pre">fib</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20fib%20%3A%20nat%20%E2%86%92%20nat%0A%7C%200%20%20%20%20%20%3A%3D%201%0A%7C%201%20%20%20%20%20%3A%3D%201%0A%7C%20(n%2B2)%20%3A%3D%20fib%20(n%2B1)%20%2B%20fib%20n%0A%0Aexample%20%3A%20fib%200%20%3D%201%20%3A%3D%20rfl%0Aexample%20%3A%20fib%201%20%3D%201%20%3A%3D%20rfl%0Aexample%20(n%20%3A%20nat)%20%3A%20fib%20(n%20%2B%202)%20%3D%20fib%20(n%20%2B%201)%20%2B%20fib%20n%20%3A%3D%20rfl%0A%0Aexample%20%3A%20fib%207%20%3D%2021%20%3A%3D%20rfl%0Aexample%20%3A%20fib%207%20%3D%2021%20%3A%3D%0Abegin%0A%20%20dsimp%20%5Bfib%5D%2C%20%20%20--%20expands%20fib%207%20as%20a%20sum%20of%201's%0A%20%20reflexivity%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">1</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="n">n</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">21</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">21</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">dsimp</span><span class="w"> </span><span class="o">[</span><span class="n">fib</span><span class="o">],</span><span class="w">   </span><span class="c1">-- expands fib 7 as a sum of 1&#39;s</span>
<span class="w">  </span><span class="n">reflexivity</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Here, the value of the <code class="docutils literal notranslate"><span class="pre">fib</span></code> function at <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">2</span></code> (which is definitionally equal to <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(succ</span> <span class="pre">n)</span></code>) is defined in terms of the values at <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> (which is definitionally equivalent to <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">n</span></code>) and the value at <code class="docutils literal notranslate"><span class="pre">n</span></code>. This is a notoriously inefficient way of computing the fibonacci function, however, with an execution time that is exponential in <code class="docutils literal notranslate"><span class="pre">n</span></code>. Here is a better way:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20fib_aux%20%3A%20nat%20%E2%86%92%20nat%20%C3%97%20nat%0A%7C%200%20%20%20%20%20%20%20%3A%3D%20(0%2C%201)%0A%7C%20(n%20%2B%201)%20%3A%3D%20let%20p%20%3A%3D%20fib_aux%20n%20in%20(p.2%2C%20p.1%20%2B%20p.2)%0A%0Adef%20fib%20(n%20%3A%20nat)%20%3A%3D%20(fib_aux%20n).1%0A%0A%23eval%20fib%20100" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">fib_aux</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">fib_aux</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="n">fib_aux</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="k">#eval</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="mi">100</span>
</pre></div>
</div>
</div><p>Another good example of a recursive definition is the list <code class="docutils literal notranslate"><span class="pre">append</span></code> function.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Adef%20append%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20l%20%3A%3D%20l%0A%7C%20(h%3A%3At)%20l%20%3A%3D%20h%20%3A%3A%20append%20t%20l%0A%0Aexample%20%3A%20append%20%5B(1%20%3A%20%E2%84%95)%2C%202%2C%203%5D%20%5B4%2C%205%5D%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%20%3A%3D%20rfl%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">     </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">l</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">l</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="o">[(</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">),</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>Here is another: it adds elements of the first list to elements of the second list, until one of the two lists runs out.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20%7Bu%7D%20list_add%20%7B%CE%B1%20%3A%20Type%20u%7D%20%5Bhas_add%20%CE%B1%5D%20%3A%0A%20%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%20%20_%20%20%20%20%20%20%20%20%3A%3D%20%5B%5D%0A%7C%20_%20%20%20%20%20%20%20%20%5B%5D%20%20%20%20%20%20%20%3A%3D%20%5B%5D%0A%7C%20(a%20%3A%3A%20l)%20(b%20%3A%3A%20m)%20%3A%3D%20(a%20%2B%20b)%20%3A%3A%20list_add%20l%20m%0A%0A%23eval%20list_add%20%5B1%2C%202%2C%203%5D%20%5B4%2C%205%2C%206%2C%206%2C%209%2C%2010%5D" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="o">{</span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="n">list_add</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="n">_</span><span class="w">        </span><span class="o">:=</span><span class="w"> </span><span class="o">[]</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w">        </span><span class="o">[]</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="o">[]</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">l</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">list_add</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">m</span>

<span class="k">#eval</span><span class="w"> </span><span class="n">list_add</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="mi">9</span><span class="o">,</span><span class="w"> </span><span class="mi">10</span><span class="o">]</span>
</pre></div>
</div>
</div><p>You are encouraged to experiment with similar examples in the exercises below.</p>
</section>
<section id="well-founded-recursion-and-induction">
<span id="id5"></span><h2><span class="section-number">8.4. </span>Well-Founded Recursion and Induction<a class="headerlink" href="#well-founded-recursion-and-induction" title="Link to this heading">&#182;</a></h2>
<p>Dependent type theory is powerful enough to encode and justify well-founded recursion. Let us start with the logical background that is needed to understand how it works.</p>
<p>Lean&#8217;s standard library defines two predicates, <code class="docutils literal notranslate"><span class="pre">acc</span> <span class="pre">r</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">well_founded</span> <span class="pre">r</span></code>, where <code class="docutils literal notranslate"><span class="pre">r</span></code> is a binary relation on a type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, and <code class="docutils literal notranslate"><span class="pre">a</span></code> is an element of type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Avariable%20%CE%B1%20%3A%20Sort%20u%0Avariable%20r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop%0A%0A%23check%20(acc%20r%20%3A%20%CE%B1%20%E2%86%92%20Prop)%0A%0A%23check%20(well_founded%20r%20%3A%20Prop)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span><span class="w"> </span><span class="n">u</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">acc</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">well_founded</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The first, <code class="docutils literal notranslate"><span class="pre">acc</span></code>, is an inductively defined predicate. According to its definition, <code class="docutils literal notranslate"><span class="pre">acc</span> <span class="pre">r</span> <span class="pre">x</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">y,</span> <span class="pre">r</span> <span class="pre">y</span> <span class="pre">x</span> <span class="pre">&#8594;</span> <span class="pre">acc</span> <span class="pre">r</span> <span class="pre">y</span></code>. If you think of <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">y</span> <span class="pre">x</span></code> as denoting a kind of order relation <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&#8826;</span> <span class="pre">x</span></code>, then <code class="docutils literal notranslate"><span class="pre">acc</span> <span class="pre">r</span> <span class="pre">x</span></code> says that <code class="docutils literal notranslate"><span class="pre">x</span></code> is accessible from below, in the sense that all its predecessors are accessible. In particular, if <code class="docutils literal notranslate"><span class="pre">x</span></code> has no predecessors, it is accessible. Given any type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, we should be able to assign a value to each accessible element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, recursively, by assigning values to all its predecessors first.</p>
<p>The statement that <code class="docutils literal notranslate"><span class="pre">r</span></code> is well founded, denoted <code class="docutils literal notranslate"><span class="pre">well_founded</span> <span class="pre">r</span></code>, is exactly the statement that every element of the type is accessible. By the above considerations, if <code class="docutils literal notranslate"><span class="pre">r</span></code> is a well-founded relation on a type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, we should have a principle of well-founded recursion on <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, with respect to the relation <code class="docutils literal notranslate"><span class="pre">r</span></code>. And, indeed, we do: the standard library defines <code class="docutils literal notranslate"><span class="pre">well_founded.fix</span></code>, which serves exactly that purpose.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universes%20u%20v%0Avariable%20%CE%B1%20%3A%20Sort%20u%0Avariable%20r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop%0Avariable%20h%20%3A%20well_founded%20r%0A%0Avariable%20C%20%3A%20%CE%B1%20%E2%86%92%20Sort%20v%0Avariable%20F%20%3A%20%CE%A0%20x%2C%20(%CE%A0%20(y%20%3A%20%CE%B1)%2C%20r%20y%20x%20%E2%86%92%20C%20y)%20%E2%86%92%20C%20x%0A%0Adef%20f%20%3A%20%CE%A0%20(x%20%3A%20%CE%B1)%2C%20C%20x%20%3A%3D%20well_founded.fix%20h%20F" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">well_founded</span><span class="w"> </span><span class="n">r</span>

<span class="kd">variable</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">v</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="bp">&#928;</span><span class="w"> </span><span class="o">(</span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">x</span>

<span class="kd">def</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">well_founded.fix</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">F</span>
</pre></div>
</div>
</div><p>There is a long cast of characters here, but the first block we have already seen: the type, <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, the relation, <code class="docutils literal notranslate"><span class="pre">r</span></code>, and the assumption, <code class="docutils literal notranslate"><span class="pre">h</span></code>, that <code class="docutils literal notranslate"><span class="pre">r</span></code> is well founded. The variable <code class="docutils literal notranslate"><span class="pre">C</span></code> represents the motive of the recursive definition: for each element <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, we would like to construct an element of <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span></code>. The function <code class="docutils literal notranslate"><span class="pre">F</span></code> provides the inductive recipe for doing that: it tells us how to construct an element <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span></code>, given elements of <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">y</span></code> for each predecessor <code class="docutils literal notranslate"><span class="pre">y</span></code> of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">well_founded.fix</span></code> works equally well as an induction principle. It says that if <code class="docutils literal notranslate"><span class="pre">&#8826;</span></code> is well founded and you want to prove <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x,</span> <span class="pre">C</span> <span class="pre">x</span></code>, it suffices to show that for an arbitrary <code class="docutils literal notranslate"><span class="pre">x</span></code>, if we have <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">y</span> <span class="pre">&#8826;</span> <span class="pre">x,</span> <span class="pre">C</span> <span class="pre">y</span></code>, then we have <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span></code>.</p>
<p>Lean knows that the usual order <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> on the natural numbers is well founded. It also knows a number of ways of constructing new well founded orders from others, for example, using lexicographic order.</p>
<p>Here is essentially the definition of division on the natural numbers that is found in the standard library.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aopen%20nat%0A%0Adef%20div_rec_lemma%20%7Bx%20y%20%3A%20%E2%84%95%7D%20%3A%200%20%3C%20y%20%E2%88%A7%20y%20%E2%89%A4%20x%20%E2%86%92%20x%20-%20y%20%3C%20x%20%3A%3D%0A%CE%BB%20h%2C%20nat.sub_lt%20(lt_of_lt_of_le%20h.left%20h.right)%20h.left%0A%0Adef%20div.F%20(x%20%3A%20%E2%84%95)%20(f%20%3A%20%CE%A0%20x%E2%82%81%2C%20x%E2%82%81%20%3C%20x%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95)%20(y%20%3A%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Aif%20h%20%3A%200%20%3C%20y%20%E2%88%A7%20y%20%E2%89%A4%20x%20then%0A%20%20f%20(x%20-%20y)%20(div_rec_lemma%20h)%20y%20%2B%201%0Aelse%0A%20%20zero%0A%0Adef%20div%20%3A%3D%20well_founded.fix%20lt_wf%20div.F%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">def</span><span class="w"> </span><span class="n">div_rec_lemma</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8804;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="n">nat.sub_lt</span><span class="w"> </span><span class="o">(</span><span class="n">lt_of_lt_of_le</span><span class="w"> </span><span class="n">h.left</span><span class="w"> </span><span class="n">h.right</span><span class="o">)</span><span class="w"> </span><span class="n">h.left</span>

<span class="kd">def</span><span class="w"> </span><span class="n">div.F</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">x&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">x&#8321;</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="k">if</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8804;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">div_rec_lemma</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span>
<span class="k">else</span>
<span class="w">  </span><span class="n">zero</span>

<span class="kd">def</span><span class="w"> </span><span class="n">div</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">well_founded.fix</span><span class="w"> </span><span class="n">lt_wf</span><span class="w"> </span><span class="n">div.F</span>
</pre></div>
</div>
</div><p>The definition is somewhat inscrutable. Here the recursion is on <code class="docutils literal notranslate"><span class="pre">x</span></code>, and <code class="docutils literal notranslate"><span class="pre">div.F</span> <span class="pre">x</span> <span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8469;</span></code> returns the &#8220;divide by <code class="docutils literal notranslate"><span class="pre">y</span></code>&#8221; function for that fixed <code class="docutils literal notranslate"><span class="pre">x</span></code>. You have to remember that the second argument to <code class="docutils literal notranslate"><span class="pre">div.F</span></code>, the recipe for the recursion, is a function that is supposed to return the divide by <code class="docutils literal notranslate"><span class="pre">y</span></code> function for all values <code class="docutils literal notranslate"><span class="pre">x&#8321;</span></code> smaller than <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The equation compiler is designed to make definitions like this more convenient. It accepts the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0A--%20BEGIN%0Adef%20div%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20x%20y%20%3A%3D%0A%20%20if%20h%20%3A%200%20%3C%20y%20%E2%88%A7%20y%20%E2%89%A4%20x%20then%0A%20%20%20%20have%20x%20-%20y%20%3C%20x%2C%0A%20%20%20%20%20%20from%20nat.sub_lt%20(lt_of_lt_of_le%20h.left%20h.right)%20h.left%2C%0A%20%20%20%20div%20(x%20-%20y)%20y%20%2B%201%0A%20%20else%0A%20%20%20%200%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">div</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8804;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="k">have</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span>
<span class="w">      </span><span class="k">from</span><span class="w"> </span><span class="n">nat.sub_lt</span><span class="w"> </span><span class="o">(</span><span class="n">lt_of_lt_of_le</span><span class="w"> </span><span class="n">h.left</span><span class="w"> </span><span class="n">h.right</span><span class="o">)</span><span class="w"> </span><span class="n">h.left</span><span class="o">,</span>
<span class="w">    </span><span class="n">div</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="mi">0</span>
</pre></div>
</div>
</div><p>When the equation compiler encounters a recursive definition, it first tries structural recursion, and only when that fails, does it fall back on well-founded recursion. In this case, detecting the possibility of well-founded recursion on the natural numbers, it uses the usual lexicographic ordering on the pair <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>. The equation compiler in and of itself is not clever enough to derive that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code> is less than <code class="docutils literal notranslate"><span class="pre">x</span></code> under the given hypotheses, but we can help it out by putting this fact in the local context. The equation compiler looks in the local context for such information, and, when it finds it, puts it to good use.</p>
<p>The defining equation for <code class="docutils literal notranslate"><span class="pre">div</span></code> does <em>not</em> hold definitionally, but the equation is available to <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> and <code class="docutils literal notranslate"><span class="pre">simp</span></code>. The simplifier will loop if you apply it blindly, but <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> will do the trick.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0Adef%20div%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20x%20y%20%3A%3D%0A%20%20if%20h%20%3A%200%20%3C%20y%20%E2%88%A7%20y%20%E2%89%A4%20x%20then%0A%20%20%20%20have%20x%20-%20y%20%3C%20x%2C%0A%20%20%20%20%20%20from%20nat.sub_lt%20(lt_of_lt_of_le%20h.left%20h.right)%20h.left%2C%0A%20%20%20%20div%20(x%20-%20y)%20y%20%2B%201%0A%20%20else%0A%20%20%20%200%0A%0A--%20BEGIN%0Aexample%20(x%20y%20%3A%20%E2%84%95)%20%3A%0A%20%20div%20x%20y%20%3D%20if%200%20%3C%20y%20%E2%88%A7%20y%20%E2%89%A4%20x%20then%20div%20(x%20-%20y)%20y%20%2B%201%20else%200%20%3A%3D%0Aby%20rw%20%5Bdiv%5D%0A%0Aexample%20(x%20y%20%3A%20%E2%84%95)%20(h%20%3A%200%20%3C%20y%20%E2%88%A7%20y%20%E2%89%A4%20x)%20%3A%0A%20%20div%20x%20y%20%3D%20div%20(x%20-%20y)%20y%20%2B%201%20%3A%3D%0Aby%20rw%20%5Bdiv%2C%20if_pos%20h%5D%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">div</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8804;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">div</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">div</span><span class="o">]</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8804;</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">div</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">div</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">div</span><span class="o">,</span><span class="w"> </span><span class="n">if_pos</span><span class="w"> </span><span class="n">h</span><span class="o">]</span>
</pre></div>
</div>
</div><p>The following example is similar: it converts any natural number to a binary expression, represented as a list of 0&#8217;s and 1&#8217;s. We have to provide the equation compiler with evidence that the recursive call is decreasing, which we do here with a <code class="docutils literal notranslate"><span class="pre">sorry</span></code>. The <code class="docutils literal notranslate"><span class="pre">sorry</span></code> does not prevent the bytecode evaluator from evaluating the function successfully.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20nat_to_bin%20%3A%20%E2%84%95%20%E2%86%92%20list%20%E2%84%95%0A%7C%200%20%20%20%20%20%20%20%3A%3D%20%5B0%5D%0A%7C%201%20%20%20%20%20%20%20%3A%3D%20%5B1%5D%0A%7C%20(n%20%2B%202)%20%3A%3D%0A%20%20have%20(n%20%2B%202)%20%2F%202%20%3C%20n%20%2B%202%2C%20from%20sorry%2C%0A%20%20nat_to_bin%20((n%20%2B%202)%20%2F%202)%20%2B%2B%20%5Bn%20%25%202%5D%0A%0A%23eval%20nat_to_bin%201234567" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">nat_to_bin</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">1</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="k">have</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="gr">sorry</span><span class="o">,</span>
<span class="w">  </span><span class="n">nat_to_bin</span><span class="w"> </span><span class="o">((</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">/</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="o">[</span><span class="n">n</span><span class="w"> </span><span class="bp">%</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span>

<span class="k">#eval</span><span class="w"> </span><span class="n">nat_to_bin</span><span class="w"> </span><span class="mi">1234567</span>
</pre></div>
</div>
</div><p>As a final example, we observe that Ackermann&#8217;s function can be defined directly, because it is justified by the well foundedness of the lexicographic order on the natural numbers.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20ack%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%200%20%20%20%20%20y%20%20%20%20%20%3A%3D%20y%2B1%0A%7C%20(x%2B1)%200%20%20%20%20%20%3A%3D%20ack%20x%201%0A%7C%20(x%2B1)%20(y%2B1)%20%3A%3D%20ack%20x%20(ack%20(x%2B1)%20y)%0A%0A%23eval%20ack%203%205" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">ack</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="n">y</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">y</span><span class="bp">+</span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">ack</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">ack</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">(</span><span class="n">ack</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="n">y</span><span class="o">)</span>

<span class="k">#eval</span><span class="w"> </span><span class="n">ack</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span>
</pre></div>
</div>
</div><p>Lean&#8217;s mechanisms for guessing a well-founded relation and then proving that recursive calls decrease are still in a rudimentary state. They will be improved over time. When they work, they provide a much more convenient way of defining functions than using <code class="docutils literal notranslate"><span class="pre">well_founded.fix</span></code> manually. When they don&#8217;t, the latter is always available as a backup.</p>
</section>
<section id="mutual-recursion">
<span id="nested-and-mutual-recursion"></span><h2><span class="section-number">8.5. </span>Mutual Recursion<a class="headerlink" href="#mutual-recursion" title="Link to this heading">&#182;</a></h2>
<p>Lean also supports mutual recursive definitions. The syntax is similar to that for mutual inductive types, as described in <a class="reference internal" href="inductive_types.html#mutual-and-nested-inductive-types"><span class="std std-numref">Section 7.9</span></a>. Here is an example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=mutual%20def%20even%2C%20odd%0Awith%20even%20%3A%20nat%20%E2%86%92%20bool%0A%7C%200%20%20%20%20%20%3A%3D%20tt%0A%7C%20(a%2B1)%20%3A%3D%20odd%20a%0Awith%20odd%20%3A%20nat%20%E2%86%92%20bool%0A%7C%200%20%20%20%20%20%3A%3D%20ff%0A%7C%20(a%2B1)%20%3A%3D%20even%20a%0A%0Aexample%20(a%20%3A%20nat)%20%3A%20even%20(a%20%2B%201)%20%3D%20odd%20a%20%3A%3D%0Aby%20simp%20%5Beven%5D%0A%0Aexample%20(a%20%3A%20nat)%20%3A%20odd%20(a%20%2B%201)%20%3D%20even%20a%20%3A%3D%0Aby%20simp%20%5Bodd%5D%0A%0Alemma%20even_eq_not_odd%20%3A%20%E2%88%80%20a%2C%20even%20a%20%3D%20bnot%20(odd%20a)%20%3A%3D%0Abegin%0A%20%20intro%20a%2C%20induction%20a%2C%0A%20%20simp%20%5Beven%2C%20odd%5D%2C%0A%20%20simp%20%5B*%2C%20even%2C%20odd%5D%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">mutual</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">even</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span>
<span class="k">with</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">tt</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="n">a</span>
<span class="k">with</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">ff</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">a</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">even</span><span class="o">]</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">odd</span><span class="o">]</span>

<span class="kd">lemma</span><span class="w"> </span><span class="n">even_eq_not_odd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">bnot</span><span class="w"> </span><span class="o">(</span><span class="n">odd</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">intro</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">induction</span><span class="w"> </span><span class="n">a</span><span class="o">,</span>
<span class="w">  </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">even</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span><span class="o">],</span>
<span class="w">  </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="bp">*</span><span class="o">,</span><span class="w"> </span><span class="n">even</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span><span class="o">]</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>What makes this a mutual definition is that <code class="docutils literal notranslate"><span class="pre">even</span></code> is defined recursively in terms of <code class="docutils literal notranslate"><span class="pre">odd</span></code>, while <code class="docutils literal notranslate"><span class="pre">odd</span></code> is defined recursively in terms of <code class="docutils literal notranslate"><span class="pre">even</span></code>. Under the hood, this is compiled as a single recursive definition. The internally defined function takes, as argument, an element of a sum type, either an input to <code class="docutils literal notranslate"><span class="pre">even</span></code>, or an input to <code class="docutils literal notranslate"><span class="pre">odd</span></code>. It then returns an output appropriate to the input. To define that function, Lean uses a suitable well-founded measure. The internals are meant to be hidden from users; the canonical way to make use of such definitions is to use <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> or <code class="docutils literal notranslate"><span class="pre">simp</span></code>, as we did above.</p>
<p>Mutual recursive definitions also provide natural ways of working with mutual and nested inductive types, as described in <a class="reference internal" href="inductive_types.html#mutual-and-nested-inductive-types"><span class="std std-numref">Section 7.9</span></a>. Recall the definition of <code class="docutils literal notranslate"><span class="pre">even</span></code> and <code class="docutils literal notranslate"><span class="pre">odd</span></code> as mutual inductive predicates, as presented as an example there:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=mutual%20inductive%20even%2C%20odd%0Awith%20even%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20even_zero%20%3A%20even%200%0A%7C%20even_succ%20%3A%20%E2%88%80%20n%2C%20odd%20n%20%E2%86%92%20even%20(n%20%2B%201)%0Awith%20odd%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20odd_succ%20%3A%20%E2%88%80%20n%2C%20even%20n%20%E2%86%92%20odd%20(n%20%2B%201)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">mutual</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">even</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span>
<span class="k">with</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">even_zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="n">even_succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="k">with</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">odd_succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The constructors, <code class="docutils literal notranslate"><span class="pre">even_zero</span></code>, <code class="docutils literal notranslate"><span class="pre">even_succ</span></code>, and <code class="docutils literal notranslate"><span class="pre">odd_succ</span></code> provide positive means for showing that a number is even or odd. We need to use the fact that the inductive type is generated by these constructors to know that the zero is not odd, and that the latter two implications reverse. As usual, the constructors are kept in a namespace that is named after the type being defined, and the command <code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">even</span> <span class="pre">odd</span></code> allows us to access them move conveniently.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=mutual%20inductive%20even%2C%20odd%0Awith%20even%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20even_zero%20%3A%20even%200%0A%7C%20even_succ%20%3A%20%E2%88%80%20n%2C%20odd%20n%20%E2%86%92%20even%20(n%20%2B%201)%0Awith%20odd%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20odd_succ%20%3A%20%E2%88%80%20n%2C%20even%20n%20%E2%86%92%20odd%20(n%20%2B%201)%0A%0A--%20BEGIN%0Aopen%20even%20odd%0A%0Atheorem%20not_odd_zero%20%3A%20%C2%AC%20odd%200.%0A%0Amutual%20theorem%20even_of_odd_succ%2C%20odd_of_even_succ%0Awith%20even_of_odd_succ%20%3A%20%E2%88%80%20n%2C%20odd%20(n%20%2B%201)%20%E2%86%92%20even%20n%0A%7C%20_%20(odd_succ%20n%20h)%20%3A%3D%20h%0Awith%20odd_of_even_succ%20%3A%20%E2%88%80%20n%2C%20even%20(n%20%2B%201)%20%E2%86%92%20odd%20n%0A%7C%20_%20(even_succ%20n%20h)%20%3A%3D%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">odd</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">not_odd_zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="mi">0</span><span class="bp">.</span>

<span class="kd">mutual</span><span class="w"> </span><span class="kd">theorem</span><span class="w"> </span><span class="n">even_of_odd_succ</span><span class="o">,</span><span class="w"> </span><span class="n">odd_of_even_succ</span>
<span class="k">with</span><span class="w"> </span><span class="n">even_of_odd_succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">(</span><span class="n">odd_succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h</span>
<span class="k">with</span><span class="w"> </span><span class="n">odd_of_even_succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">(</span><span class="n">even_succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h</span>
</pre></div>
</div>
</div><p>For another example, suppose we use a nested inductive type to define a set of terms inductively, so that a term is either a constant (with a name given by a string), or the result of applying a constant to a list of constants.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20term%0A%7C%20const%20%3A%20string%20%E2%86%92%20term%0A%7C%20app%20%20%20%3A%20string%20%E2%86%92%20list%20term%20%E2%86%92%20term" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">term</span>
<span class="bp">|</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">term</span>
<span class="bp">|</span><span class="w"> </span><span class="n">app</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">term</span>
</pre></div>
</div>
</div><p>We can then use a mutual recursive definition to count the number of constants occurring in a term, as well as the number occurring in a list of terms.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20term%0A%7C%20const%20%3A%20string%20%E2%86%92%20term%0A%7C%20app%20%20%20%3A%20string%20%E2%86%92%20list%20term%20%E2%86%92%20term%0A%0A--%20BEGIN%0Aopen%20term%0A%0Amutual%20def%20num_consts%2C%20num_consts_lst%0Awith%20num_consts%20%3A%20term%20%E2%86%92%20nat%0A%7C%20(term.const%20n)%20%20%3A%3D%201%0A%7C%20(term.app%20n%20ts)%20%3A%3D%20num_consts_lst%20ts%0Awith%20num_consts_lst%20%3A%20list%20term%20%E2%86%92%20nat%0A%7C%20%5B%5D%20%20%20%20%20%20%3A%3D%200%0A%7C%20(t%3A%3Ats)%20%3A%3D%20num_consts%20t%20%2B%20num_consts_lst%20ts%0A%0Adef%20sample_term%20%3A%3D%20app%20%22f%22%20%5Bapp%20%22g%22%20%5Bconst%20%22x%22%5D%2C%20const%20%22y%22%5D%0A%0A%23eval%20num_consts%20sample_term%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">term</span>

<span class="kd">mutual</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">num_consts</span><span class="o">,</span><span class="w"> </span><span class="n">num_consts_lst</span>
<span class="k">with</span><span class="w"> </span><span class="n">num_consts</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">term.const</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">term.app</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ts</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">num_consts_lst</span><span class="w"> </span><span class="n">ts</span>
<span class="k">with</span><span class="w"> </span><span class="n">num_consts_lst</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">      </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="o">::</span><span class="n">ts</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">num_consts</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">num_consts_lst</span><span class="w"> </span><span class="n">ts</span>

<span class="kd">def</span><span class="w"> </span><span class="n">sample_term</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="s2">&quot;f&quot;</span><span class="w"> </span><span class="o">[</span><span class="n">app</span><span class="w"> </span><span class="s2">&quot;g&quot;</span><span class="w"> </span><span class="o">[</span><span class="n">const</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="o">],</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="o">]</span>

<span class="k">#eval</span><span class="w"> </span><span class="n">num_consts</span><span class="w"> </span><span class="n">sample_term</span>
</pre></div>
</div>
</div></section>
<section id="dependent-pattern-matching">
<span id="id6"></span><h2><span class="section-number">8.6. </span>Dependent Pattern Matching<a class="headerlink" href="#dependent-pattern-matching" title="Link to this heading">&#182;</a></h2>
<p>All the examples of pattern matching we considered in <a class="reference internal" href="#pattern-matching"><span class="std std-numref">Section 8.1</span></a> can easily be written using <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> and <code class="docutils literal notranslate"><span class="pre">rec_on</span></code>. However, this is often not the case with indexed inductive families such as <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">&#945;</span> <span class="pre">n</span></code>, since case splits impose constraints on the values of the indices. Without the equation compiler, we would need a lot of boilerplate code to define very simple functions such as <code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">zip</span></code>, and <code class="docutils literal notranslate"><span class="pre">unzip</span></code> using recursors. To understand the difficulty, consider what it would take to define a function <code class="docutils literal notranslate"><span class="pre">tail</span></code> which takes a vector <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">:</span> <span class="pre">vector</span> <span class="pre">&#945;</span> <span class="pre">(succ</span> <span class="pre">n)</span></code> and deletes the first element. A first thought might be to use the <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> function:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20nat%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20vector%200%0A%7C%20cons%20%20%20%3A%20%CE%A0%20%7Bn%7D%2C%20%CE%B1%20%E2%86%92%20vector%20n%20%E2%86%92%20vector%20(n%2B1)%0A%0Anamespace%20vector%0Alocal%20notation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%3A%3D%20cons%20h%20t%0A%0A%23check%20%40vector.cases_on%0A--%20%CE%A0%20%7B%CE%B1%20%3A%20Type*%7D%0A--%20%20%20%7BC%20%3A%20%CE%A0%20(a%20%3A%20%E2%84%95)%2C%20vector%20%CE%B1%20a%20%E2%86%92%20Type*%7D%0A--%20%20%20%7Ba%20%3A%20%E2%84%95%7D%0A--%20%20%20(n%20%3A%20vector%20%CE%B1%20a)%2C%0A--%20%20%20(e1%20%3A%20C%200%20nil)%0A--%20%20%20(e2%20%3A%20%CE%A0%20%7Bn%20%3A%20%E2%84%95%7D%20(a%20%3A%20%CE%B1)%20(a_1%20%3A%20vector%20%CE%B1%20n)%2C%0A--%20%20%20%20%20%20%20%20%20%20%20C%20(n%20%2B%201)%20(cons%20a%20a_1))%2C%0A--%20%20%20C%20a%20n%0A%0Aend%20vector" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span><span class="w"> </span><span class="n">u</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span>
<span class="bp">|</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="n">cons</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="o">},</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">vector</span>
<span class="kn">local</span><span class="w"> </span><span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="o">)</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">t</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">vector.cases_on</span>
<span class="c1">-- &#928; {&#945; : Type*}</span>
<span class="c1">--   {C : &#928; (a : &#8469;), vector &#945; a &#8594; Type*}</span>
<span class="c1">--   {a : &#8469;}</span>
<span class="c1">--   (n : vector &#945; a),</span>
<span class="c1">--   (e1 : C 0 nil)</span>
<span class="c1">--   (e2 : &#928; {n : &#8469;} (a : &#945;) (a_1 : vector &#945; n),</span>
<span class="c1">--           C (n + 1) (cons a a_1)),</span>
<span class="c1">--   C a n</span>

<span class="kd">end</span><span class="w"> </span><span class="n">vector</span>
</pre></div>
</div>
</div><p>But what value should we return in the <code class="docutils literal notranslate"><span class="pre">nil</span></code> case? Something funny is going on: if <code class="docutils literal notranslate"><span class="pre">v</span></code> has type <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">&#945;</span> <span class="pre">(succ</span> <span class="pre">n)</span></code>, it <em>can&#8217;t</em> be nil, but it is not clear how to tell that to <code class="docutils literal notranslate"><span class="pre">cases_on</span></code>.</p>
<p>One solution is to define an auxiliary function:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20%E2%84%95%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20vector%200%0A%7C%20cons%20%20%20%3A%20%CE%A0%20%7Bn%7D%2C%20%CE%B1%20%E2%86%92%20vector%20n%20%E2%86%92%20vector%20(n%2B1)%0A%0Anamespace%20vector%0Alocal%20notation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%3A%3D%20cons%20h%20t%0A%0A--%20BEGIN%0Adef%20tail_aux%20%7B%CE%B1%20%3A%20Type*%7D%20%7Bn%20m%20%3A%20%E2%84%95%7D%20(v%20%3A%20vector%20%CE%B1%20m)%20%3A%0A%20%20%20%20m%20%3D%20n%20%2B%201%20%E2%86%92%20vector%20%CE%B1%20n%20%3A%3D%0Avector.cases_on%20v%0A%20%20(assume%20H%20%3A%200%20%3D%20n%20%2B%201%2C%20nat.no_confusion%20H)%0A%20%20(assume%20m%20(a%20%3A%20%CE%B1)%20w%20%3A%20vector%20%CE%B1%20m%2C%0A%20%20%20%20assume%20H%20%3A%20m%20%2B%201%20%3D%20n%20%2B%201%2C%0A%20%20%20%20%20%20nat.no_confusion%20H%20(%CE%BB%20H1%20%3A%20m%20%3D%20n%2C%20eq.rec_on%20H1%20w))%0A%0Adef%20tail%20%7B%CE%B1%20%3A%20Type*%7D%20%7Bn%20%3A%20%E2%84%95%7D%20(v%20%3A%20vector%20%CE%B1%20(n%2B1))%20%3A%0A%20%20vector%20%CE%B1%20n%20%3A%3D%0Atail_aux%20v%20rfl%0A--%20END%0A%0Aend%20vector" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">tail_aux</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="n">vector.cases_on</span><span class="w"> </span><span class="n">v</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">nat.no_confusion</span><span class="w"> </span><span class="n">H</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">m</span><span class="o">,</span>
<span class="w">    </span><span class="k">assume</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span>
<span class="w">      </span><span class="n">nat.no_confusion</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">H1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">eq.rec_on</span><span class="w"> </span><span class="n">H1</span><span class="w"> </span><span class="n">w</span><span class="o">))</span>

<span class="kd">def</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="n">tail_aux</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>In the <code class="docutils literal notranslate"><span class="pre">nil</span></code> case, <code class="docutils literal notranslate"><span class="pre">m</span></code> is instantiated to <code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">no_confusion</span></code> makes use of the fact that <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">=</span> <span class="pre">succ</span> <span class="pre">n</span></code> cannot occur. Otherwise, <code class="docutils literal notranslate"><span class="pre">v</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">::</span> <span class="pre">w</span></code>, and we can simply return <code class="docutils literal notranslate"><span class="pre">w</span></code>, after casting it from a vector of length <code class="docutils literal notranslate"><span class="pre">m</span></code> to a vector of length <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>The difficulty in defining <code class="docutils literal notranslate"><span class="pre">tail</span></code> is to maintain the relationships between the indices. The hypothesis <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> in <code class="docutils literal notranslate"><span class="pre">tail_aux</span></code> is used to communicate the relationship between <code class="docutils literal notranslate"><span class="pre">n</span></code> and the index associated with the minor premise. Moreover, the <code class="docutils literal notranslate"><span class="pre">zero</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> case is unreachable, and the canonical way to discard such a case is to use <code class="docutils literal notranslate"><span class="pre">no_confusion</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tail</span></code> function is, however, easy to define using recursive equations, and the equation compiler generates all the boilerplate code automatically for us. Here are a number of similar examples:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20%E2%84%95%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20vector%200%0A%7C%20cons%20%20%20%3A%20%CE%A0%20%7Bn%7D%2C%20%CE%B1%20%E2%86%92%20vector%20n%20%E2%86%92%20vector%20(n%2B1)%0A%0Anamespace%20vector%0Alocal%20notation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%3A%3D%20cons%20h%20t%0A%0A--%20BEGIN%0Adef%20head%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%CE%A0%20%7Bn%7D%2C%20vector%20%CE%B1%20(n%2B1)%20%E2%86%92%20%CE%B1%0A%7C%20n%20(h%20%3A%3A%20t)%20%3A%3D%20h%0A%0Adef%20tail%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%20%CE%A0%20%7Bn%7D%2C%20vector%20%CE%B1%20(n%2B1)%20%E2%86%92%20vector%20%CE%B1%20n%0A%7C%20n%20(h%20%3A%3A%20t)%20%3A%3D%20t%0A%0Alemma%20eta%20%7B%CE%B1%20%3A%20Type*%7D%20%3A%0A%20%20%E2%88%80%20%7Bn%7D%20(v%20%3A%20vector%20%CE%B1%20(n%2B1))%2C%20head%20v%20%3A%3A%20tail%20v%20%3D%20v%0A%7C%20n%20(h%20%3A%3A%20t)%20%3A%3D%20rfl%0A%0Adef%20map%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%3A%20Type*%7D%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20%CE%B3)%20%3A%0A%20%20%CE%A0%20%7Bn%7D%2C%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B2%20n%20%E2%86%92%20vector%20%CE%B3%20n%0A%7C%200%20%20%20%20%20nil%20%20%20%20%20%20%20nil%20%20%20%20%20%20%20%3A%3D%20nil%0A%7C%20(n%2B1)%20(a%20%3A%3A%20va)%20(b%20%3A%3A%20vb)%20%3A%3D%20f%20a%20b%20%3A%3A%20map%20va%20vb%0A%0Adef%20zip%20%7B%CE%B1%20%CE%B2%20%3A%20Type*%7D%20%3A%0A%20%20%CE%A0%20%7Bn%7D%2C%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B2%20n%20%E2%86%92%20vector%20(%CE%B1%20%C3%97%20%CE%B2)%20n%0A%7C%200%20%20%20%20%20nil%20%20%20%20%20%20%20nil%20%20%20%20%20%20%20%3A%3D%20nil%0A%7C%20(n%2B1)%20(a%20%3A%3A%20va)%20(b%20%3A%3A%20vb)%20%3A%3D%20(a%2C%20b)%20%3A%3A%20zip%20va%20vb%0A--%20END%0A%0Aend%20vector" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="o">},</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h</span>

<span class="kd">def</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="o">},</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">t</span>

<span class="kd">lemma</span><span class="w"> </span><span class="n">eta</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">v</span>
<span class="bp">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">def</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="n">&#947;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#947;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="o">},</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#947;</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="n">nil</span><span class="w">       </span><span class="n">nil</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="n">nil</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">va</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">vb</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="n">vb</span>

<span class="kd">def</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="o">},</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="n">nil</span><span class="w">       </span><span class="n">nil</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="n">nil</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">va</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">vb</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="n">vb</span>
</pre></div>
</div>
</div><p>Note that we can omit recursive equations for &#8220;unreachable&#8221; cases such as <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">nil</span></code>. The automatically generated definitions for indexed families are far from straightforward. For example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20%E2%84%95%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20vector%200%0A%7C%20cons%20%20%20%3A%20%CE%A0%20%7Bn%7D%2C%20%CE%B1%20%E2%86%92%20vector%20n%20%E2%86%92%20vector%20(n%2B1)%0A%0Anamespace%20vector%0Alocal%20notation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%3A%3D%20cons%20h%20t%0A%0Adef%20map%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%3A%20Type*%7D%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20%CE%B3)%0A%20%20%20%20%20%20%20%20%3A%20%CE%A0%20%7Bn%20%3A%20nat%7D%2C%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B2%20n%20%E2%86%92%20vector%20%CE%B3%20n%0A%7C%200%20%20%20%20%20nil%20%20%20%20%20nil%20%20%20%20%20%3A%3D%20nil%0A%7C%20(n%2B1)%20(a%3A%3Ava)%20(b%3A%3Avb)%20%3A%3D%20f%20a%20b%20%3A%3A%20map%20va%20vb%0A%0A--%20BEGIN%0A%23print%20map%0A%23print%20map._main%0A--%20END%0A%0Aend%20vector" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#print</span><span class="w"> </span><span class="n">map</span>
<span class="k">#print</span><span class="w"> </span><span class="n">map._main</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">map</span></code> function is even more tedious to define by hand than the <code class="docutils literal notranslate"><span class="pre">tail</span></code> function. We encourage you to try it, using <code class="docutils literal notranslate"><span class="pre">rec_on</span></code>, <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> and <code class="docutils literal notranslate"><span class="pre">no_confusion</span></code>.</p>
</section>
<section id="inaccessible-terms">
<span id="id7"></span><h2><span class="section-number">8.7. </span>Inaccessible Terms<a class="headerlink" href="#inaccessible-terms" title="Link to this heading">&#182;</a></h2>
<p>Sometimes an argument in a dependent matching pattern is not essential to the definition, but nonetheless has to be included to specialize the type of the expression appropriately. Lean allows users to mark such subterms as <em>inaccessible</em> for pattern matching. These annotations are essential, for example, when a term occurring in the left-hand side is neither a variable nor a constructor application, because these are not suitable targets for pattern matching. We can view such inaccessible terms as &#8220;don&#8217;t care&#8221; components of the patterns. You can declare a subterm inaccessible by writing <code class="docutils literal notranslate"><span class="pre">.(t)</span></code>. If the inaccessible term can be inferred, you can also write <code class="docutils literal notranslate"><span class="pre">._</span></code>.</p>
<p>The following example can be found in <a class="reference internal" href="#gomm06" id="id8"><span>[GoMM06]</span></a>. We declare an inductive type that defines the property of &#8220;being in the image of <code class="docutils literal notranslate"><span class="pre">f</span></code>&#8221;. You can view an element of the type <code class="docutils literal notranslate"><span class="pre">image_of</span> <span class="pre">f</span> <span class="pre">b</span></code> as evidence that <code class="docutils literal notranslate"><span class="pre">b</span></code> is in the image of <code class="docutils literal notranslate"><span class="pre">f</span></code>, whereby the constructor <code class="docutils literal notranslate"><span class="pre">imf</span></code> is used to build such evidence. We can then define any function <code class="docutils literal notranslate"><span class="pre">f</span></code> with an &#8220;inverse&#8221; which takes anything in the image of <code class="docutils literal notranslate"><span class="pre">f</span></code> to an element that is mapped to it. The typing rules forces us to write <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> for the first argument, but this term is neither a variable nor a constructor application, and plays no role in the pattern-matching definition. To define the function <code class="docutils literal notranslate"><span class="pre">inverse</span></code> below, we <em>have to</em> mark <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> inaccessible.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Avariables%20%7B%CE%B1%20%CE%B2%20%3A%20Type%20u%7D%0A%0Ainductive%20image_of%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2)%20%3A%20%CE%B2%20%E2%86%92%20Type%20u%0A%7C%20imf%20%3A%20%CE%A0%20a%2C%20image_of%20(f%20a)%0A%0Aopen%20image_of%0A%0Adef%20inverse%20%7Bf%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%7D%20%3A%20%CE%A0%20b%2C%20image_of%20f%20b%20%E2%86%92%20%CE%B1%0A%7C%20.(f%20a)%20(imf%20a)%20%3A%3D%20a" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span><span class="w"> </span><span class="n">u</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">image_of</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span>
<span class="bp">|</span><span class="w"> </span><span class="n">imf</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">image_of</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>

<span class="kn">open</span><span class="w"> </span><span class="n">image_of</span>

<span class="kd">def</span><span class="w"> </span><span class="n">inverse</span><span class="w"> </span><span class="o">{</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">image_of</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="bp">.</span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">imf</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
</div><p>In the example above, the inaccessible annotation makes it clear that <code class="docutils literal notranslate"><span class="pre">f</span></code> is <em>not</em> a pattern matching variable.</p>
<p>Inaccessible terms can be used to clarify and control definitions that make use of dependent pattern matching. Consider the following definition of the function <code class="docutils literal notranslate"><span class="pre">vector.add,</span></code> which adds two vectors of elements of a type, assuming that type has an associated addition function:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20BEGIN%0Auniverse%20u%0A%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20%E2%84%95%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20vector%200%0A%7C%20cons%20%20%20%3A%20%CE%A0%20%7Bn%7D%2C%20%CE%B1%20%E2%86%92%20vector%20n%20%E2%86%92%20vector%20(n%2B1)%0A%0Anamespace%20vector%0Alocal%20notation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%3A%3D%20cons%20h%20t%0A%0Avariable%20%7B%CE%B1%20%3A%20Type%20u%7D%0A%0Adef%20add%20%5Bhas_add%20%CE%B1%5D%20%3A%20%CE%A0%20%7Bn%20%3A%20%E2%84%95%7D%2C%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B1%20n%0A%7C%200%20%20%20%20%20nil%20%20%20%20%20%20%20%20nil%20%20%20%20%20%20%20%20%3A%3D%20nil%0A%7C%20(n%2B1)%20(cons%20a%20v)%20(cons%20b%20w)%20%3A%3D%20cons%20(a%20%2B%20b)%20(add%20v%20w)%0A%0Aend%20vector%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span><span class="w"> </span><span class="n">u</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span>
<span class="bp">|</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="n">cons</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="o">},</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">vector</span>
<span class="kn">local</span><span class="w"> </span><span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="o">)</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">t</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span>

<span class="kd">def</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">},</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="n">nil</span><span class="w">        </span><span class="n">nil</span><span class="w">        </span><span class="o">:=</span><span class="w"> </span><span class="n">nil</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">cons</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">w</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">add</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">w</span><span class="o">)</span>

<span class="kd">end</span><span class="w"> </span><span class="n">vector</span>
</pre></div>
</div>
</div><p>The argument <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">:</span> <span class="pre">&#8469;}</span></code> has to appear after the colon, because it cannot be held fixed throughout the definition. When implementing this definition, the equation compiler starts with a case distinction as to whether the first argument is <code class="docutils literal notranslate"><span class="pre">0</span></code> or of the form <code class="docutils literal notranslate"><span class="pre">n+1</span></code>. This is followed by nested case splits on the next two arguments, and in each case the equation compiler rules out the cases are not compatible with the first pattern.</p>
<p>But, in fact, a case split is not required on the first argument; the <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> eliminator for <code class="docutils literal notranslate"><span class="pre">vector</span></code> automatically abstracts this argument and replaces it by <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> when we do a case split on the second argument. Using inaccessible terms, we can prompt the equation compiler to avoid the case split on <code class="docutils literal notranslate"><span class="pre">n</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20%E2%84%95%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20vector%200%0A%7C%20cons%20%20%20%3A%20%CE%A0%20%7Bn%7D%2C%20%CE%B1%20%E2%86%92%20vector%20n%20%E2%86%92%20vector%20(n%2B1)%0A%0Anamespace%20vector%0Alocal%20notation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%3A%3D%20cons%20h%20t%0A%0Avariable%20%7B%CE%B1%20%3A%20Type%20u%7D%0A%0A--%20BEGIN%0Adef%20add%20%5Bhas_add%20%CE%B1%5D%20%3A%20%CE%A0%20%7Bn%20%3A%20%E2%84%95%7D%2C%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B1%20n%0A%7C%20._%20nil%20%20%20%20%20%20%20%20nil%20%20%20%20%20%20%20%20%3A%3D%20nil%0A%7C%20._%20(cons%20a%20v)%20(cons%20b%20w)%20%3A%3D%20cons%20(a%20%2B%20b)%20(add%20v%20w)%0A--%20END%0A%0Aend%20vector" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">},</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="bp">.</span><span class="n">_</span><span class="w"> </span><span class="n">nil</span><span class="w">        </span><span class="n">nil</span><span class="w">        </span><span class="o">:=</span><span class="w"> </span><span class="n">nil</span>
<span class="bp">|</span><span class="w"> </span><span class="bp">.</span><span class="n">_</span><span class="w"> </span><span class="o">(</span><span class="n">cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">cons</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">w</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">add</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">w</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Marking the position as an inaccessible implicit argument tells the equation compiler first, that the form of the argument should be inferred from the constraints posed by the other arguments, and, second, that the first argument should <em>not</em> participate in pattern matching.</p>
<p>Using explicit inaccessible terms makes it even clearer what is going on.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20%E2%84%95%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20vector%200%0A%7C%20cons%20%20%20%3A%20%CE%A0%20%7Bn%7D%2C%20%CE%B1%20%E2%86%92%20vector%20n%20%E2%86%92%20vector%20(n%2B1)%0A%0Anamespace%20vector%0Alocal%20notation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%3A%3D%20cons%20h%20t%0A%0Avariable%20%7B%CE%B1%20%3A%20Type%20u%7D%0A%0A--%20BEGIN%0Adef%20add%20%5Bhas_add%20%CE%B1%5D%20%3A%20%CE%A0%20%7Bn%20%3A%20%E2%84%95%7D%2C%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B1%20n%20%E2%86%92%20vector%20%CE%B1%20n%0A%7C%20.(0)%20%20%20nil%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20nil%20%20%20%20%20%20%20%20%3A%3D%20nil%0A%7C%20.(n%2B1)%20(%40cons%20.(%CE%B1)%20n%20a%20v)%20(cons%20b%20w)%20%3A%3D%20cons%20(a%20%2B%20b)%20(add%20v%20w)%0A--%20END%0A%0Aend%20vector" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">[</span><span class="n">has_add</span><span class="w"> </span><span class="n">&#945;</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">},</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="bp">.</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span><span class="w">   </span><span class="n">nil</span><span class="w">                </span><span class="n">nil</span><span class="w">        </span><span class="o">:=</span><span class="w"> </span><span class="n">nil</span>
<span class="bp">|</span><span class="w"> </span><span class="bp">.</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">cons</span><span class="w"> </span><span class="bp">.</span><span class="o">(</span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">cons</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">w</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">add</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">w</span><span class="o">)</span>
</pre></div>
</div>
</div><p>We have to introduce the variable <code class="docutils literal notranslate"><span class="pre">n</span></code> in the pattern <code class="docutils literal notranslate"><span class="pre">&#64;cons</span> <span class="pre">.(&#945;)</span> <span class="pre">n</span> <span class="pre">a</span> <span class="pre">v</span></code>, since it is involved in the pattern match over that argument. In contrast, the parameter <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is held fixed; we could have left it implicit by writing <code class="docutils literal notranslate"><span class="pre">._</span></code> instead. The advantage to naming the variable there is that we can now use inaccessible terms in the first position to display the values that were inferred implicitly in the previous example.</p>
</section>
<section id="match-expressions">
<span id="id9"></span><h2><span class="section-number">8.8. </span>Match Expressions<a class="headerlink" href="#match-expressions" title="Link to this heading">&#182;</a></h2>
<p>Lean also provides a compiler for <em>match-with</em> expressions found in many functional languages. It uses essentially the same infrastructure used to compile recursive equations.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20is_not_zero%20(m%20%3A%20%E2%84%95)%20%3A%20bool%20%3A%3D%0Amatch%20m%20with%0A%7C%200%20%20%20%20%20%3A%3D%20ff%0A%7C%20(n%2B1)%20%3A%3D%20tt%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">is_not_zero</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="o">:=</span>
<span class="k">match</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="k">with</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="n">ff</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tt</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This does not look very different from an ordinary pattern matching definition, but the point is that a <code class="docutils literal notranslate"><span class="pre">match</span></code> can be used anywhere in an expression, and with arbitrary arguments.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20is_not_zero%20(m%20%3A%20%E2%84%95)%20%3A%20bool%20%3A%3D%0Amatch%20m%20with%0A%7C%200%20%20%20%20%20%3A%3D%20ff%0A%7C%20(n%2B1)%20%3A%3D%20tt%0Aend%0A%0A--%20BEGIN%0Avariable%20%7B%CE%B1%20%3A%20Type*%7D%0Avariable%20p%20%3A%20%CE%B1%20%E2%86%92%20bool%0A%0Adef%20filter%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%20%20%3A%3D%20%5B%5D%0A%7C%20(a%20%3A%3A%20l)%20%3A%3D%0A%20%20match%20p%20a%20with%0A%20%20%7C%20%20tt%20%3A%3D%20a%20%3A%3A%20filter%20l%0A%20%20%7C%20%20ff%20%3A%3D%20filter%20l%0A%20%20end%0A%0Aexample%20%3A%20filter%20is_not_zero%20%5B1%2C%200%2C%200%2C%203%2C%200%5D%20%3D%20%5B1%2C%203%5D%20%3A%3D%20rfl%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">bool</span>

<span class="kd">def</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">[]</span><span class="w">       </span><span class="o">:=</span><span class="w"> </span><span class="o">[]</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">l</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">with</span>
<span class="w">  </span><span class="bp">|</span><span class="w">  </span><span class="n">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="n">l</span>
<span class="w">  </span><span class="bp">|</span><span class="w">  </span><span class="n">ff</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="n">l</span>
<span class="w">  </span><span class="kd">end</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="n">is_not_zero</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>Here is another example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo%20(n%20%3A%20%E2%84%95)%20(b%20c%20%3A%20bool)%20%3A%3D%0A5%20%2B%20match%20n%20-%205%2C%20b%20%26%26%20c%20with%0A%20%20%20%20%7C%200%2C%20%20%20%20%20%20tt%20%3A%3D%200%0A%20%20%20%20%7C%20m%2B1%2C%20%20%20%20tt%20%3A%3D%20m%20%2B%207%0A%20%20%20%20%7C%200%2C%20%20%20%20%20%20ff%20%3A%3D%205%0A%20%20%20%20%7C%20m%2B1%2C%20%20%20%20ff%20%3A%3D%20m%20%2B%203%0A%20%20%20%20end%0A%0A%23eval%20foo%207%20tt%20ff%0A%0Aexample%20%3A%20foo%207%20tt%20ff%20%3D%209%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="mi">5</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w">      </span><span class="n">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="bp">|</span><span class="w"> </span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span><span class="w">    </span><span class="n">tt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">7</span>
<span class="w">    </span><span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w">      </span><span class="n">ff</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">5</span>
<span class="w">    </span><span class="bp">|</span><span class="w"> </span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span><span class="w">    </span><span class="n">ff</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="kd">end</span>

<span class="k">#eval</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="n">ff</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>Notice that with multiple arguments, the syntax for the match statement is markedly different from that used for pattern matching in an ordinary recursive definition. Because arbitrary terms are allowed in the <code class="docutils literal notranslate"><span class="pre">match</span></code>, parentheses are not enough to set the arguments apart; if we wrote <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">-</span> <span class="pre">5)</span> <span class="pre">(b</span> <span class="pre">&amp;&amp;</span> <span class="pre">c)</span></code>, it would be interpreted as the result of applying <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">5</span></code> to <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">&amp;&amp;</span> <span class="pre">c</span></code>. Instead, the arguments are separated by commas. Then, for consistency, the patterns on each line are separated by commas as well.</p>
<p>Lean uses the <code class="docutils literal notranslate"><span class="pre">match</span></code> construct internally to implement a pattern-matching <code class="docutils literal notranslate"><span class="pre">assume</span></code>, as well as a pattern-matching <code class="docutils literal notranslate"><span class="pre">let</span></code>. Thus, all four of these definitions have the same net effect.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20bar%E2%82%81%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20(m%2C%20n)%20%3A%3D%20m%20%2B%20n%0A%0Adef%20bar%E2%82%82%20(p%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Amatch%20p%20with%20(m%2C%20n)%20%3A%3D%20m%20%2B%20n%20end%0A%0Adef%20bar%E2%82%83%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%3A%3D%0A%CE%BB%20%E2%9F%A8m%2C%20n%E2%9F%A9%2C%20m%20%2B%20n%0A%0Adef%20bar%E2%82%84%20(p%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Alet%20%E2%9F%A8m%2C%20n%E2%9F%A9%20%3A%3D%20p%20in%20m%20%2B%20n" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">bar&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span>

<span class="kd">def</span><span class="w"> </span><span class="n">bar&#8322;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="k">match</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kd">end</span>

<span class="kd">def</span><span class="w"> </span><span class="n">bar&#8323;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">m</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="o">&#10217;,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span>

<span class="kd">def</span><span class="w"> </span><span class="n">bar&#8324;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="k">let</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">m</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span>
</pre></div>
</div>
</div><p>The second definition also illustrates the fact that in a match with a single pattern, the vertical bar is optional. These variations are equally useful for destructing propositions:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%0Aexample%20%3A%20(%E2%88%83%20x%2C%20p%20x)%20%E2%86%92%20(%E2%88%83%20y%2C%20q%20y)%20%E2%86%92%0A%20%20%E2%88%83%20x%20y%2C%20p%20x%20%E2%88%A7%20q%20y%0A%7C%20%E2%9F%A8x%2C%20px%E2%9F%A9%20%E2%9F%A8y%2C%20qy%E2%9F%A9%20%3A%3D%20%E2%9F%A8x%2C%20y%2C%20px%2C%20qy%E2%9F%A9%0A%0Aexample%20(h%E2%82%80%20%3A%20%E2%88%83%20x%2C%20p%20x)%20(h%E2%82%81%20%3A%20%E2%88%83%20y%2C%20q%20y)%20%3A%0A%20%20%E2%88%83%20x%20y%2C%20p%20x%20%E2%88%A7%20q%20y%20%3A%3D%0Amatch%20h%E2%82%80%2C%20h%E2%82%81%20with%0A%E2%9F%A8x%2C%20px%E2%9F%A9%2C%20%E2%9F%A8y%2C%20qy%E2%9F%A9%20%3A%3D%20%E2%9F%A8x%2C%20y%2C%20px%2C%20qy%E2%9F%A9%0Aend%0A%0Aexample%20%3A%20(%E2%88%83%20x%2C%20p%20x)%20%E2%86%92%20(%E2%88%83%20y%2C%20q%20y)%20%E2%86%92%0A%20%20%E2%88%83%20x%20y%2C%20p%20x%20%E2%88%A7%20q%20y%20%3A%3D%0A%CE%BB%20%E2%9F%A8x%2C%20px%E2%9F%A9%20%E2%9F%A8y%2C%20qy%E2%9F%A9%2C%20%E2%9F%A8x%2C%20y%2C%20px%2C%20qy%E2%9F%A9%0A%0Aexample%20(h%E2%82%80%20%3A%20%E2%88%83%20x%2C%20p%20x)%20(h%E2%82%81%20%3A%20%E2%88%83%20y%2C%20q%20y)%20%3A%0A%20%20%E2%88%83%20x%20y%2C%20p%20x%20%E2%88%A7%20q%20y%20%3A%3D%0Alet%20%E2%9F%A8x%2C%20px%E2%9F%A9%20%3A%3D%20h%E2%82%80%2C%0A%20%20%20%20%E2%9F%A8y%2C%20qy%E2%9F%A9%20%3A%3D%20h%E2%82%81%20in%0A%E2%9F%A8x%2C%20y%2C%20px%2C%20qy%E2%9F%A9" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span>
<span class="w">  </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span>
<span class="bp">|</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8320;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span>
<span class="k">match</span><span class="w"> </span><span class="n">h&#8320;</span><span class="o">,</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="k">with</span>
<span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">&#10217;,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;</span>
<span class="kd">end</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span>
<span class="w">  </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8320;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span>
<span class="k">let</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h&#8320;</span><span class="o">,</span>
<span class="w">    </span><span class="o">&#10216;</span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="k">in</span>
<span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">px</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div></section>
<section id="exercises">
<h2><span class="section-number">8.9. </span>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">&#182;</a></h2>
<ol class="arabic">
<li><p>Use pattern matching to prove that the composition of surjective functions is surjective:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20function%0A%0A%23print%20surjective%0A%0Auniverses%20u%20v%20w%0Avariables%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7B%CE%B2%20%3A%20Type%20v%7D%20%7B%CE%B3%20%3A%20Type%20w%7D%0Aopen%20function%0A%0Alemma%20surjective_comp%20%7Bg%20%3A%20%CE%B2%20%E2%86%92%20%CE%B3%7D%20%7Bf%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%7D%0A%20%20(hg%20%3A%20surjective%20g)%20(hf%20%3A%20surjective%20f)%20%3A%0Asurjective%20(g%20%E2%88%98%20f)%20%3A%3D%20sorry" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">function</span>

<span class="k">#print</span><span class="w"> </span><span class="n">surjective</span>

<span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">w</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#947;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">w</span><span class="o">}</span>
<span class="kn">open</span><span class="w"> </span><span class="n">function</span>

<span class="kd">lemma</span><span class="w"> </span><span class="n">surjective_comp</span><span class="w"> </span><span class="o">{</span><span class="n">g</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#947;</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">}</span>
<span class="w">  </span><span class="o">(</span><span class="n">hg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">surjective</span><span class="w"> </span><span class="n">g</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hf</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">surjective</span><span class="w"> </span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="n">surjective</span><span class="w"> </span><span class="o">(</span><span class="n">g</span><span class="w"> </span><span class="bp">&#8728;</span><span class="w"> </span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
</pre></div>
</div>
</div></li>
<li><p>Open a namespace <code class="docutils literal notranslate"><span class="pre">hidden</span></code> to avoid naming conflicts, and use the equation compiler to define addition, multiplication, and exponentiation on the natural numbers. Then use the equation compiler to derive some of their basic properties.</p></li>
<li><p>Similarly, use the equation compiler to define some basic operations on lists (like the <code class="docutils literal notranslate"><span class="pre">reverse</span></code> function) and prove theorems about lists by induction (such as the fact that <code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">(reverse</span> <span class="pre">l)</span> <span class="pre">=</span> <span class="pre">l</span></code> for any list <code class="docutils literal notranslate"><span class="pre">l</span></code>).</p></li>
<li><p>Define your own function to carry out course-of-value recursion on the natural numbers. Similarly, see if you can figure out how to define <code class="docutils literal notranslate"><span class="pre">well_founded.fix</span></code> on your own.</p></li>
<li><p>Following the examples in <a class="reference internal" href="#dependent-pattern-matching"><span class="std std-numref">Section 8.6</span></a>, define a function that will append two vectors. This is tricky; you will have to define an auxiliary function.</p></li>
<li><p>Consider the following type of arithmetic expressions. The idea is that <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">n</span></code> is a variable, <code class="docutils literal notranslate"><span class="pre">v&#8345;</span></code>, and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">n</span></code> is the constant whose value is <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20aexpr%20%3A%20Type%0A%7C%20const%20%3A%20%E2%84%95%20%E2%86%92%20aexpr%0A%7C%20var%20%3A%20%E2%84%95%20%E2%86%92%20aexpr%0A%7C%20plus%20%3A%20aexpr%20%E2%86%92%20aexpr%20%E2%86%92%20aexpr%0A%7C%20times%20%3A%20aexpr%20%E2%86%92%20aexpr%20%E2%86%92%20aexpr%0A%0Aopen%20aexpr%0A%0Adef%20sample_aexpr%20%3A%20aexpr%20%3A%3D%0Aplus%20(times%20(var%200)%20(const%207))%20(times%20(const%202)%20(var%201))" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span>
<span class="bp">|</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span>
<span class="bp">|</span><span class="w"> </span><span class="n">plus</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span>
<span class="bp">|</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span>

<span class="kn">open</span><span class="w"> </span><span class="n">aexpr</span>

<span class="kd">def</span><span class="w"> </span><span class="n">sample_aexpr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="o">:=</span>
<span class="n">plus</span><span class="w"> </span><span class="o">(</span><span class="n">times</span><span class="w"> </span><span class="o">(</span><span class="n">var</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">const</span><span class="w"> </span><span class="mi">7</span><span class="o">))</span><span class="w"> </span><span class="o">(</span><span class="n">times</span><span class="w"> </span><span class="o">(</span><span class="n">const</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">var</span><span class="w"> </span><span class="mi">1</span><span class="o">))</span>
</pre></div>
</div>
</div><p>Here <code class="docutils literal notranslate"><span class="pre">sample_aexpr</span></code> represents <code class="docutils literal notranslate"><span class="pre">(v&#8320;</span> <span class="pre">+</span> <span class="pre">7)</span> <span class="pre">*</span> <span class="pre">(2</span> <span class="pre">+</span> <span class="pre">v&#8321;)</span></code>.</p>
<p>Write a function that evaluates such an expression, evaluating each <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">n</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">n</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20aexpr%20%3A%20Type%0A%7C%20const%20%3A%20%E2%84%95%20%E2%86%92%20aexpr%0A%7C%20var%20%3A%20%E2%84%95%20%E2%86%92%20aexpr%0A%7C%20plus%20%3A%20aexpr%20%E2%86%92%20aexpr%20%E2%86%92%20aexpr%0A%7C%20times%20%3A%20aexpr%20%E2%86%92%20aexpr%20%E2%86%92%20aexpr%0A%0Aopen%20aexpr%0A%0Adef%20sample_aexpr%20%3A%20aexpr%20%3A%3D%0Aplus%20(times%20(var%200)%20(const%207))%20(times%20(const%202)%20(var%201))%0A%0A--%20BEGIN%0Adef%20aeval%20(v%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95)%20%3A%20aexpr%20%E2%86%92%20%E2%84%95%0A%7C%20(const%20n)%20%20%20%20%3A%3D%20sorry%0A%7C%20(var%20n)%20%20%20%20%20%20%3A%3D%20v%20n%0A%7C%20(plus%20e%E2%82%81%20e%E2%82%82)%20%20%3A%3D%20sorry%0A%7C%20(times%20e%E2%82%81%20e%E2%82%82)%20%3A%3D%20sorry%0A%0Adef%20sample_val%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%3A%3D%205%0A%7C%201%20%3A%3D%206%0A%7C%20_%20%3A%3D%200%0A%0A--%20Try%20it%20out.%20You%20should%20get%2047%20here.%0A--%20%23eval%20aeval%20sample_val%20sample_aexpr%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">aeval</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">const</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w">    </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">var</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w">      </span><span class="o">:=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">n</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">plus</span><span class="w"> </span><span class="n">e&#8321;</span><span class="w"> </span><span class="n">e&#8322;</span><span class="o">)</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">times</span><span class="w"> </span><span class="n">e&#8321;</span><span class="w"> </span><span class="n">e&#8322;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="kd">def</span><span class="w"> </span><span class="n">sample_val</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">5</span>
<span class="bp">|</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">6</span>
<span class="bp">|</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>

<span class="c1">-- Try it out. You should get 47 here.</span>
<span class="c1">-- #eval aeval sample_val sample_aexpr</span>
</pre></div>
</div>
</div><p>Implement &#8220;constant fusion,&#8221; a procedure that simplifies subterms like <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">+</span> <span class="pre">7</span></code> to <code class="docutils literal notranslate"><span class="pre">12</span></code>. Using the auxiliary function <code class="docutils literal notranslate"><span class="pre">simp_const</span></code>, define a function &#8220;fuse&#8221;: to simplify a plus or a times, first simplify the arguments recursively, and then apply <code class="docutils literal notranslate"><span class="pre">simp_const</span></code> to try to simplify the result.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20aexpr%20%3A%20Type%0A%7C%20const%20%3A%20%E2%84%95%20%E2%86%92%20aexpr%0A%7C%20var%20%3A%20%E2%84%95%20%E2%86%92%20aexpr%0A%7C%20plus%20%3A%20aexpr%20%E2%86%92%20aexpr%20%E2%86%92%20aexpr%0A%7C%20times%20%3A%20aexpr%20%E2%86%92%20aexpr%20%E2%86%92%20aexpr%0A%0Aopen%20aexpr%0A%0Adef%20aeval%20(v%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95)%20%3A%20aexpr%20%E2%86%92%20%E2%84%95%0A%7C%20(const%20n)%20%20%20%20%3A%3D%20sorry%0A%7C%20(var%20n)%20%20%20%20%20%20%3A%3D%20v%20n%0A%7C%20(plus%20e%E2%82%81%20e%E2%82%82)%20%20%3A%3D%20sorry%0A%7C%20(times%20e%E2%82%81%20e%E2%82%82)%20%3A%3D%20sorry%0A%0A--%20BEGIN%0Adef%20simp_const%20%3A%20aexpr%20%E2%86%92%20aexpr%0A%7C%20(plus%20(const%20n%E2%82%81)%20(const%20n%E2%82%82))%20%20%3A%3D%20const%20(n%E2%82%81%20%2B%20n%E2%82%82)%0A%7C%20(times%20(const%20n%E2%82%81)%20(const%20n%E2%82%82))%20%3A%3D%20const%20(n%E2%82%81%20*%20n%E2%82%82)%0A%7C%20e%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%3D%20e%0A%0Adef%20fuse%20%3A%20aexpr%20%E2%86%92%20aexpr%20%3A%3D%20sorry%0A%0Atheorem%20simp_const_eq%20(v%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95)%20%3A%0A%20%20%E2%88%80%20e%20%3A%20aexpr%2C%20aeval%20v%20(simp_const%20e)%20%3D%20aeval%20v%20e%20%3A%3D%0Asorry%0A%0Atheorem%20fuse_eq%20(v%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95)%20%3A%0A%20%20%E2%88%80%20e%20%3A%20aexpr%2C%20aeval%20v%20(fuse%20e)%20%3D%20aeval%20v%20e%20%3A%3D%0Asorry%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">simp_const</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">plus</span><span class="w"> </span><span class="o">(</span><span class="n">const</span><span class="w"> </span><span class="n">n&#8321;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">const</span><span class="w"> </span><span class="n">n&#8322;</span><span class="o">))</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="o">(</span><span class="n">n&#8321;</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n&#8322;</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="o">(</span><span class="n">times</span><span class="w"> </span><span class="o">(</span><span class="n">const</span><span class="w"> </span><span class="n">n&#8321;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">const</span><span class="w"> </span><span class="n">n&#8322;</span><span class="o">))</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="o">(</span><span class="n">n&#8321;</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">n&#8322;</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">e</span><span class="w">                             </span><span class="o">:=</span><span class="w"> </span><span class="n">e</span>

<span class="kd">def</span><span class="w"> </span><span class="n">fuse</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">aexpr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">simp_const_eq</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="o">,</span><span class="w"> </span><span class="n">aeval</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">(</span><span class="n">simp_const</span><span class="w"> </span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">aeval</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">fuse_eq</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">aexpr</span><span class="o">,</span><span class="w"> </span><span class="n">aeval</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">(</span><span class="n">fuse</span><span class="w"> </span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">aeval</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
</div><p>The last two theorems show that the definitions preserve the value.</p>
</li>
</ol>
<div role="list" class="citation-list">
<div class="citation" id="gomm06" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">GoMM06</a><span class="fn-bracket">]</span></span>
<p>Healfdene Goguen, Conor McBride, and James McKinna. Eliminating dependent pattern matching. In Kokichi Futatsugi, Jean-Pierre Jouannaud, and Jos&#233; Meseguer, editors, Algebra, Meaning, and Computation, Essays Dedicated to Joseph A. Goguen on the Occasion of His 65th Birthday, volume 4060 of Lecture Notes in Computer Science, pages 521&#8211;540. Springer, 2006.</p>
</div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean 3 (outdated)</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositions_and_proofs.html">3. Propositions and Proofs</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Induction and Recursion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pattern-matching">8.1. Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wildcards-and-overlapping-patterns">8.2. Wildcards and Overlapping Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structural-recursion-and-induction">8.3. Structural Recursion and Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#well-founded-recursion-and-induction">8.4. Well-Founded Recursion and Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mutual-recursion">8.5. Mutual Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dependent-pattern-matching">8.6. Dependent Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inaccessible-terms">8.7. Inaccessible Terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#match-expressions">8.8. Match Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">8.9. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/induction_and_recursion.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>