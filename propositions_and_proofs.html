<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>3. Propositions and Proofs &#8212; Theorem Proving in Lean 3 (outdated) 3.23.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=5ca61e87" />
    <script src="_static/documentation_options.js?v=5de50469"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Quantifiers and Equality" href="quantifiers_and_equality.html" />
    <link rel="prev" title="2. Dependent Type Theory" href="dependent_type_theory.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="propositions-and-proofs">
<span id="id1"></span><h1><span class="section-number">3. </span>Propositions and Proofs<a class="headerlink" href="#propositions-and-proofs" title="Link to this heading">&#182;</a></h1>
<p>By now, you have seen some ways of defining objects and functions in Lean. In this chapter, we will begin to explain how to write mathematical assertions and proofs in the language of dependent type theory as well.</p>
<section id="propositions-as-types">
<h2><span class="section-number">3.1. </span>Propositions as Types<a class="headerlink" href="#propositions-as-types" title="Link to this heading">&#182;</a></h2>
<p>One strategy for proving assertions about objects defined in the language of dependent type theory is to layer an assertion language and a proof language on top of the definition language. But there is no reason to multiply languages in this way: dependent type theory is flexible and expressive, and there is no reason we cannot represent assertions and proofs in the same general framework.</p>
<p>For example, we could introduce a new type, <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, to represent propositions, and introduce constructors to build new propositions from others.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aconstant%20and%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20or%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20not%20%3A%20Prop%20%E2%86%92%20Prop%0Aconstant%20implies%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0A%0Avariables%20p%20q%20r%20%3A%20Prop%0A%23check%20and%20p%20q%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Prop%0A%23check%20or%20(and%20p%20q)%20r%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Prop%0A%23check%20implies%20(and%20p%20q)%20(and%20q%20p)%20%20--%20Prop%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">constant</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">constant</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">constant</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">constant</span><span class="w"> </span><span class="n">implies</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="k">#check</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w">                      </span><span class="c1">-- Prop</span>
<span class="k">#check</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="o">(</span><span class="n">and</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="n">r</span><span class="w">               </span><span class="c1">-- Prop</span>
<span class="k">#check</span><span class="w"> </span><span class="n">implies</span><span class="w"> </span><span class="o">(</span><span class="n">and</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">and</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w">  </span><span class="c1">-- Prop</span>
</pre></div>
</div>
</div><p>We could then introduce, for each element <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, another type <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">p</span></code>, for the type of proofs of <code class="docutils literal notranslate"><span class="pre">p</span></code>. An &#8220;axiom&#8221; would be a constant of such a type.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Aconstant%20and%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20or%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20not%20%3A%20Prop%20%E2%86%92%20Prop%0Aconstant%20implies%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0A%0A--%20BEGIN%0Aconstant%20Proof%20%3A%20Prop%20%E2%86%92%20Type%0A%0Aconstant%20and_comm%20%3A%20%CE%A0%20p%20q%20%3A%20Prop%2C%0A%20%20Proof%20(implies%20(and%20p%20q)%20(and%20q%20p))%0A%0Avariables%20p%20q%20%3A%20Prop%0A%23check%20and_comm%20p%20q%20%20%20%20%20%20--%20Proof%20(implies%20(and%20p%20q)%20(and%20q%20p))%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">constant</span><span class="w"> </span><span class="n">Proof</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Type</span>

<span class="kd">constant</span><span class="w"> </span><span class="n">and_comm</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">,</span>
<span class="w">  </span><span class="n">Proof</span><span class="w"> </span><span class="o">(</span><span class="n">implies</span><span class="w"> </span><span class="o">(</span><span class="n">and</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">and</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">p</span><span class="o">))</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="k">#check</span><span class="w"> </span><span class="n">and_comm</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w">      </span><span class="c1">-- Proof (implies (and p q) (and q p))</span>
</pre></div>
</div>
</div><p>In addition to axioms, however, we would also need rules to build new proofs from old ones. For example, in many proof systems for propositional logic, we have the rule of modus ponens:</p>
<blockquote>
<div><p>From a proof of <code class="docutils literal notranslate"><span class="pre">implies</span> <span class="pre">p</span> <span class="pre">q</span></code> and a proof of <code class="docutils literal notranslate"><span class="pre">p</span></code>, we obtain a proof of <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
</div></blockquote>
<p>We could represent this as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Aconstant%20implies%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20Proof%20%3A%20Prop%20%E2%86%92%20Type%0A%0A--%20BEGIN%0Aconstant%20modus_ponens%20%3A%0A%20%20%CE%A0%20p%20q%20%3A%20Prop%2C%20Proof%20(implies%20p%20q)%20%E2%86%92%20%20Proof%20p%20%E2%86%92%20Proof%20q%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">constant</span><span class="w"> </span><span class="n">modus_ponens</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">,</span><span class="w"> </span><span class="n">Proof</span><span class="w"> </span><span class="o">(</span><span class="n">implies</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w">  </span><span class="n">Proof</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">Proof</span><span class="w"> </span><span class="n">q</span>
</pre></div>
</div>
</div><p>Systems of natural deduction for propositional logic also typically rely on the following rule:</p>
<blockquote>
<div><p>Suppose that, assuming <code class="docutils literal notranslate"><span class="pre">p</span></code> as a hypothesis, we have a proof of <code class="docutils literal notranslate"><span class="pre">q</span></code>. Then we can &#8220;cancel&#8221; the hypothesis and obtain a proof of <code class="docutils literal notranslate"><span class="pre">implies</span> <span class="pre">p</span> <span class="pre">q</span></code>.</p>
</div></blockquote>
<p>We could render this as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Aconstant%20implies%20%3A%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20Proof%20%3A%20Prop%20%E2%86%92%20Type%0A%0A--%20BEGIN%0Aconstant%20implies_intro%20%3A%0A%20%20%CE%A0%20p%20q%20%3A%20Prop%2C%20(Proof%20p%20%E2%86%92%20Proof%20q)%20%E2%86%92%20Proof%20(implies%20p%20q).%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">constant</span><span class="w"> </span><span class="n">implies_intro</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="n">Proof</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">Proof</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">Proof</span><span class="w"> </span><span class="o">(</span><span class="n">implies</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="bp">.</span>
</pre></div>
</div>
</div><p>This approach would provide us with a reasonable way of building assertions and proofs. Determining that an expression <code class="docutils literal notranslate"><span class="pre">t</span></code> is a correct proof of assertion <code class="docutils literal notranslate"><span class="pre">p</span></code> would then simply be a matter of checking that <code class="docutils literal notranslate"><span class="pre">t</span></code> has type <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">p</span></code>.</p>
<p>Some simplifications are possible, however. To start with, we can avoid writing the term <code class="docutils literal notranslate"><span class="pre">Proof</span></code> repeatedly by conflating <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">p</span></code> with <code class="docutils literal notranslate"><span class="pre">p</span></code> itself. In other words, whenever we have <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, we can interpret <code class="docutils literal notranslate"><span class="pre">p</span></code> as a type, namely, the type of its proofs. We can then read <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> as the assertion that <code class="docutils literal notranslate"><span class="pre">t</span></code> is a proof of <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>Moreover, once we make this identification, the rules for implication show that we can pass back and forth between <code class="docutils literal notranslate"><span class="pre">implies</span> <span class="pre">p</span> <span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code>. In other words, implication between propositions <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> corresponds to having a function that takes any element of <code class="docutils literal notranslate"><span class="pre">p</span></code> to an element of <code class="docutils literal notranslate"><span class="pre">q</span></code>. As a result, the introduction of the connective <code class="docutils literal notranslate"><span class="pre">implies</span></code> is entirely redundant: we can use the usual function space constructor <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> from dependent type theory as our notion of implication.</p>
<p>This is the approach followed in the Calculus of Constructions, and hence in Lean as well. The fact that the rules for implication in a proof system for natural deduction correspond exactly to the rules governing abstraction and application for functions is an instance of the <em>Curry-Howard isomorphism</em>, sometimes known as the <em>propositions-as-types</em> paradigm. In fact, the type <code class="docutils literal notranslate"><span class="pre">Prop</span></code> is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">0</span></code>, the very bottom of the type hierarchy described in the last chapter. Moreover, <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u</span></code> is also just syntactic sugar for <code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">(u+1)</span></code>. <code class="docutils literal notranslate"><span class="pre">Prop</span></code> has some special features, but like the other type universes, it is closed under the arrow constructor: if we have <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, then <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>.</p>
<p>There are at least two ways of thinking about propositions as types. To some who take a constructive view of logic and mathematics, this is a faithful rendering of what it means to be a proposition: a proposition <code class="docutils literal notranslate"><span class="pre">p</span></code> represents a sort of data type, namely, a specification of the type of data that constitutes a proof. A proof of <code class="docutils literal notranslate"><span class="pre">p</span></code> is then simply an object <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> of the right type.</p>
<p>Those not inclined to this ideology can view it, rather, as a simple coding trick. To each proposition <code class="docutils literal notranslate"><span class="pre">p</span></code> we associate a type that is empty if <code class="docutils literal notranslate"><span class="pre">p</span></code> is false and has a single element, say <code class="docutils literal notranslate"><span class="pre">*</span></code>, if <code class="docutils literal notranslate"><span class="pre">p</span></code> is true. In the latter case, let us say that (the type associated with) <code class="docutils literal notranslate"><span class="pre">p</span></code> is <em>inhabited</em>. It just so happens that the rules for function application and abstraction can conveniently help us keep track of which elements of <code class="docutils literal notranslate"><span class="pre">Prop</span></code> are inhabited. So constructing an element <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> tells us that <code class="docutils literal notranslate"><span class="pre">p</span></code> is indeed true. You can think of the inhabitant of <code class="docutils literal notranslate"><span class="pre">p</span></code> as being the &#8220;fact that <code class="docutils literal notranslate"><span class="pre">p</span></code> is true.&#8221; A proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> uses &#8220;the fact that <code class="docutils literal notranslate"><span class="pre">p</span></code> is true&#8221; to obtain &#8220;the fact that <code class="docutils literal notranslate"><span class="pre">q</span></code> is true.&#8221;</p>
<p>Indeed, if <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code> is any proposition, Lean&#8217;s kernel treats any two elements <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">t2</span> <span class="pre">:</span> <span class="pre">p</span></code> as being definitionally equal, much the same way as it treats <code class="docutils literal notranslate"><span class="pre">(&#955;</span> <span class="pre">x,</span> <span class="pre">t)s</span></code> and <code class="docutils literal notranslate"><span class="pre">t[s/x]</span></code> as definitionally equal. This is known as <em>proof irrelevance,</em> and is consistent with the interpretation in the last paragraph. It means that even though we can treat proofs <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> as ordinary objects in the language of dependent type theory, they carry no information beyond the fact that <code class="docutils literal notranslate"><span class="pre">p</span></code> is true.</p>
<p>The two ways we have suggested thinking about the propositions-as-types paradigm differ in a fundamental way. From the constructive point of view, proofs are abstract mathematical objects that are <em>denoted</em> by suitable expressions in dependent type theory. In contrast, if we think in terms of the coding trick described above, then the expressions themselves do not denote anything interesting. Rather, it is the fact that we can write them down and check that they are well-typed that ensures that the proposition in question is true. In other words, the expressions <em>themselves</em> are the proofs.</p>
<p>In the exposition below, we will slip back and forth between these two ways of talking, at times saying that an expression &#8220;constructs&#8221; or &#8220;produces&#8221; or &#8220;returns&#8221; a proof of a proposition, and at other times simply saying that it &#8220;is&#8221; such a proof. This is similar to the way that computer scientists occasionally blur the distinction between syntax and semantics by saying, at times, that a program &#8220;computes&#8221; a certain function, and at other times speaking as though the program &#8220;is&#8221; the function in question.</p>
<p>In any case, all that really matters is the bottom line. To formally express a mathematical assertion in the language of dependent type theory, we need to exhibit a term <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>. To <em>prove</em> that assertion, we need to exhibit a term <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code>. Lean&#8217;s task, as a proof assistant, is to help us to construct such a term, <code class="docutils literal notranslate"><span class="pre">t</span></code>, and to verify that it is well-formed and has the correct type.</p>
</section>
<section id="working-with-propositions-as-types">
<h2><span class="section-number">3.2. </span>Working with Propositions as Types<a class="headerlink" href="#working-with-propositions-as-types" title="Link to this heading">&#182;</a></h2>
<p>In the propositions-as-types paradigm, theorems involving only <code class="docutils literal notranslate"><span class="pre">&#8594;</span></code> can be proved using lambda abstraction and application. In Lean, the <code class="docutils literal notranslate"><span class="pre">theorem</span></code> command introduces a new theorem:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=constants%20p%20q%20%3A%20Prop%0A%0Atheorem%20t1%20%3A%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%3A%3D%20%CE%BB%20hp%20%3A%20p%2C%20%CE%BB%20hq%20%3A%20q%2C%20hp" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">constants</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>This looks exactly like the definition of the constant function in the last chapter, the only difference being that the arguments are elements of <code class="docutils literal notranslate"><span class="pre">Prop</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Type</span></code>. Intuitively, our proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> assumes <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are true, and uses the first hypothesis (trivially) to establish that the conclusion, <code class="docutils literal notranslate"><span class="pre">p</span></code>, is true.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">theorem</span></code> command is really a version of the <code class="docutils literal notranslate"><span class="pre">definition</span></code> command: under the propositions and types correspondence, proving the theorem <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> is really the same as defining an element of the associated type. To the kernel type checker, there is no difference between the two.</p>
<p>There are a few pragmatic differences between definitions and theorems, however. In normal circumstances, it is never necessary to unfold the &#8220;definition&#8221; of a theorem; by proof irrelevance, any two proofs of that theorem are definitionally equal. Once the proof of a theorem is complete, typically we only need to know that the proof exists; it doesn&#8217;t matter what the proof is. In light of that fact, Lean tags proofs as <em>irreducible</em>, which serves as a hint to the parser (more precisely, the <em>elaborator</em>) that there is generally no need to unfold it when processing a file. In fact, Lean is generally able to process and check proofs in parallel, since assessing the correctness of one proof does not require knowing the details of another.</p>
<p>As with definitions, the <code class="docutils literal notranslate"><span class="pre">#print</span></code> command will show you the proof of a theorem.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=constants%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20%3A%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%3A%3D%20%CE%BB%20hp%20%3A%20p%2C%20%CE%BB%20hq%20%3A%20q%2C%20hp%0A%0A%23print%20t1%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="n">hp</span>

<span class="k">#print</span><span class="w"> </span><span class="n">t1</span>
</pre></div>
</div>
</div><p>Notice that the lambda abstractions <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code> can be viewed as temporary assumptions in the proof of <code class="docutils literal notranslate"><span class="pre">t1</span></code>. Lean provides the alternative syntax <code class="docutils literal notranslate"><span class="pre">assume</span></code> for such a lambda abstraction:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=constants%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20%3A%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%3A%3D%0Aassume%20hp%20%3A%20p%2C%0Aassume%20hq%20%3A%20q%2C%0Ahp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="n">hp</span>
</pre></div>
</div>
</div><p>Lean also allows us to specify the type of the final term <code class="docutils literal notranslate"><span class="pre">hp</span></code>, explicitly, with a <code class="docutils literal notranslate"><span class="pre">show</span></code> statement.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=constants%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20%3A%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%3A%3D%0Aassume%20hp%20%3A%20p%2C%0Aassume%20hq%20%3A%20q%2C%0Ashow%20p%2C%20from%20hp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>Adding such extra information can improve the clarity of a proof and help detect errors when writing a proof. The <code class="docutils literal notranslate"><span class="pre">show</span></code> command does nothing more than annotate the type, and, internally, all the presentations of <code class="docutils literal notranslate"><span class="pre">t1</span></code> that we have seen produce the same term. Lean also allows you to use the alternative syntax <code class="docutils literal notranslate"><span class="pre">lemma</span></code> instead of theorem:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=constants%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Alemma%20t1%20%3A%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%3A%3D%0Aassume%20hp%20%3A%20p%2C%0Aassume%20hq%20%3A%20q%2C%0Ashow%20p%2C%20from%20hp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">lemma</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>As with ordinary definitions, we can move the lambda-abstracted variables to the left of the colon:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=constants%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20(hp%20%3A%20p)%20(hq%20%3A%20q)%20%3A%20p%20%3A%3D%20hp%0A%0A%23check%20t1%20%20%20%20--%20p%20%E2%86%92%20q%20%E2%86%92%20p%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">hp</span>

<span class="k">#check</span><span class="w"> </span><span class="n">t1</span><span class="w">    </span><span class="c1">-- p &#8594; q &#8594; p</span>
</pre></div>
</div>
</div><p>Now we can apply the theorem <code class="docutils literal notranslate"><span class="pre">t1</span></code> just as a function application.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=constants%20p%20q%20%3A%20Prop%0A%0Atheorem%20t1%20(hp%20%3A%20p)%20(hq%20%3A%20q)%20%3A%20p%20%3A%3D%20hp%0A%0A--%20BEGIN%0Aaxiom%20hp%20%3A%20p%0A%0Atheorem%20t2%20%3A%20q%20%E2%86%92%20p%20%3A%3D%20t1%20hp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">axiom</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>Here, the <code class="docutils literal notranslate"><span class="pre">axiom</span></code> command is alternative syntax for <code class="docutils literal notranslate"><span class="pre">constant</span></code>. Declaring a &#8220;constant&#8221; <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> is tantamount to declaring that <code class="docutils literal notranslate"><span class="pre">p</span></code> is true, as witnessed by <code class="docutils literal notranslate"><span class="pre">hp</span></code>. Applying the theorem <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> to the fact <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> that <code class="docutils literal notranslate"><span class="pre">p</span></code> is true yields the theorem <code class="docutils literal notranslate"><span class="pre">t2</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>.</p>
<p>Notice, by the way, that the original theorem <code class="docutils literal notranslate"><span class="pre">t1</span></code> is true for <em>any</em> propositions <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>, not just the particular constants declared. So it would be more natural to define the theorem so that it quantifies over those, too:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20t1%20(p%20q%20%3A%20Prop)%20(hp%20%3A%20p)%20(hq%20%3A%20q)%20%3A%20p%20%3A%3D%20hp%0A%0A%23check%20t1" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">hp</span>

<span class="k">#check</span><span class="w"> </span><span class="n">t1</span>
</pre></div>
</div>
</div><p>The type of <code class="docutils literal notranslate"><span class="pre">t1</span></code> is now <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop,</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>. We can read this as the assertion &#8220;for every pair of propositions <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">q</span></code>, we have <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>.&#8221; The symbol <code class="docutils literal notranslate"><span class="pre">&#8704;</span></code> is alternate syntax for <code class="docutils literal notranslate"><span class="pre">&#928;</span></code>, and later we will see how Pi types let us model universal quantifiers more generally. For example, we can move all parameters to the right of the colon:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20t1%20%3A%20%E2%88%80%20(p%20q%20%3A%20Prop)%2C%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%3A%3D%0A%CE%BB%20(p%20q%20%3A%20Prop)%20(hp%20%3A%20p)%20(hq%20%3A%20q)%2C%20hp" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">),</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#955;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">),</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> have been declared as variables, Lean will generalize them for us automatically:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A%0Atheorem%20t1%20%3A%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%3A%3D%20%CE%BB%20(hp%20%3A%20p)%20(hq%20%3A%20q)%2C%20hp" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">),</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>In fact, by the propositions-as-types correspondence, we can declare the assumption <code class="docutils literal notranslate"><span class="pre">hp</span></code> that <code class="docutils literal notranslate"><span class="pre">p</span></code> holds, as another variable:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0Avariable%20%20hp%20%3A%20p%0A%0Atheorem%20t1%20%3A%20q%20%E2%86%92%20p%20%3A%3D%20%CE%BB%20(hq%20%3A%20q)%2C%20hp" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">variable</span><span class="w">  </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">),</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>Lean detects that the proof uses <code class="docutils literal notranslate"><span class="pre">hp</span></code> and automatically adds <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> as a premise. In all cases, the command <code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">t1</span></code> still yields <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop,</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>. Remember that this type can just as well be written <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">(p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop)</span> <span class="pre">(hp</span> <span class="pre">:</span> <span class="pre">p)</span> <span class="pre">(hq</span> <span class="pre">:q),</span> <span class="pre">p</span></code>, since the arrow denotes nothing more than a Pi type in which the target does not depend on the bound variable.</p>
<p>When we generalize <code class="docutils literal notranslate"><span class="pre">t1</span></code> in such a way, we can then apply it to different pairs of propositions, to obtain different instances of the general theorem.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20t1%20(p%20q%20%3A%20Prop)%20(hp%20%3A%20p)%20(hq%20%3A%20q)%20%3A%20p%20%3A%3D%20hp%0A%0Avariables%20p%20q%20r%20s%20%3A%20Prop%0A%0A%23check%20t1%20p%20q%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20p%20%E2%86%92%20q%20%E2%86%92%20p%0A%23check%20t1%20r%20s%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20r%20%E2%86%92%20s%20%E2%86%92%20r%0A%23check%20t1%20(r%20%E2%86%92%20s)%20(s%20%E2%86%92%20r)%20%20%20%20--%20(r%20%E2%86%92%20s)%20%E2%86%92%20(s%20%E2%86%92%20r)%20%E2%86%92%20r%20%E2%86%92%20s%0A%0Avariable%20h%20%3A%20r%20%E2%86%92%20s%0A%23check%20t1%20(r%20%E2%86%92%20s)%20(s%20%E2%86%92%20r)%20h%20%20--%20(s%20%E2%86%92%20r)%20%E2%86%92%20r%20%E2%86%92%20s" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">hp</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="k">#check</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w">                </span><span class="c1">-- p &#8594; q &#8594; p</span>
<span class="k">#check</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">s</span><span class="w">                </span><span class="c1">-- r &#8594; s &#8594; r</span>
<span class="k">#check</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">s</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w">    </span><span class="c1">-- (r &#8594; s) &#8594; (s &#8594; r) &#8594; r &#8594; s</span>

<span class="kd">variable</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">s</span>
<span class="k">#check</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">s</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="n">h</span><span class="w">  </span><span class="c1">-- (s &#8594; r) &#8594; r &#8594; s</span>
</pre></div>
</div>
</div><p>Once again, using the propositions-as-types correspondence, the variable <code class="docutils literal notranslate"><span class="pre">h</span></code> of type <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">&#8594;</span> <span class="pre">s</span></code> can be viewed as the hypothesis, or premise, that <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">&#8594;</span> <span class="pre">s</span></code> holds.</p>
<p>As another example, let us consider the composition function discussed in the last chapter, now with propositions instead of types.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20s%20%3A%20Prop%0A%0Atheorem%20t2%20(h%E2%82%81%20%3A%20q%20%E2%86%92%20r)%20(h%E2%82%82%20%3A%20p%20%E2%86%92%20q)%20%3A%20p%20%E2%86%92%20r%20%3A%3D%0Aassume%20h%E2%82%83%20%3A%20p%2C%0Ashow%20r%2C%20from%20h%E2%82%81%20(h%E2%82%82%20h%E2%82%83)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">h&#8323;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="n">h&#8323;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>As a theorem of propositional logic, what does <code class="docutils literal notranslate"><span class="pre">t2</span></code> say?</p>
<p>Note that it is often useful to use numeric unicode subscripts, entered as <code class="docutils literal notranslate"><span class="pre">\0</span></code>, <code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>, &#8230;, for hypotheses, as we did in this example.</p>
</section>
<section id="propositional-logic">
<span id="id2"></span><h2><span class="section-number">3.3. </span>Propositional Logic<a class="headerlink" href="#propositional-logic" title="Link to this heading">&#182;</a></h2>
<p>Lean defines all the standard logical connectives and notation. The propositional connectives come with the following notation:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Ascii</p></td>
<td><p>Unicode</p></td>
<td><p>Editor shortcut</p></td>
<td><p>Definition</p></td>
</tr>
<tr class="row-even"><td><p>true</p></td>
<td></td>
<td></td>
<td><p>true</p></td>
</tr>
<tr class="row-odd"><td><p>false</p></td>
<td></td>
<td></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>not</p></td>
<td><p>&#172;</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\not</span></code>, <code class="docutils literal notranslate"><span class="pre">\neg</span></code></p></td>
<td><p>not</p></td>
</tr>
<tr class="row-odd"><td><p>/\</p></td>
<td><p>&#8743;</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\and</span></code></p></td>
<td><p>and</p></td>
</tr>
<tr class="row-even"><td><p>\/</p></td>
<td><p>&#8744;</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\or</span></code></p></td>
<td><p>or</p></td>
</tr>
<tr class="row-odd"><td><p>-&gt;</p></td>
<td><p>&#8594;</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\to</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code>, <code class="docutils literal notranslate"><span class="pre">\imp</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>&lt;-&gt;</p></td>
<td><p>&#8596;</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\iff</span></code>, <code class="docutils literal notranslate"><span class="pre">\lr</span></code></p></td>
<td><p>iff</p></td>
</tr>
</tbody>
</table>
<p>They all take values in <code class="docutils literal notranslate"><span class="pre">Prop</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A%0A%23check%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%E2%88%A7%20q%0A%23check%20%C2%ACp%20%E2%86%92%20p%20%E2%86%94%20false%0A%23check%20p%20%E2%88%A8%20q%20%E2%86%92%20q%20%E2%88%A8%20p" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="k">#check</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">false</span>
<span class="k">#check</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span>
</pre></div>
</div>
</div><p>The order of operations is as follows: unary negation <code class="docutils literal notranslate"><span class="pre">&#172;</span></code> binds most strongly, then <code class="docutils literal notranslate"><span class="pre">&#8743;</span></code>, then <code class="docutils literal notranslate"><span class="pre">&#8744;</span></code>, then <code class="docutils literal notranslate"><span class="pre">&#8594;</span></code>, and finally <code class="docutils literal notranslate"><span class="pre">&#8596;</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8743;</span> <span class="pre">b</span> <span class="pre">&#8594;</span> <span class="pre">c</span> <span class="pre">&#8744;</span> <span class="pre">d</span> <span class="pre">&#8743;</span> <span class="pre">e</span></code> means <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">&#8743;</span> <span class="pre">b)</span> <span class="pre">&#8594;</span> <span class="pre">(c</span> <span class="pre">&#8744;</span> <span class="pre">(d</span> <span class="pre">&#8743;</span> <span class="pre">e))</span></code>. Remember that <code class="docutils literal notranslate"><span class="pre">&#8594;</span></code> associates to the right (nothing changes now that the arguments are elements of <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, instead of some other <code class="docutils literal notranslate"><span class="pre">Type</span></code>), as do the other binary connectives. So if we have <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">q</span> <span class="pre">r</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code> reads &#8220;if <code class="docutils literal notranslate"><span class="pre">p</span></code>, then if <code class="docutils literal notranslate"><span class="pre">q</span></code>, then <code class="docutils literal notranslate"><span class="pre">r</span></code>.&#8221; This is just the &#8220;curried&#8221; form of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>.</p>
<p>In the last chapter we observed that lambda abstraction can be viewed as an &#8220;introduction rule&#8221; for <code class="docutils literal notranslate"><span class="pre">&#8594;</span></code>. In the current setting, it shows how to &#8220;introduce&#8221; or establish an implication. Application can be viewed as an &#8220;elimination rule,&#8221; showing how to &#8220;eliminate&#8221; or use an implication in a proof. The other propositional connectives are defined in Lean&#8217;s library in the file <code class="docutils literal notranslate"><span class="pre">init.core</span></code> (see <a class="reference internal" href="interacting_with_lean.html#importing-files"><span class="std std-numref">Section 6.1</span></a> for more information on the library hierarchy), and each connective comes with its canonical introduction and elimination rules.</p>
<section id="conjunction">
<span id="id3"></span><h3><span class="section-number">3.3.1. </span>Conjunction<a class="headerlink" href="#conjunction" title="Link to this heading">&#182;</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="pre">and.intro</span> <span class="pre">h1</span> <span class="pre">h2</span></code> builds a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code> using proofs <code class="docutils literal notranslate"><span class="pre">h1</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">h2</span> <span class="pre">:</span> <span class="pre">q</span></code>. It is common to describe <code class="docutils literal notranslate"><span class="pre">and.intro</span></code> as the <em>and-introduction</em> rule. In the next example we use <code class="docutils literal notranslate"><span class="pre">and.intro</span></code> to create a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0A%0Aexample%20(hp%20%3A%20p)%20(hq%20%3A%20q)%20%3A%20p%20%E2%88%A7%20q%20%3A%3D%20and.intro%20hp%20hq%0A%0A%23check%20assume%20(hp%20%3A%20p)%20(hq%20%3A%20q)%2C%20and.intro%20hp%20hq%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="n">hq</span>

<span class="k">#check</span><span class="w"> </span><span class="k">assume</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">),</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="n">hq</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">example</span></code> command states a theorem without naming it or storing it in the permanent context. Essentially, it just checks that the given term has the indicated type. It is convenient for illustration, and we will use it often.</p>
<p>The expression <code class="docutils literal notranslate"><span class="pre">and.elim_left</span> <span class="pre">h</span></code> creates a proof of <code class="docutils literal notranslate"><span class="pre">p</span></code> from a proof <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>. Similarly, <code class="docutils literal notranslate"><span class="pre">and.elim_right</span> <span class="pre">h</span></code> is a proof of <code class="docutils literal notranslate"><span class="pre">q</span></code>. They are commonly known as the right and left <em>and-elimination</em> rules.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20p%20%3A%3D%20and.elim_left%20h%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%3A%3D%20and.elim_right%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">and.elim_left</span><span class="w"> </span><span class="n">h</span>
<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">and.elim_right</span><span class="w"> </span><span class="n">h</span>
</pre></div>
</div>
</div><p>Because they are so commonly used, the standard library provides the abbreviations <code class="docutils literal notranslate"><span class="pre">and.left</span></code> and <code class="docutils literal notranslate"><span class="pre">and.right</span></code> for <code class="docutils literal notranslate"><span class="pre">and.elim_left</span></code> and <code class="docutils literal notranslate"><span class="pre">and.elim_right</span></code>, respectively.</p>
<p>We can now prove <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> with the following proof term.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%0Aand.intro%20(and.right%20h)%20(and.left%20h)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">and.intro</span><span class="w"> </span><span class="o">(</span><span class="n">and.right</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">and.left</span><span class="w"> </span><span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice that and-introduction and and-elimination are similar to the pairing and projection operations for the cartesian product. The difference is that given <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">and.intro</span> <span class="pre">hp</span> <span class="pre">hq</span></code> has type <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, while <code class="docutils literal notranslate"><span class="pre">pair</span> <span class="pre">hp</span> <span class="pre">hq</span></code> has type <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#215;</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Type</span></code>. The similarity between <code class="docutils literal notranslate"><span class="pre">&#8743;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#215;</span></code> is another instance of the Curry-Howard isomorphism, but in contrast to implication and the function space constructor, <code class="docutils literal notranslate"><span class="pre">&#8743;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#215;</span></code> are treated separately in Lean. With the analogy, however, the proof we have just constructed is similar to a function that swaps the elements of a pair.</p>
<p>We will see in <a class="reference internal" href="structures_and_records.html#structures-and-records"><span class="std std-numref">Chapter 9</span></a> that certain types in Lean are <em>structures</em>, which is to say, the type is defined with a single canonical <em>constructor</em> which builds an element of the type from a sequence of suitable arguments. For every <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code> is an example: the canonical way to construct an element is to apply <code class="docutils literal notranslate"><span class="pre">and.intro</span></code> to suitable arguments <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>. Lean allows us to use <em>anonymous constructor</em> notation <code class="docutils literal notranslate"><span class="pre">&#10216;arg1,</span> <span class="pre">arg2,</span> <span class="pre">...&#10217;</span></code> in situations like these, when the relevant type is an inductive type and can be inferred from the context. In particular, we can often write <code class="docutils literal notranslate"><span class="pre">&#10216;hp,</span> <span class="pre">hq&#10217;</span></code> instead of <code class="docutils literal notranslate"><span class="pre">and.intro</span> <span class="pre">hp</span> <span class="pre">hq</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0Avariables%20%20(hp%20%3A%20p)%20(hq%20%3A%20q)%0A%0A%23check%20(%E2%9F%A8hp%2C%20hq%E2%9F%A9%20%3A%20p%20%E2%88%A7%20q)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="kd">variables</span><span class="w">  </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(&#10216;</span><span class="n">hp</span><span class="o">,</span><span class="w"> </span><span class="n">hq</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span>
</pre></div>
</div>
</div><p>These angle brackets are obtained by typing <code class="docutils literal notranslate"><span class="pre">\&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">\&gt;</span></code>, respectively.</p>
<p>Lean provides another useful syntactic gadget. Given an expression <code class="docutils literal notranslate"><span class="pre">e</span></code> of an inductive type <code class="docutils literal notranslate"><span class="pre">foo</span></code> (possibly applied to some arguments), the notation <code class="docutils literal notranslate"><span class="pre">e.bar</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">foo.bar</span> <span class="pre">e</span></code>. This provides a convenient way of accessing functions without opening a namespace. For example, the following two expressions mean the same thing:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20l%20%3A%20list%20%E2%84%95%0A%0A%23check%20list.head%20l%0A%23check%20l.head" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#8469;</span>

<span class="k">#check</span><span class="w"> </span><span class="n">list.head</span><span class="w"> </span><span class="n">l</span>
<span class="k">#check</span><span class="w"> </span><span class="n">l.head</span>
</pre></div>
</div>
</div><p>As a result, given <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>, we can write <code class="docutils literal notranslate"><span class="pre">h.left</span></code> for <code class="docutils literal notranslate"><span class="pre">and.left</span> <span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">h.right</span></code> for <code class="docutils literal notranslate"><span class="pre">and.right</span> <span class="pre">h</span></code>. We can therefore rewrite the sample proof above conveniently as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%0A%E2%9F%A8h.right%2C%20h.left%E2%9F%A9%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span><span class="w"> </span><span class="n">h.left</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>There is a fine line between brevity and obfuscation, and omitting information in this way can sometimes make a proof harder to read. But for straightforward constructions like the one above, when the type of <code class="docutils literal notranslate"><span class="pre">h</span></code> and the goal of the construction are salient, the notation is clean and effective.</p>
<p>It is common to iterate constructions like &#8220;and.&#8221; Lean also allows you to flatten nested constructors that associate to the right, so that these two proofs are equivalent:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%E2%88%A7%20q%3A%3D%0A%E2%9F%A8h.right%2C%20%E2%9F%A8h.left%2C%20h.right%E2%9F%A9%E2%9F%A9%0A%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%E2%88%A7%20q%3A%3D%0A%E2%9F%A8h.right%2C%20h.left%2C%20h.right%E2%9F%A9%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">h.left</span><span class="o">,</span><span class="w"> </span><span class="n">h.right</span><span class="o">&#10217;&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span><span class="w"> </span><span class="n">h.left</span><span class="o">,</span><span class="w"> </span><span class="n">h.right</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>This is often useful as well.</p>
</section>
<section id="disjunction">
<h3><span class="section-number">3.3.2. </span>Disjunction<a class="headerlink" href="#disjunction" title="Link to this heading">&#182;</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="pre">or.intro_left</span> <span class="pre">q</span> <span class="pre">hp</span></code> creates a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code> from a proof <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code>. Similarly, <code class="docutils literal notranslate"><span class="pre">or.intro_right</span> <span class="pre">p</span> <span class="pre">hq</span></code> creates a proof for <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code> using a proof <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>. These are the left and right <em>or-introduction</em> rules.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(hp%20%3A%20p)%20%3A%20p%20%E2%88%A8%20q%20%3A%3D%20or.intro_left%20q%20hp%0Aexample%20(hq%20%3A%20q)%20%3A%20p%20%E2%88%A8%20q%20%3A%3D%20or.intro_right%20p%20hq%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">or.intro_left</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">hp</span>
<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">or.intro_right</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">hq</span>
</pre></div>
</div>
</div><p>The <em>or-elimination</em> rule is slightly more complicated. The idea is that we can prove <code class="docutils literal notranslate"><span class="pre">r</span></code> from <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>, by showing that <code class="docutils literal notranslate"><span class="pre">r</span></code> follows from <code class="docutils literal notranslate"><span class="pre">p</span></code> and that <code class="docutils literal notranslate"><span class="pre">r</span></code> follows from <code class="docutils literal notranslate"><span class="pre">q</span></code>. In other words, it is a proof by cases. In the expression <code class="docutils literal notranslate"><span class="pre">or.elim</span> <span class="pre">hpq</span> <span class="pre">hpr</span> <span class="pre">hqr</span></code>, <code class="docutils literal notranslate"><span class="pre">or.elim</span></code> takes three arguments, <code class="docutils literal notranslate"><span class="pre">hpq</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">hpr</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code> and <code class="docutils literal notranslate"><span class="pre">hqr</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>, and produces a proof of <code class="docutils literal notranslate"><span class="pre">r</span></code>. In the following example, we use <code class="docutils literal notranslate"><span class="pre">or.elim</span></code> to prove <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8744;</span> <span class="pre">p</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A8%20q)%20%3A%20q%20%E2%88%A8%20p%20%3A%3D%0Aor.elim%20h%0A%20%20(assume%20hp%20%3A%20p%2C%0A%20%20%20%20show%20q%20%E2%88%A8%20p%2C%20from%20or.intro_right%20q%20hp)%0A%20%20(assume%20hq%20%3A%20q%2C%0A%20%20%20%20show%20q%20%E2%88%A8%20p%2C%20from%20or.intro_left%20p%20hq)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">or.elim</span><span class="w"> </span><span class="n">h</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">or.intro_right</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">or.intro_left</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">hq</span><span class="o">)</span>
</pre></div>
</div>
</div><p>In most cases, the first argument of <code class="docutils literal notranslate"><span class="pre">or.intro_right</span></code> and <code class="docutils literal notranslate"><span class="pre">or.intro_left</span></code> can be inferred automatically by Lean. Lean therefore provides <code class="docutils literal notranslate"><span class="pre">or.inr</span></code> and <code class="docutils literal notranslate"><span class="pre">or.inl</span></code> as shorthand for <code class="docutils literal notranslate"><span class="pre">or.intro_right</span> <span class="pre">_</span></code> and <code class="docutils literal notranslate"><span class="pre">or.intro_left</span> <span class="pre">_</span></code>. Thus the proof term above could be written more concisely:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A8%20q)%20%3A%20q%20%E2%88%A8%20p%20%3A%3D%0Aor.elim%20h%20(%CE%BB%20hp%2C%20or.inr%20hp)%20(%CE%BB%20hq%2C%20or.inl%20hq)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">or.elim</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hp</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">hq</span><span class="o">,</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="n">hq</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice that there is enough information in the full expression for Lean to infer the types of <code class="docutils literal notranslate"><span class="pre">hp</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span></code> as well. But using the type annotations in the longer version makes the proof more readable, and can help catch and debug errors.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">or</span></code> has two constructors, we cannot use anonymous constructor notation. But we can still write <code class="docutils literal notranslate"><span class="pre">h.elim</span></code> instead of <code class="docutils literal notranslate"><span class="pre">or.elim</span> <span class="pre">h</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A8%20q)%20%3A%20q%20%E2%88%A8%20p%20%3A%3D%0Ah.elim%0A%20%20(assume%20hp%20%3A%20p%2C%20or.inr%20hp)%0A%20%20(assume%20hq%20%3A%20q%2C%20or.inl%20hq)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">h.elim</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="n">hq</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Once again, you should exercise judgment as to whether such abbreviations enhance or diminish readability.</p>
</section>
<section id="negation-and-falsity">
<h3><span class="section-number">3.3.3. </span>Negation and Falsity<a class="headerlink" href="#negation-and-falsity" title="Link to this heading">&#182;</a></h3>
<p>Negation, <code class="docutils literal notranslate"><span class="pre">&#172;p</span></code>, is actually defined to be <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">false</span></code>, so we obtain <code class="docutils literal notranslate"><span class="pre">&#172;p</span></code> by deriving a contradiction from <code class="docutils literal notranslate"><span class="pre">p</span></code>. Similarly, the expression <code class="docutils literal notranslate"><span class="pre">hnp</span> <span class="pre">hp</span></code> produces a proof of <code class="docutils literal notranslate"><span class="pre">false</span></code> from <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">hnp</span> <span class="pre">:</span> <span class="pre">&#172;p</span></code>. The next example uses both these rules to produce a proof of <code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">&#172;q</span> <span class="pre">&#8594;</span> <span class="pre">&#172;p</span></code>. (The symbol <code class="docutils literal notranslate"><span class="pre">&#172;</span></code> is produced by typing <code class="docutils literal notranslate"><span class="pre">\not</span></code> or <code class="docutils literal notranslate"><span class="pre">\neg</span></code>.)</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(hpq%20%3A%20p%20%E2%86%92%20q)%20(hnq%20%3A%20%C2%ACq)%20%3A%20%C2%ACp%20%3A%3D%0Aassume%20hp%20%3A%20p%2C%0Ashow%20false%2C%20from%20hnq%20(hpq%20hp)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hpq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hnq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">false</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">hnq</span><span class="w"> </span><span class="o">(</span><span class="n">hpq</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The connective <code class="docutils literal notranslate"><span class="pre">false</span></code> has a single elimination rule, <code class="docutils literal notranslate"><span class="pre">false.elim</span></code>, which expresses the fact that anything follows from a contradiction. This rule is sometimes called <em>ex falso</em> (short for <em>ex falso sequitur quodlibet</em>), or the <em>principle of explosion</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(hp%20%3A%20p)%20(hnp%20%3A%20%C2%ACp)%20%3A%20q%20%3A%3D%20false.elim%20(hnp%20hp)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hnp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">false.elim</span><span class="w"> </span><span class="o">(</span><span class="n">hnp</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The arbitrary fact, <code class="docutils literal notranslate"><span class="pre">q</span></code>, that follows from falsity is an implicit argument in <code class="docutils literal notranslate"><span class="pre">false.elim</span></code> and is inferred automatically. This pattern, deriving an arbitrary fact from contradictory hypotheses, is quite common, and is represented by <code class="docutils literal notranslate"><span class="pre">absurd</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(hp%20%3A%20p)%20(hnp%20%3A%20%C2%ACp)%20%3A%20q%20%3A%3D%20absurd%20hp%20hnp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hnp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">absurd</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="n">hnp</span>
</pre></div>
</div>
</div><p>Here, for example, is a proof of <code class="docutils literal notranslate"><span class="pre">&#172;p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">(q</span> <span class="pre">&#8594;</span> <span class="pre">p)</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(hnp%20%3A%20%C2%ACp)%20(hq%20%3A%20q)%20(hqp%20%3A%20q%20%E2%86%92%20p)%20%3A%20r%20%3A%3D%0Aabsurd%20(hqp%20hq)%20hnp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hnp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hqp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="n">absurd</span><span class="w"> </span><span class="o">(</span><span class="n">hqp</span><span class="w"> </span><span class="n">hq</span><span class="o">)</span><span class="w"> </span><span class="n">hnp</span>
</pre></div>
</div>
</div><p>Incidentally, just as <code class="docutils literal notranslate"><span class="pre">false</span></code> has only an elimination rule, <code class="docutils literal notranslate"><span class="pre">true</span></code> has only an introduction rule, <code class="docutils literal notranslate"><span class="pre">true.intro</span> <span class="pre">:</span> <span class="pre">true</span></code>, sometimes abbreviated <code class="docutils literal notranslate"><span class="pre">trivial</span> <span class="pre">:</span> <span class="pre">true</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">true</span></code> is simply true, and has a canonical proof, <code class="docutils literal notranslate"><span class="pre">trivial</span></code>.</p>
</section>
<section id="logical-equivalence">
<h3><span class="section-number">3.3.4. </span>Logical Equivalence<a class="headerlink" href="#logical-equivalence" title="Link to this heading">&#182;</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="pre">iff.intro</span> <span class="pre">h1</span> <span class="pre">h2</span></code> produces a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code> from <code class="docutils literal notranslate"><span class="pre">h1</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">h2</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>. The expression <code class="docutils literal notranslate"><span class="pre">iff.elim_left</span> <span class="pre">h</span></code> produces a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> from <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code>. Similarly, <code class="docutils literal notranslate"><span class="pre">iff.elim_right</span> <span class="pre">h</span></code> produces a proof of <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> from <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code>. Here is a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8596;</span> <span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20and_swap%20%3A%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20%3A%3D%0Aiff.intro%0A%20%20(assume%20h%20%3A%20p%20%E2%88%A7%20q%2C%0A%20%20%20%20show%20q%20%E2%88%A7%20p%2C%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%20%20(assume%20h%20%3A%20q%20%E2%88%A7%20p%2C%0A%20%20%20%20show%20p%20%E2%88%A7%20q%2C%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%0A%23check%20and_swap%20p%20q%20%20%20%20--%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">and_swap</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">iff.intro</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="o">(</span><span class="n">and.right</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">and.left</span><span class="w"> </span><span class="n">h</span><span class="o">))</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="o">(</span><span class="n">and.right</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">and.left</span><span class="w"> </span><span class="n">h</span><span class="o">))</span>

<span class="k">#check</span><span class="w"> </span><span class="n">and_swap</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w">    </span><span class="c1">-- p &#8743; q &#8596; q &#8743; p</span>
</pre></div>
</div>
</div><p>Because they represent a form of <em>modus ponens</em>, <code class="docutils literal notranslate"><span class="pre">iff.elim_left</span></code> and <code class="docutils literal notranslate"><span class="pre">iff.elim_right</span></code> can be abbreviated <code class="docutils literal notranslate"><span class="pre">iff.mp</span></code> and <code class="docutils literal notranslate"><span class="pre">iff.mpr</span></code>, respectively. In the next example, we use that theorem to derive <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> from <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A%0Atheorem%20and_swap%20%3A%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20%3A%3D%0Aiff.intro%0A%20%20(assume%20h%20%3A%20p%20%E2%88%A7%20q%2C%0A%20%20%20%20show%20q%20%E2%88%A7%20p%2C%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%20%20(assume%20h%20%3A%20q%20%E2%88%A7%20p%2C%0A%20%20%20%20show%20p%20%E2%88%A7%20q%2C%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%0A--%20BEGIN%0Avariable%20h%20%3A%20p%20%E2%88%A7%20q%0Aexample%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%20iff.mp%20(and_swap%20p%20q)%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">iff.mp</span><span class="w"> </span><span class="o">(</span><span class="n">and_swap</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="n">h</span>
</pre></div>
</div>
</div><p>We can use the anonymous constructor notation to construct a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code> from proofs of the forward and backward directions, and we can also use <code class="docutils literal notranslate"><span class="pre">.</span></code> notation with <code class="docutils literal notranslate"><span class="pre">mp</span></code> and <code class="docutils literal notranslate"><span class="pre">mpr</span></code>. The previous examples can therefore be written concisely as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Atheorem%20and_swap%20%3A%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20%3A%3D%0A%E2%9F%A8%20%CE%BB%20h%2C%20%E2%9F%A8h.right%2C%20h.left%E2%9F%A9%2C%20%CE%BB%20h%2C%20%E2%9F%A8h.right%2C%20h.left%E2%9F%A9%20%E2%9F%A9%0A%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%20(and_swap%20p%20q).mp%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">and_swap</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span><span class="w"> </span><span class="n">h.left</span><span class="o">&#10217;,</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">h</span><span class="o">,</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span><span class="w"> </span><span class="n">h.left</span><span class="o">&#10217;</span><span class="w"> </span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="n">and_swap</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span><span class="w"> </span><span class="n">h</span>
</pre></div>
</div>
</div></section>
</section>
<section id="introducing-auxiliary-subgoals">
<h2><span class="section-number">3.4. </span>Introducing Auxiliary Subgoals<a class="headerlink" href="#introducing-auxiliary-subgoals" title="Link to this heading">&#182;</a></h2>
<p>This is a good place to introduce another device Lean offers to help structure long proofs, namely, the <code class="docutils literal notranslate"><span class="pre">have</span></code> construct, which introduces an auxiliary subgoal in a proof. Here is a small example, adapted from the last section:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%0Ahave%20hp%20%3A%20p%2C%20from%20and.left%20h%2C%0Ahave%20hq%20%3A%20q%2C%20from%20and.right%20h%2C%0Ashow%20q%20%E2%88%A7%20p%2C%20from%20and.intro%20hq%20hp" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">have</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.left</span><span class="w"> </span><span class="n">h</span><span class="o">,</span>
<span class="k">have</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.right</span><span class="w"> </span><span class="n">h</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>Internally, the expression <code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">from</span> <span class="pre">s,</span> <span class="pre">t</span></code> produces the term <code class="docutils literal notranslate"><span class="pre">(&#955;</span> <span class="pre">(h</span> <span class="pre">:</span> <span class="pre">p),</span> <span class="pre">t)</span> <span class="pre">s</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">s</span></code> is a proof of <code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> is a proof of the desired conclusion assuming <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span></code>, and the two are combined by a lambda abstraction and application. This simple device is extremely useful when it comes to structuring long proofs, since we can use intermediate <code class="docutils literal notranslate"><span class="pre">have</span></code>&#8217;s as stepping stones leading to the final goal.</p>
<p>Lean also supports a structured way of reasoning backwards from a goal, which models the &#8220;suffices to show&#8221; construction in ordinary mathematics. The next example simply permutes the last two lines in the previous proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%0Ahave%20hp%20%3A%20p%2C%20from%20and.left%20h%2C%0Asuffices%20hq%20%3A%20q%2C%20from%20and.intro%20hq%20hp%2C%0Ashow%20q%2C%20from%20and.right%20h" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">have</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.left</span><span class="w"> </span><span class="n">h</span><span class="o">,</span>
<span class="k">suffices</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="n">hp</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.right</span><span class="w"> </span><span class="n">h</span>
</pre></div>
</div>
</div><p>Writing <code class="docutils literal notranslate"><span class="pre">suffices</span> <span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code> leaves us with two goals. First, we have to show that it indeed suffices to show <code class="docutils literal notranslate"><span class="pre">q</span></code>, by proving the original goal of <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> with the additional hypothesis <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>. Finally, we have to show <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
</section>
<section id="classical-logic">
<span id="id4"></span><h2><span class="section-number">3.5. </span>Classical Logic<a class="headerlink" href="#classical-logic" title="Link to this heading">&#182;</a></h2>
<p>The introduction and elimination rules we have seen so far are all constructive, which is to say, they reflect a computational understanding of the logical connectives based on the propositions-as-types correspondence. Ordinary classical logic adds to this the law of the excluded middle, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;p</span></code>. To use this principle, you have to open the classical namespace.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Avariable%20p%20%3A%20Prop%0A%23check%20em%20p" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">classical</span>

<span class="kd">variable</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="k">#check</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="n">p</span>
</pre></div>
</div>
</div><p>Intuitively, the constructive &#8220;or&#8221; is very strong: asserting <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code> amounts to knowing which is the case. If <code class="docutils literal notranslate"><span class="pre">RH</span></code> represents the Riemann hypothesis, a classical mathematician is willing to assert <code class="docutils literal notranslate"><span class="pre">RH</span> <span class="pre">&#8744;</span> <span class="pre">&#172;RH</span></code>, even though we cannot yet assert either disjunct.</p>
<p>One consequence of the law of the excluded middle is the principle of double-negation elimination:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0A--%20BEGIN%0Atheorem%20dne%20%7Bp%20%3A%20Prop%7D%20(h%20%3A%20%C2%AC%C2%ACp)%20%3A%20p%20%3A%3D%0Aor.elim%20(em%20p)%0A%20%20(assume%20hp%20%3A%20p%2C%20hp)%0A%20%20(assume%20hnp%20%3A%20%C2%ACp%2C%20absurd%20hnp%20h)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">dne</span><span class="w"> </span><span class="o">{</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">or.elim</span><span class="w"> </span><span class="o">(</span><span class="n">em</span><span class="w"> </span><span class="n">p</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hnp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">absurd</span><span class="w"> </span><span class="n">hnp</span><span class="w"> </span><span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Double-negation elimination allows one to prove any proposition, <code class="docutils literal notranslate"><span class="pre">p</span></code>, by assuming <code class="docutils literal notranslate"><span class="pre">&#172;p</span></code> and deriving <code class="docutils literal notranslate"><span class="pre">false</span></code>, because that amounts to proving <code class="docutils literal notranslate"><span class="pre">&#172;&#172;p</span></code>. In other words, double-negation elimination allows one to carry out a proof by contradiction, something which is not generally possible in constructive logic. As an exercise, you might try proving the converse, that is, showing that <code class="docutils literal notranslate"><span class="pre">em</span></code> can be proved from <code class="docutils literal notranslate"><span class="pre">dne</span></code>.</p>
<p>The classical axioms also give you access to additional patterns of proof that can be justified by appeal to <code class="docutils literal notranslate"><span class="pre">em</span></code>. For example, one can carry out a proof by cases:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Avariable%20p%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC%C2%ACp)%20%3A%20p%20%3A%3D%0Aby_cases%0A%20%20(assume%20h1%20%3A%20p%2C%20h1)%0A%20%20(assume%20h1%20%3A%20%C2%ACp%2C%20absurd%20h1%20h)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">by_cases</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">h1</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="n">absurd</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Or you can carry out a proof by contradiction:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Avariable%20p%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC%C2%ACp)%20%3A%20p%20%3A%3D%0Aby_contradiction%0A%20%20(assume%20h1%20%3A%20%C2%ACp%2C%0A%20%20%20%20show%20false%2C%20from%20h%20h1)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="n">by_contradiction</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="n">false</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">h1</span><span class="o">)</span>
</pre></div>
</div>
</div><p>If you are not used to thinking constructively, it may take some time for you to get a sense of where classical reasoning is used. It is needed in the following example because, from a constructive standpoint, knowing that <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are not both true does not necessarily tell you which one is false:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Avariables%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC(p%20%E2%88%A7%20q))%20%3A%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%3A%3D%0Aor.elim%20(em%20p)%0A%20%20(assume%20hp%20%3A%20p%2C%0A%20%20%20%20or.inr%0A%20%20%20%20%20%20(show%20%C2%ACq%2C%20from%0A%20%20%20%20%20%20%20%20assume%20hq%20%3A%20q%2C%0A%20%20%20%20%20%20%20%20h%20%E2%9F%A8hp%2C%20hq%E2%9F%A9))%0A%20%20(assume%20hp%20%3A%20%C2%ACp%2C%0A%20%20%20%20or.inl%20hp)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="o">:=</span>
<span class="n">or.elim</span><span class="w"> </span><span class="o">(</span><span class="n">em</span><span class="w"> </span><span class="n">p</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="w">    </span><span class="n">or.inr</span>
<span class="w">      </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span>
<span class="w">        </span><span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span><span class="w"> </span><span class="n">hq</span><span class="o">&#10217;))</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span>
<span class="w">    </span><span class="n">or.inl</span><span class="w"> </span><span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>We will see later that there <em>are</em> situations in constructive logic where principles like excluded middle and double-negation elimination are permissible, and Lean supports the use of classical reasoning in such contexts without relying on excluded middle.</p>
<p>The full list of axioms that are used in Lean to support classical reasoning are discussed in <a class="reference internal" href="axioms_and_computation.html#axioms-and-computation"><span class="std std-numref">Chapter 11</span></a>.</p>
</section>
<section id="examples-of-propositional-validities">
<span id="id5"></span><h2><span class="section-number">3.6. </span>Examples of Propositional Validities<a class="headerlink" href="#examples-of-propositional-validities" title="Link to this heading">&#182;</a></h2>
<p>Lean&#8217;s standard library contains proofs of many valid statements of propositional logic, all of which you are free to use in proofs of your own. The following list includes a number of common identities.</p>
<p>Commutativity:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8596;</span> <span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span> <span class="pre">&#8596;</span> <span class="pre">q</span> <span class="pre">&#8744;</span> <span class="pre">p</span></code></p></li>
</ol>
<p>Associativity:</p>
<ol class="arabic simple" start="3">
<li><p><code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">&#8743;</span> <span class="pre">q)</span> <span class="pre">&#8743;</span> <span class="pre">r</span> <span class="pre">&#8596;</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">(q</span> <span class="pre">&#8743;</span> <span class="pre">r)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">&#8744;</span> <span class="pre">q)</span> <span class="pre">&#8744;</span> <span class="pre">r</span> <span class="pre">&#8596;</span> <span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">(q</span> <span class="pre">&#8744;</span> <span class="pre">r)</span></code></p></li>
</ol>
<p>Distributivity:</p>
<ol class="arabic simple" start="5">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">(q</span> <span class="pre">&#8744;</span> <span class="pre">r)</span> <span class="pre">&#8596;</span> <span class="pre">(p</span> <span class="pre">&#8743;</span> <span class="pre">q)</span> <span class="pre">&#8744;</span> <span class="pre">(p</span> <span class="pre">&#8743;</span> <span class="pre">r)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">(q</span> <span class="pre">&#8743;</span> <span class="pre">r)</span> <span class="pre">&#8596;</span> <span class="pre">(p</span> <span class="pre">&#8744;</span> <span class="pre">q)</span> <span class="pre">&#8743;</span> <span class="pre">(p</span> <span class="pre">&#8744;</span> <span class="pre">r)</span></code></p></li>
</ol>
<p>Other properties:</p>
<ol class="arabic simple" start="7">
<li><p><code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">(q</span> <span class="pre">&#8594;</span> <span class="pre">r))</span> <span class="pre">&#8596;</span> <span class="pre">(p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">((p</span> <span class="pre">&#8744;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">r)</span> <span class="pre">&#8596;</span> <span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">r)</span> <span class="pre">&#8743;</span> <span class="pre">(q</span> <span class="pre">&#8594;</span> <span class="pre">r)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#172;(p</span> <span class="pre">&#8744;</span> <span class="pre">q)</span> <span class="pre">&#8596;</span> <span class="pre">&#172;p</span> <span class="pre">&#8743;</span> <span class="pre">&#172;q</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#172;p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;q</span> <span class="pre">&#8594;</span> <span class="pre">&#172;(p</span> <span class="pre">&#8743;</span> <span class="pre">q)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#172;(p</span> <span class="pre">&#8743;</span> <span class="pre">&#172;p)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">&#172;q</span> <span class="pre">&#8594;</span> <span class="pre">&#172;(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#172;p</span> <span class="pre">&#8594;</span> <span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(&#172;p</span> <span class="pre">&#8744;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">false</span> <span class="pre">&#8596;</span> <span class="pre">p</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">false</span> <span class="pre">&#8596;</span> <span class="pre">false</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#172;(p</span> <span class="pre">&#8596;</span> <span class="pre">&#172;p)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">(&#172;q</span> <span class="pre">&#8594;</span> <span class="pre">&#172;p)</span></code></p></li>
</ol>
<p>These require classical reasoning:</p>
<ol class="arabic simple" start="19">
<li><p><code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">r</span> <span class="pre">&#8744;</span> <span class="pre">s)</span> <span class="pre">&#8594;</span> <span class="pre">((p</span> <span class="pre">&#8594;</span> <span class="pre">r)</span> <span class="pre">&#8744;</span> <span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">s))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#172;(p</span> <span class="pre">&#8743;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">&#172;p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;q</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#172;(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">&#172;q</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">(&#172;p</span> <span class="pre">&#8744;</span> <span class="pre">q)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(&#172;q</span> <span class="pre">&#8594;</span> <span class="pre">&#172;p)</span> <span class="pre">&#8594;</span> <span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;p</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(((p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">p)</span> <span class="pre">&#8594;</span> <span class="pre">p)</span></code></p></li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">sorry</span></code> identifier magically produces a proof of anything, or provides an object of any data type at all. Of course, it is unsound as a proof method &#8211; for example, you can use it to prove <code class="docutils literal notranslate"><span class="pre">false</span></code> &#8211; and Lean produces severe warnings when files use or import theorems which depend on it. But it is very useful for building long proofs incrementally. Start writing the proof from the top down, using <code class="docutils literal notranslate"><span class="pre">sorry</span></code> to fill in subproofs. Make sure Lean accepts the term with all the <code class="docutils literal notranslate"><span class="pre">sorry</span></code>&#8217;s; if not, there are errors that you need to correct. Then go back and replace each <code class="docutils literal notranslate"><span class="pre">sorry</span></code> with an actual proof, until no more remain.</p>
<p>Here is another useful trick. Instead of using <code class="docutils literal notranslate"><span class="pre">sorry</span></code>, you can use an underscore <code class="docutils literal notranslate"><span class="pre">_</span></code> as a placeholder. Recall that this tells Lean that the argument is implicit, and should be filled in automatically. If Lean tries to do so and fails, it returns with an error message &#8220;don&#8217;t know how to synthesize placeholder.&#8221; This is followed by the type of the term it is expecting, and all the objects and hypothesis available in the context. In other words, for each unresolved placeholder, Lean reports the subgoal that needs to be filled at that point. You can then construct a proof by incrementally filling in these placeholders.</p>
<p>For reference, here are two sample proofs of validities taken from the list above.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Avariables%20p%20q%20r%20%3A%20Prop%0A%0A--%20distributivity%0Aexample%20%3A%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r)%20%E2%86%94%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r)%20%3A%3D%0Aiff.intro%0A%20%20(assume%20h%20%3A%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r)%2C%0A%20%20%20%20have%20hp%20%3A%20p%2C%20from%20h.left%2C%0A%20%20%20%20or.elim%20(h.right)%0A%20%20%20%20%20%20(assume%20hq%20%3A%20q%2C%0A%20%20%20%20%20%20%20%20show%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r)%2C%20from%20or.inl%20%E2%9F%A8hp%2C%20hq%E2%9F%A9)%0A%20%20%20%20%20%20(assume%20hr%20%3A%20r%2C%0A%20%20%20%20%20%20%20%20show%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r)%2C%20from%20or.inr%20%E2%9F%A8hp%2C%20hr%E2%9F%A9))%0A%20%20(assume%20h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r)%2C%0A%20%20%20%20or.elim%20h%0A%20%20%20%20%20%20(assume%20hpq%20%3A%20p%20%E2%88%A7%20q%2C%0A%20%20%20%20%20%20%20%20have%20hp%20%3A%20p%2C%20from%20hpq.left%2C%0A%20%20%20%20%20%20%20%20have%20hq%20%3A%20q%2C%20from%20hpq.right%2C%0A%20%20%20%20%20%20%20%20show%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r)%2C%20from%20%E2%9F%A8hp%2C%20or.inl%20hq%E2%9F%A9)%0A%20%20%20%20%20%20(assume%20hpr%20%3A%20p%20%E2%88%A7%20r%2C%0A%20%20%20%20%20%20%20%20have%20hp%20%3A%20p%2C%20from%20hpr.left%2C%0A%20%20%20%20%20%20%20%20have%20hr%20%3A%20r%2C%20from%20hpr.right%2C%0A%20%20%20%20%20%20%20%20show%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r)%2C%20from%20%E2%9F%A8hp%2C%20or.inr%20hr%E2%9F%A9))%0A%0A--%20an%20example%20that%20requires%20classical%20reasoning%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A7%20%C2%ACq)%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%0Aassume%20h%20%3A%20%C2%AC(p%20%E2%88%A7%20%C2%ACq)%2C%0Aassume%20hp%20%3A%20p%2C%0Ashow%20q%2C%20from%0A%20%20or.elim%20(em%20q)%0A%20%20%20%20(assume%20hq%20%3A%20q%2C%20hq)%0A%20%20%20%20(assume%20hnq%20%3A%20%C2%ACq%2C%20absurd%20(and.intro%20hp%20hnq)%20h)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">classical</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="c1">-- distributivity</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">iff.intro</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="o">),</span>
<span class="w">    </span><span class="k">have</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">h.left</span><span class="o">,</span>
<span class="w">    </span><span class="n">or.elim</span><span class="w"> </span><span class="o">(</span><span class="n">h.right</span><span class="o">)</span>
<span class="w">      </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="w">        </span><span class="k">show</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">),</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span><span class="w"> </span><span class="n">hq</span><span class="o">&#10217;)</span>
<span class="w">      </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="o">,</span>
<span class="w">        </span><span class="k">show</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">),</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span><span class="w"> </span><span class="n">hr</span><span class="o">&#10217;))</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">),</span>
<span class="w">    </span><span class="n">or.elim</span><span class="w"> </span><span class="n">h</span>
<span class="w">      </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hpq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="w">        </span><span class="k">have</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">hpq.left</span><span class="o">,</span>
<span class="w">        </span><span class="k">have</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">hpq.right</span><span class="o">,</span>
<span class="w">        </span><span class="k">show</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="o">),</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span><span class="w"> </span><span class="n">or.inl</span><span class="w"> </span><span class="n">hq</span><span class="o">&#10217;)</span>
<span class="w">      </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hpr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">,</span>
<span class="w">        </span><span class="k">have</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">hpr.left</span><span class="o">,</span>
<span class="w">        </span><span class="k">have</span><span class="w"> </span><span class="n">hr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">hpr.right</span><span class="o">,</span>
<span class="w">        </span><span class="k">show</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="o">),</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span><span class="w"> </span><span class="n">or.inr</span><span class="w"> </span><span class="n">hr</span><span class="o">&#10217;))</span>

<span class="c1">-- an example that requires classical reasoning</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="o">),</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span>
<span class="w">  </span><span class="n">or.elim</span><span class="w"> </span><span class="o">(</span><span class="n">em</span><span class="w"> </span><span class="n">q</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="n">hq</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">hnq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="n">absurd</span><span class="w"> </span><span class="o">(</span><span class="n">and.intro</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="n">hnq</span><span class="o">)</span><span class="w"> </span><span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div></section>
<section id="exercises">
<h2><span class="section-number">3.7. </span>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">&#182;</a></h2>
<ol class="arabic">
<li><p>Prove the following identities, replacing the &#8220;sorry&#8221; placeholders with actual proofs.</p>
<blockquote>
<div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A%0A--%20commutativity%20of%20%E2%88%A7%20and%20%E2%88%A8%0Aexample%20%3A%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20%3A%3D%20sorry%0Aexample%20%3A%20p%20%E2%88%A8%20q%20%E2%86%94%20q%20%E2%88%A8%20p%20%3A%3D%20sorry%0A%0A--%20associativity%20of%20%E2%88%A7%20and%20%E2%88%A8%0Aexample%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20%E2%86%94%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%20%3A%3D%20sorry%0Aexample%20%3A%20(p%20%E2%88%A8%20q)%20%E2%88%A8%20r%20%E2%86%94%20p%20%E2%88%A8%20(q%20%E2%88%A8%20r)%20%3A%3D%20sorry%0A%0A--%20distributivity%0Aexample%20%3A%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r)%20%E2%86%94%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r)%20%3A%3D%20sorry%0Aexample%20%3A%20p%20%E2%88%A8%20(q%20%E2%88%A7%20r)%20%E2%86%94%20(p%20%E2%88%A8%20q)%20%E2%88%A7%20(p%20%E2%88%A8%20r)%20%3A%3D%20sorry%0A%0A--%20other%20properties%0Aexample%20%3A%20(p%20%E2%86%92%20(q%20%E2%86%92%20r))%20%E2%86%94%20(p%20%E2%88%A7%20q%20%E2%86%92%20r)%20%3A%3D%20sorry%0Aexample%20%3A%20((p%20%E2%88%A8%20q)%20%E2%86%92%20r)%20%E2%86%94%20(p%20%E2%86%92%20r)%20%E2%88%A7%20(q%20%E2%86%92%20r)%20%3A%3D%20sorry%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A8%20q)%20%E2%86%94%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20%3A%3D%20sorry%0Aexample%20%3A%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%E2%86%92%20%C2%AC(p%20%E2%88%A7%20q)%20%3A%3D%20sorry%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A7%20%C2%ACp)%20%3A%3D%20sorry%0Aexample%20%3A%20p%20%E2%88%A7%20%C2%ACq%20%E2%86%92%20%C2%AC(p%20%E2%86%92%20q)%20%3A%3D%20sorry%0Aexample%20%3A%20%C2%ACp%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%20sorry%0Aexample%20%3A%20(%C2%ACp%20%E2%88%A8%20q)%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%20sorry%0Aexample%20%3A%20p%20%E2%88%A8%20false%20%E2%86%94%20p%20%3A%3D%20sorry%0Aexample%20%3A%20p%20%E2%88%A7%20false%20%E2%86%94%20false%20%3A%3D%20sorry%0Aexample%20%3A%20(p%20%E2%86%92%20q)%20%E2%86%92%20(%C2%ACq%20%E2%86%92%20%C2%ACp)%20%3A%3D%20sorry" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="c1">-- commutativity of &#8743; and &#8744;</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- associativity of &#8743; and &#8744;</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- distributivity</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="c1">-- other properties</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">))</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">((</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="bp">&#8596;</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
</pre></div>
</div>
</div></div></blockquote>
</li>
<li><p>Prove the following identities, replacing the &#8220;sorry&#8221; placeholders with actual proofs. These require classical reasoning.</p>
<blockquote>
<div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20classical%0A%0Avariables%20p%20q%20r%20s%20%3A%20Prop%0A%0Aexample%20%3A%20(p%20%E2%86%92%20r%20%E2%88%A8%20s)%20%E2%86%92%20((p%20%E2%86%92%20r)%20%E2%88%A8%20(p%20%E2%86%92%20s))%20%3A%3D%20sorry%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%3A%3D%20sorry%0Aexample%20%3A%20%C2%AC(p%20%E2%86%92%20q)%20%E2%86%92%20p%20%E2%88%A7%20%C2%ACq%20%3A%3D%20sorry%0Aexample%20%3A%20(p%20%E2%86%92%20q)%20%E2%86%92%20(%C2%ACp%20%E2%88%A8%20q)%20%3A%3D%20sorry%0Aexample%20%3A%20(%C2%ACq%20%E2%86%92%20%C2%ACp)%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%20sorry%0Aexample%20%3A%20p%20%E2%88%A8%20%C2%ACp%20%3A%3D%20sorry%0Aexample%20%3A%20(((p%20%E2%86%92%20q)%20%E2%86%92%20p)%20%E2%86%92%20p)%20%3A%3D%20sorry" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">classical</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">s</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">((</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">s</span><span class="o">))</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="bp">&#172;</span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="bp">&#172;</span><span class="n">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(((</span><span class="n">p</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
</pre></div>
</div>
</div></div></blockquote>
</li>
<li><p>Prove <code class="docutils literal notranslate"><span class="pre">&#172;(p</span> <span class="pre">&#8596;</span> <span class="pre">&#172;p)</span></code> without using classical logic.</p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean 3 (outdated)</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Propositions and Proofs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#propositions-as-types">3.1. Propositions as Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-propositions-as-types">3.2. Working with Propositions as Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#propositional-logic">3.3. Propositional Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introducing-auxiliary-subgoals">3.4. Introducing Auxiliary Subgoals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classical-logic">3.5. Classical Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples-of-propositional-validities">3.6. Examples of Propositional Validities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">3.7. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/propositions_and_proofs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>