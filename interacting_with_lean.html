<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>6. Interacting with Lean &#8212; Theorem Proving in Lean 3 (outdated) 3.23.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=5ca61e87" />
    <script src="_static/documentation_options.js?v=5de50469"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Inductive Types" href="inductive_types.html" />
    <link rel="prev" title="5. Tactics" href="tactics.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="interacting-with-lean">
<span id="id1"></span><h1><span class="section-number">6. </span>Interacting with Lean<a class="headerlink" href="#interacting-with-lean" title="Link to this heading">&#182;</a></h1>
<p>You are now familiar with the fundamentals of dependent type theory, both as a language for defining mathematical objects and a language for constructing proofs. The one thing you are missing is a mechanism for defining new data types. We will fill this gap in the next chapter, which introduces the notion of an <em>inductive data type</em>. But first, in this chapter, we take a break from the mechanics of type theory to explore some pragmatic aspects of interacting with Lean.</p>
<p>Not all of the information found here will be useful to you right away. We recommend skimming this section to get a sense of Lean&#8217;s features, and then returning to it as necessary.</p>
<section id="importing-files">
<span id="id2"></span><h2><span class="section-number">6.1. </span>Importing Files<a class="headerlink" href="#importing-files" title="Link to this heading">&#182;</a></h2>
<p>The goal of Lean&#8217;s front end is to interpret user input, construct formal expressions, and check that they are well formed and type correct. Lean also supports the use of various editors, which provide continuous checking and feedback. More information can be found on the Lean <a class="reference external" href="http://leanprover.github.io/documentation/">documentation pages</a>.</p>
<p>The definitions and theorems in Lean&#8217;s standard library are spread across multiple files. Users may also wish to make use of additional libraries, or develop their own projects across multiple files. When Lean starts, it automatically imports the contents of the library <code class="docutils literal notranslate"><span class="pre">init</span></code> folder, which includes a number of fundamental definitions and constructions. As a result, most of the examples we present here work &#8220;out of the box.&#8221;</p>
<p>If you want to use additional files, however, they need to be imported manually, via an <code class="docutils literal notranslate"><span class="pre">import</span></code> statement at the beginning of a file. The command</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>import foo bar.baz.blah
</pre></div>
</div>
<p>imports the files <code class="docutils literal notranslate"><span class="pre">foo.lean</span></code> and <code class="docutils literal notranslate"><span class="pre">bar/baz/blah.lean</span></code>, where the descriptions are interpreted relative to the Lean <em>search path</em>. Information as to how the search path is determined can be found on the <a class="reference external" href="http://leanprover.github.io/documentation/">documentation pages</a>. By default, it includes the standard library directory, and (in some contexts) the root of the user&#8217;s local project. One can also specify imports relative to the current directory; for example,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>import .foo ..bar.baz
</pre></div>
</div>
<p>tells Lean to import <code class="docutils literal notranslate"><span class="pre">foo.lean</span></code> from the current directory and <code class="docutils literal notranslate"><span class="pre">bar/baz.lean</span></code> relative to the parent of the current directory.</p>
<p>Importing is transitive. In other words, if you import <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">foo</span></code> imports <code class="docutils literal notranslate"><span class="pre">bar</span></code>, then you also have access to the contents of <code class="docutils literal notranslate"><span class="pre">bar</span></code>, and do not need to import it explicitly.</p>
</section>
<section id="more-on-sections">
<h2><span class="section-number">6.2. </span>More on Sections<a class="headerlink" href="#more-on-sections" title="Link to this heading">&#182;</a></h2>
<p>Lean provides various sectioning mechanisms to help structure a theory. We saw in <a class="reference internal" href="dependent_type_theory.html#variables-and-sections"><span class="std std-numref">Section 2.6</span></a> that the <code class="docutils literal notranslate"><span class="pre">section</span></code> command makes it possible not only to group together elements of a theory that go together, but also to declare variables that are inserted as arguments to theorems and definitions, as necessary. Remember that the point of the variable command is to declare variables for use in theorems, as in the following example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Asection%0Avariables%20x%20y%20%3A%20%E2%84%95%0A%0Adef%20double%20%3A%3D%20x%20%2B%20x%0A%0A%23check%20double%20y%0A%23check%20double%20(2%20*%20x)%0A%0Alocal%20attribute%20%5Bsimp%5D%20add_assoc%20add_comm%20add_left_comm%0A%0Atheorem%20t1%20%3A%20double%20(x%20%2B%20y)%20%3D%20double%20x%20%2B%20double%20y%20%3A%3D%0Aby%20simp%20%5Bdouble%5D%0A%0A%23check%20t1%20y%0A%23check%20t1%20(2%20*%20x)%0A%0Atheorem%20t2%20%3A%20double%20(x%20*%20y)%20%3D%20double%20x%20*%20y%20%3A%3D%0Aby%20simp%20%5Bdouble%2C%20add_mul%5D%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">data.nat.basic</span>

<span class="kn">section</span>
<span class="kd">variables</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span>

<span class="kd">def</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">x</span>

<span class="k">#check</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="n">y</span>
<span class="k">#check</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">x</span><span class="o">)</span>

<span class="kn">local</span><span class="w"> </span><span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="n">simp</span><span class="o">]</span><span class="w"> </span><span class="n">add_assoc</span><span class="w"> </span><span class="n">add_comm</span><span class="w"> </span><span class="n">add_left_comm</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">double</span><span class="o">]</span>

<span class="k">#check</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">y</span>
<span class="k">#check</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">x</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">double</span><span class="o">,</span><span class="w"> </span><span class="n">add_mul</span><span class="o">]</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The definition of <code class="docutils literal notranslate"><span class="pre">double</span></code> does not have to declare <code class="docutils literal notranslate"><span class="pre">x</span></code> as an argument; Lean detects the dependence and inserts it automatically. Similarly, Lean detects the occurrence of <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">t1</span></code> and <code class="docutils literal notranslate"><span class="pre">t2</span></code>, and inserts it automatically there, too.</p>
<p>Note that double does <em>not</em> have <code class="docutils literal notranslate"><span class="pre">y</span></code> as argument. Variables are only included in declarations where they are actually mentioned. More precisely, they must be mentioned outside of a tactic block; because variables can appear and can be renamed dynamically in a tactic proof, there is no reliable way of determining when a name used in a tactic proof refers to an element of the context in which the theorem is parsed, and Lean does not try to guess. You can manually ask Lean to include a variable in every definition in a section with the <code class="docutils literal notranslate"><span class="pre">include</span></code> command.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=section%0Avariables%20(x%20y%20z%20%3A%20%E2%84%95)%0Avariables%20(h%E2%82%81%20%3A%20x%20%3D%20y)%20(h%E2%82%82%20%3A%20y%20%3D%20z)%0A%0Ainclude%20h%E2%82%81%20h%E2%82%82%0Atheorem%20foo%20%3A%20x%20%3D%20z%20%3A%3D%0Abegin%0A%20%20rw%20%5Bh%E2%82%81%2C%20h%E2%82%82%5D%0Aend%0Aomit%20h%E2%82%81%20h%E2%82%82%0A%0Atheorem%20bar%20%3A%20x%20%3D%20z%20%3A%3D%0Aeq.trans%20h%E2%82%81%20h%E2%82%82%0A%0Atheorem%20baz%20%3A%20x%20%3D%20x%20%3A%3D%20rfl%0A%0A%23check%20%40foo%0A%23check%20%40bar%0A%23check%20%40baz%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z</span><span class="o">)</span>

<span class="kn">include</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">h&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">]</span>
<span class="kd">end</span>
<span class="kn">omit</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span>
<span class="n">eq.trans</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">foo</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">bar</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">baz</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">omit</span></code> command simply undoes the effect of the <code class="docutils literal notranslate"><span class="pre">include</span></code>. It does not, however, prevent the arguments from being included automatically in subsequent theorems that mention them. The scope of the <code class="docutils literal notranslate"><span class="pre">include</span></code> statement can also be delimited by enclosing it in a section.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=section%0Avariables%20(x%20y%20z%20%3A%20%E2%84%95)%0Avariables%20(h%E2%82%81%20%3A%20x%20%3D%20y)%20(h%E2%82%82%20%3A%20y%20%3D%20z)%0A%0A--%20BEGIN%0Asection%20include_hs%0Ainclude%20h%E2%82%81%20h%E2%82%82%0A%0Atheorem%20foo%20%3A%20x%20%3D%20z%20%3A%3D%0Abegin%0A%20%20rw%20%5Bh%E2%82%81%2C%20h%E2%82%82%5D%0Aend%0A%0Aend%20include_hs%0A--%20END%0A%0Atheorem%20bar%20%3A%20x%20%3D%20z%20%3A%3D%0Aeq.trans%20h%E2%82%81%20h%E2%82%82%0A%0Atheorem%20baz%20%3A%20x%20%3D%20x%20%3A%3D%20rfl%0A%0A%23check%20%40foo%0A%23check%20%40bar%0A%23check%20%40baz%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span><span class="w"> </span><span class="n">include_hs</span>
<span class="kn">include</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">h&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">end</span><span class="w"> </span><span class="n">include_hs</span>
</pre></div>
</div>
</div><p>The include command is often useful with structures that are not mentioned explicitly but meant to be inferred by type class inference, as described in <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a>.</p>
<p>It is often the case that we want to declare section variables as explicit variables but later make them implicit, or vice-versa. One can do this with a <code class="docutils literal notranslate"><span class="pre">variables</span></code> command that mentions these variables with the desired brackets, without repeating the type again. Once again, sections can be used to delimit scope. In the example below, the variables <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> are marked implicit in <code class="docutils literal notranslate"><span class="pre">foo</span></code> but explicit in <code class="docutils literal notranslate"><span class="pre">bar</span></code>, while <code class="docutils literal notranslate"><span class="pre">x</span></code> is (somewhat perversely) marked as implicit in <code class="docutils literal notranslate"><span class="pre">baz</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=section%0Avariables%20(x%20y%20z%20%3A%20%E2%84%95)%0Avariables%20(h%E2%82%81%20%3A%20x%20%3D%20y)%20(h%E2%82%82%20%3A%20y%20%3D%20z)%0A%0Asection%0Avariables%20%7Bx%20y%20z%7D%0Ainclude%20h%E2%82%81%20h%E2%82%82%0Atheorem%20foo%20%3A%20x%20%3D%20z%20%3A%3D%0Abegin%0A%20%20rw%20%5Bh%E2%82%81%2C%20h%E2%82%82%5D%0Aend%0Aend%0A%0Atheorem%20bar%20%3A%20x%20%3D%20z%20%3A%3D%0Aeq.trans%20h%E2%82%81%20h%E2%82%82%0A%0Avariable%20%7Bx%7D%0Atheorem%20baz%20%3A%20x%20%3D%20x%20%3A%3D%20rfl%0A%0A%23check%20%40foo%0A%23check%20%40bar%0A%23check%20%40baz%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="o">}</span>
<span class="kn">include</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">h&#8321;</span><span class="o">,</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">]</span>
<span class="kd">end</span>
<span class="kd">end</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span>
<span class="n">eq.trans</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">foo</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">bar</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">baz</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Using these subsequent <code class="docutils literal notranslate"><span class="pre">variables</span></code> commands does not change the order in which variables are inserted. It only changes the explicit / implicit annotations.</p>
<p>In fact, Lean has two ways of introducing local elements into the sections, namely, as <code class="docutils literal notranslate"><span class="pre">variables</span></code> or as <code class="docutils literal notranslate"><span class="pre">parameters</span></code>. In the initial example in this section, the variable <code class="docutils literal notranslate"><span class="pre">x</span></code> is generalized immediately, so that even within the section <code class="docutils literal notranslate"><span class="pre">double</span></code> is a function of <code class="docutils literal notranslate"><span class="pre">x</span></code>, and <code class="docutils literal notranslate"><span class="pre">t1</span></code> and <code class="docutils literal notranslate"><span class="pre">t2</span></code> depend explicitly on <code class="docutils literal notranslate"><span class="pre">x</span></code>. This is what makes it possible to apply <code class="docutils literal notranslate"><span class="pre">double</span></code> and <code class="docutils literal notranslate"><span class="pre">t1</span></code> to other expressions, like <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span></code>. It corresponds to the ordinary mathematical locution &#8220;in this section, let <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> range over the natural numbers.&#8221; Whenever <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> occur, we assume they denote natural numbers, but we do not assume they refer to the same natural number from theorem to theorem.</p>
<p>Sometimes, however, we wish to <em>fix</em> a value in a section. For example, following ordinary mathematical vernacular, we might say &#8220;in this section, we fix a type, <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, and a binary relation <code class="docutils literal notranslate"><span class="pre">r</span></code> on <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.&#8221; The notion of a <code class="docutils literal notranslate"><span class="pre">parameter</span></code> captures this usage:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=section%0Aparameters%20%7B%CE%B1%20%3A%20Type*%7D%20(r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop)%0Aparameter%20%20transr%20%3A%20%E2%88%80%20%7Bx%20y%20z%7D%2C%20r%20x%20y%20%E2%86%92%20r%20y%20z%20%E2%86%92%20r%20x%20z%0A%0Avariables%20%7Ba%20b%20c%20d%20e%20%3A%20%CE%B1%7D%0A%0Atheorem%20t1%20(h%E2%82%81%20%3A%20r%20a%20b)%20(h%E2%82%82%20%3A%20r%20b%20c)%20(h%E2%82%83%20%3A%20r%20c%20d)%20%3A%20r%20a%20d%20%3A%3D%0Atransr%20(transr%20h%E2%82%81%20h%E2%82%82)%20h%E2%82%83%0A%0Atheorem%20t2%20(h%E2%82%81%20%3A%20r%20a%20b)%20(h%E2%82%82%20%3A%20r%20b%20c)%20(h%E2%82%83%20%3A%20r%20c%20d)%0A%20%20%20%20(h%E2%82%84%20%3A%20r%20d%20e)%20%3A%0A%20%20r%20a%20e%20%3A%3D%0Atransr%20h%E2%82%81%20(t1%20h%E2%82%82%20h%E2%82%83%20h%E2%82%84)%0A%0A%23check%20t1%0A%23check%20t2%0Aend%0A%0A%23check%20t1%0A%23check%20t2" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">parameters</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>
<span class="kd">parameter</span><span class="w">  </span><span class="n">transr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="o">},</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">z</span>

<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8323;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:=</span>
<span class="n">transr</span><span class="w"> </span><span class="o">(</span><span class="n">transr</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">h&#8322;</span><span class="o">)</span><span class="w"> </span><span class="n">h&#8323;</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8323;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="n">h&#8324;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:=</span>
<span class="n">transr</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">(</span><span class="n">t1</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="n">h&#8323;</span><span class="w"> </span><span class="n">h&#8324;</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="n">t1</span>
<span class="k">#check</span><span class="w"> </span><span class="n">t2</span>
<span class="kd">end</span>

<span class="k">#check</span><span class="w"> </span><span class="n">t1</span>
<span class="k">#check</span><span class="w"> </span><span class="n">t2</span>
</pre></div>
</div>
</div><p>As with variables, the parameters <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span></code>, and <code class="docutils literal notranslate"><span class="pre">transr</span></code> are inserted as arguments to definitions and theorems as needed. But there is a difference: within the section, <code class="docutils literal notranslate"><span class="pre">t1</span></code> is an abbreviation for <code class="docutils literal notranslate"><span class="pre">&#64;t1</span> <span class="pre">&#945;</span> <span class="pre">r</span> <span class="pre">transr</span></code>, which is to say, these arguments are held fixed until the section is closed. On the plus side, this means that you do not have to specify the explicit arguments <code class="docutils literal notranslate"><span class="pre">r</span></code> and <code class="docutils literal notranslate"><span class="pre">transr</span></code> when you write <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">h&#8322;</span> <span class="pre">h&#8323;</span> <span class="pre">h&#8324;</span></code>, in contrast to the previous example. But it also means that you cannot specify other arguments in their place. In this example, making <code class="docutils literal notranslate"><span class="pre">r</span></code> a parameter is appropriate if <code class="docutils literal notranslate"><span class="pre">r</span></code> is the only binary relation you want to reason about in the section. In that case, it would make sense to introduce temporary infix notation like <code class="docutils literal notranslate"><span class="pre">&#8828;</span></code> for <code class="docutils literal notranslate"><span class="pre">r</span></code>, and we will see in <a class="reference internal" href="#notation"><span class="std std-numref">Section 6.6</span></a> how to do that. On the other hand, if you want to apply your theorems to arbitrary binary relations within the section, you should make <code class="docutils literal notranslate"><span class="pre">r</span></code> a variable.</p>
</section>
<section id="more-on-namespaces">
<h2><span class="section-number">6.3. </span>More on Namespaces<a class="headerlink" href="#more-on-namespaces" title="Link to this heading">&#182;</a></h2>
<p>In Lean, identifiers are given by hierarchical <em>names</em> like <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. We saw in <a class="reference internal" href="dependent_type_theory.html#namespaces"><span class="std std-numref">Section 2.7</span></a> that Lean provides mechanisms for working with hierarchical names. The command <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">foo</span></code> causes <code class="docutils literal notranslate"><span class="pre">foo</span></code> to be prepended to the name of each definition and theorem until <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">foo</span></code> is encountered. The command <code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">foo</span></code> then creates temporary <em>aliases</em> to definitions and theorems that begin with prefix <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20foo%0Adef%20bar%20%3A%20%E2%84%95%20%3A%3D%201%0Aend%20foo%0A%0Aopen%20foo%0A%0A%23check%20bar%0A%23check%20foo.bar" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">foo</span>
<span class="kd">def</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="kd">end</span><span class="w"> </span><span class="n">foo</span>

<span class="kn">open</span><span class="w"> </span><span class="n">foo</span>

<span class="k">#check</span><span class="w"> </span><span class="n">bar</span>
<span class="k">#check</span><span class="w"> </span><span class="n">foo.bar</span>
</pre></div>
</div>
</div><p>It is not important that the definition of <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> was the result of a <code class="docutils literal notranslate"><span class="pre">namespace</span></code> command:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foo.bar%20%3A%20%E2%84%95%20%3A%3D%201%0A%0Aopen%20foo%0A%0A%23check%20bar%0A%23check%20foo.bar" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">foo.bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>

<span class="kn">open</span><span class="w"> </span><span class="n">foo</span>

<span class="k">#check</span><span class="w"> </span><span class="n">bar</span>
<span class="k">#check</span><span class="w"> </span><span class="n">foo.bar</span>
</pre></div>
</div>
</div><p>Although the names of theorems and definitions have to be unique, the aliases that identify them do not. For example, the standard library defines a theorem <code class="docutils literal notranslate"><span class="pre">add_sub_cancel</span></code>, which asserts <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">-</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span></code> in any additive group. The corresponding theorem on the natural numbers is named <code class="docutils literal notranslate"><span class="pre">nat.add_sub_cancel</span></code>; it is not a special case of <code class="docutils literal notranslate"><span class="pre">add_sub_cancel</span></code>, because the natural numbers do not form a group. When we open the <code class="docutils literal notranslate"><span class="pre">nat</span></code> namespace, the expression <code class="docutils literal notranslate"><span class="pre">add_sub_cancel</span></code> is overloaded, and can refer to either one. Lean tries to use type information to disambiguate the meaning in context, but you can always disambiguate by giving the full name. To that end, the string <code class="docutils literal notranslate"><span class="pre">_root_</span></code> is an explicit description of the empty prefix.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.group.basic%0A%0A%23check%20add_sub_cancel%0A%23check%20nat.add_sub_cancel%0A%23check%20_root_.add_sub_cancel" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">algebra.group.basic</span>

<span class="k">#check</span><span class="w"> </span><span class="n">add_sub_cancel</span>
<span class="k">#check</span><span class="w"> </span><span class="n">nat.add_sub_cancel</span>
<span class="k">#check</span><span class="w"> </span><span class="n">_root_.add_sub_cancel</span>
</pre></div>
</div>
</div><p>We can prevent the shorter alias from being created by using the <code class="docutils literal notranslate"><span class="pre">protected</span></code> keyword:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20foo%0Aprotected%20def%20bar%20%3A%20%E2%84%95%20%3A%3D%201%0Aend%20foo%0A%0Aopen%20foo%0A%0A--%20%23check%20bar%20--%20error%0A%23check%20foo.bar" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">foo</span>
<span class="kn">protected</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="kd">end</span><span class="w"> </span><span class="n">foo</span>

<span class="kn">open</span><span class="w"> </span><span class="n">foo</span>

<span class="c1">-- #check bar -- error</span>
<span class="k">#check</span><span class="w"> </span><span class="n">foo.bar</span>
</pre></div>
</div>
</div><p>This is often used for names like <code class="docutils literal notranslate"><span class="pre">nat.rec</span></code> and <code class="docutils literal notranslate"><span class="pre">nat.rec_on</span></code>, to prevent overloading of common names.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">open</span></code> command admits variations. The command</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%20(succ%20add%20sub)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">sub</span><span class="o">)</span>
</pre></div>
</div>
</div><p>creates aliases for only the identifiers listed. The command</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%20(hiding%20succ%20add%20sub)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">(</span><span class="kn">hiding</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">sub</span><span class="o">)</span>
</pre></div>
</div>
</div><p>creates aliases for everything in the <code class="docutils literal notranslate"><span class="pre">nat</span></code> namespace <em>except</em> the identifiers listed. The command</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%20(renaming%20mul%20%E2%86%92%20times)%20(renaming%20add%20%E2%86%92%20plus)%0A%20%20(hiding%20succ%20sub)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">(</span><span class="kn">renaming</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">times</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="kn">renaming</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">plus</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="kn">hiding</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">sub</span><span class="o">)</span>
</pre></div>
</div>
</div><p>creates aliases for everything in the <code class="docutils literal notranslate"><span class="pre">nat</span></code> namespace except <code class="docutils literal notranslate"><span class="pre">succ</span></code> and <code class="docutils literal notranslate"><span class="pre">sub</span></code>, renaming <code class="docutils literal notranslate"><span class="pre">nat.mul</span></code> to <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">nat.add</span></code> to <code class="docutils literal notranslate"><span class="pre">plus</span></code>.</p>
<p>It is sometimes useful to <code class="docutils literal notranslate"><span class="pre">export</span></code> aliases from one namespace to another, or to the top level. The command</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=export%20nat%20(succ%20add%20sub)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">export</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">sub</span><span class="o">)</span>
</pre></div>
</div>
</div><p>creates aliases for <code class="docutils literal notranslate"><span class="pre">succ</span></code>, <code class="docutils literal notranslate"><span class="pre">add</span></code>, and <code class="docutils literal notranslate"><span class="pre">sub</span></code> in the current namespace, so that whenever the namespace is open, these aliases are available. If this command is used outside a namespace, the aliases are exported to the top level. The <code class="docutils literal notranslate"><span class="pre">export</span></code> command admits all the variations described above.</p>
</section>
<section id="attributes">
<span id="id3"></span><h2><span class="section-number">6.4. </span>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">&#182;</a></h2>
<p>The main function of Lean is to translate user input to formal expressions that are checked by the kernel for correctness and then stored in the environment for later use. But some commands have other effects on the environment, either assigning attributes to objects in the environment, defining notation, or declaring instances of type classes, as described in <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a>. Most of these commands have global effects, which is to say, that they remain in effect not only in the current file, but also in any file that imports it. However, such commands can often be prefixed with the <code class="docutils literal notranslate"><span class="pre">local</span></code> modifier, which indicates that they only have effect until the current <code class="docutils literal notranslate"><span class="pre">section</span></code> or <code class="docutils literal notranslate"><span class="pre">namespace</span></code> is closed, or until the end of the current file.</p>
<p>In <a class="reference internal" href="tactics.html#using-the-simplifier"><span class="std std-numref">Section 5.7</span></a>, we saw that theorems can be annotated with the <code class="docutils literal notranslate"><span class="pre">[simp]</span></code> attribute, which makes them available for use by the simplifier. The following example defines the prefix relation on lists, proves that this relation is reflexive, and assigns the <code class="docutils literal notranslate"><span class="pre">[simp]</span></code> attribute to that theorem.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20is_prefix%20(l%E2%82%81%20%3A%20list%20%CE%B1)%20(l%E2%82%82%20%3A%20list%20%CE%B1)%20%3A%20Prop%20%3A%3D%0A%E2%88%83%20t%2C%20l%E2%82%81%20%2B%2B%20t%20%3D%20l%E2%82%82%0A%0Ainfix%20%60%20%3C%2B%3A%20%60%3A50%20%3A%3D%20is_prefix%0A%0Aattribute%20%5Bsimp%5D%0Atheorem%20list.is_prefix_refl%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%3C%2B%3A%20l%20%3A%3D%0A%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0A%0Aexample%20%3A%20%5B1%2C%202%2C%203%5D%20%3C%2B%3A%20%5B1%2C%202%2C%203%5D%20%3A%3D%20by%20simp" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">def</span><span class="w"> </span><span class="n">is_prefix</span><span class="w"> </span><span class="o">(</span><span class="n">l&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">l&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">&#8707;</span><span class="w"> </span><span class="n">t</span><span class="o">,</span><span class="w"> </span><span class="n">l&#8321;</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">l&#8322;</span>

<span class="kd">infix</span><span class="w"> </span><span class="bp">`</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">is_prefix</span>

<span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">list.is_prefix_refl</span><span class="w"> </span><span class="o">(</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;[],</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span>
</pre></div>
</div>
</div><p>The simplifier then proves <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">&lt;+:</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> by rewriting it to <code class="docutils literal notranslate"><span class="pre">true</span></code>. Lean allows the alternative annotation <code class="docutils literal notranslate"><span class="pre">&#64;[simp]</span></code> before a theorem to assign the attribute:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20is_prefix%20(l%E2%82%81%20%3A%20list%20%CE%B1)%20(l%E2%82%82%20%3A%20list%20%CE%B1)%20%3A%20Prop%20%3A%3D%20%E2%88%83%20t%2C%20l%E2%82%81%20%2B%2B%20t%20%3D%20l%E2%82%82%0A%0Ainfix%20%60%20%3C%2B%3A%20%60%3A50%20%3A%3D%20is_prefix%0A%0A--%20BEGIN%0A%40%5Bsimp%5D%0Atheorem%20list.is_prefix_refl%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%3C%2B%3A%20l%20%3A%3D%0A%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">list.is_prefix_refl</span><span class="w"> </span><span class="o">(</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;[],</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>One can also assign the attribute any time after the definition takes place:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20is_prefix%20(l%E2%82%81%20%3A%20list%20%CE%B1)%20(l%E2%82%82%20%3A%20list%20%CE%B1)%20%3A%20Prop%20%3A%3D%20%E2%88%83%20t%2C%20l%E2%82%81%20%2B%2B%20t%20%3D%20l%E2%82%82%0A%0Ainfix%20%60%20%3C%2B%3A%20%60%3A50%20%3A%3D%20is_prefix%0A%0A--%20BEGIN%0Atheorem%20list.is_prefix_refl%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%3C%2B%3A%20l%20%3A%3D%0A%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0A%0Aattribute%20%5Bsimp%5D%20list.is_prefix_refl%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">list.is_prefix_refl</span><span class="w"> </span><span class="o">(</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;[],</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>

<span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="n">simp</span><span class="o">]</span><span class="w"> </span><span class="n">list.is_prefix_refl</span>
</pre></div>
</div>
</div><p>In all these cases, the attribute remains in effect in any file that imports the one in which the declaration occurs. Adding the <code class="docutils literal notranslate"><span class="pre">local</span></code> modifier restricts the scope:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20is_prefix%20(l%E2%82%81%20%3A%20list%20%CE%B1)%20(l%E2%82%82%20%3A%20list%20%CE%B1)%20%3A%20Prop%20%3A%3D%20%E2%88%83%20t%2C%20l%E2%82%81%20%2B%2B%20t%20%3D%20l%E2%82%82%0A%0Ainfix%20%60%20%3C%2B%3A%20%60%3A50%20%3A%3D%20is_prefix%0A%0A--%20BEGIN%0Asection%0Alocal%20attribute%20%5Bsimp%5D%0Atheorem%20list.is_prefix_refl%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%3C%2B%3A%20l%20%3A%3D%0A%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0A%0Aexample%20%3A%20%5B1%2C%202%2C%203%5D%20%3C%2B%3A%20%5B1%2C%202%2C%203%5D%20%3A%3D%20by%20simp%0Aend%0A%0A--%20error%3A%0A--%20example%20%3A%20%5B1%2C%202%2C%203%5D%20%3C%2B%3A%20%5B1%2C%202%2C%203%5D%20%3A%3D%20by%20simp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kn">local</span><span class="w"> </span><span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">list.is_prefix_refl</span><span class="w"> </span><span class="o">(</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;[],</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span>
<span class="kd">end</span>

<span class="c1">-- error:</span>
<span class="c1">-- example : [1, 2, 3] &lt;+: [1, 2, 3] := by simp</span>
</pre></div>
</div>
</div><p>For another example, we can use the <code class="docutils literal notranslate"><span class="pre">instance</span></code> command to assign the notation <code class="docutils literal notranslate"><span class="pre">&#8804;</span></code> to the <cite>is_prefix</cite> relation. That command, which will be explained in <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a>, works by assigning an <code class="docutils literal notranslate"><span class="pre">[instance]</span></code> attribute to the associated definition.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20is_prefix%20(l%E2%82%81%20%3A%20list%20%CE%B1)%20(l%E2%82%82%20%3A%20list%20%CE%B1)%20%3A%20Prop%20%3A%3D%20%E2%88%83%20t%2C%20l%E2%82%81%20%2B%2B%20t%20%3D%20l%E2%82%82%0A%0A--%20BEGIN%0Ainstance%20list_has_le%20%3A%20has_le%20(list%20%CE%B1)%20%3A%3D%20%E2%9F%A8is_prefix%E2%9F%A9%0A%0Atheorem%20list.is_prefix_refl%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%E2%89%A4%20l%20%3A%3D%0A%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="n">list_has_le</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_le</span><span class="w"> </span><span class="o">(</span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">is_prefix</span><span class="o">&#10217;</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">list.is_prefix_refl</span><span class="w"> </span><span class="o">(</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">&#8804;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;[],</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>That assignment can also be made local:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20is_prefix%20(l%E2%82%81%20%3A%20list%20%CE%B1)%20(l%E2%82%82%20%3A%20list%20%CE%B1)%20%3A%20Prop%20%3A%3D%20%E2%88%83%20t%2C%20l%E2%82%81%20%2B%2B%20t%20%3D%20l%E2%82%82%0A%0A--%20BEGIN%0Adef%20list_has_le%20%3A%20has_le%20(list%20%CE%B1)%20%3A%3D%20%E2%9F%A8is_prefix%E2%9F%A9%0A%0Asection%0Alocal%20attribute%20%5Binstance%5D%20list_has_le%0A%0Atheorem%20foo%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%E2%89%A4%20l%20%3A%3D%20%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0Aend%0A%0A--%20error%3A%0A--%20theorem%20bar%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%E2%89%A4%20l%20%3A%3D%20%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">list_has_le</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_le</span><span class="w"> </span><span class="o">(</span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">is_prefix</span><span class="o">&#10217;</span>

<span class="kn">section</span>
<span class="kn">local</span><span class="w"> </span><span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="kd">instance</span><span class="o">]</span><span class="w"> </span><span class="n">list_has_le</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">(</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">&#8804;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;[],</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>
<span class="kd">end</span>

<span class="c1">-- error:</span>
<span class="c1">-- theorem bar (l : list &#945;) : l &#8804; l := &#10216;[], by simp&#10217;</span>
</pre></div>
</div>
</div><p>For yet another example, the <code class="docutils literal notranslate"><span class="pre">reflexivity</span></code> tactic makes use of objects in the environment that have been tagged with the <code class="docutils literal notranslate"><span class="pre">[refl]</span></code> attribute:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Adef%20is_prefix%20(l%E2%82%81%20%3A%20list%20%CE%B1)%20(l%E2%82%82%20%3A%20list%20%CE%B1)%20%3A%20Prop%20%3A%3D%20%E2%88%83%20t%2C%20l%E2%82%81%20%2B%2B%20t%20%3D%20l%E2%82%82%0A%0Ainfix%20%60%20%3C%2B%3A%20%60%3A50%20%3A%3D%20is_prefix%0A%0A--%20BEGIN%0A%40%5Bsimp%2C%20refl%5D%0Atheorem%20list.is_prefix_refl%20(l%20%3A%20list%20%CE%B1)%20%3A%20l%20%3C%2B%3A%20l%20%3A%3D%0A%E2%9F%A8%5B%5D%2C%20by%20simp%E2%9F%A9%0A%0Aexample%20%3A%20%5B1%2C%202%2C%203%5D%20%3C%2B%3A%20%5B1%2C%202%2C%203%5D%20%3A%3D%20by%20reflexivity%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">@[</span><span class="n">simp</span><span class="o">,</span><span class="w"> </span><span class="n">refl</span><span class="kd">]</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">list.is_prefix_refl</span><span class="w"> </span><span class="o">(</span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;[],</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="bp">&lt;+</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">reflexivity</span>
</pre></div>
</div>
</div><p>The scope of the <code class="docutils literal notranslate"><span class="pre">[refl]</span></code> attribute can similarly be restricted using the <code class="docutils literal notranslate"><span class="pre">local</span></code> modifier, as above.</p>
<p>In <a class="reference internal" href="#notation"><span class="std std-numref">Section 6.6</span></a> below, we will discuss Lean&#8217;s mechanisms for defining notation, and see that they also support the <code class="docutils literal notranslate"><span class="pre">local</span></code> modifier. However, in <a class="reference internal" href="#setting-options"><span class="std std-numref">Section 6.9</span></a>, we will discuss Lean&#8217;s mechanisms for setting options, which does <em>not</em> follow this pattern: options can <em>only</em> be set locally, which is to say, their scope is always restricted to the current section or current file.</p>
</section>
<section id="more-on-implicit-arguments">
<h2><span class="section-number">6.5. </span>More on Implicit Arguments<a class="headerlink" href="#more-on-implicit-arguments" title="Link to this heading">&#182;</a></h2>
<p>In <a class="reference internal" href="dependent_type_theory.html#implicit-arguments"><span class="std std-numref">Section 2.9</span></a>, we saw that if Lean displays the type of a term <code class="docutils literal notranslate"><span class="pre">t</span></code> as <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">{x</span> <span class="pre">:</span> <span class="pre">&#945;},</span> <span class="pre">&#946;</span> <span class="pre">x</span></code>, then the curly brackets indicate that <code class="docutils literal notranslate"><span class="pre">x</span></code> has been marked as an <em>implicit argument</em> to <code class="docutils literal notranslate"><span class="pre">t</span></code>. This means that whenever you write <code class="docutils literal notranslate"><span class="pre">t</span></code>, a placeholder, or &#8220;hole,&#8221; is inserted, so that <code class="docutils literal notranslate"><span class="pre">t</span></code> is replaced by <code class="docutils literal notranslate"><span class="pre">&#64;t</span> <span class="pre">_</span></code>. If you don&#8217;t want that to happen, you have to write <code class="docutils literal notranslate"><span class="pre">&#64;t</span></code> instead.</p>
<p>Notice that implicit arguments are inserted eagerly. Suppose we define a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">&#8469;)</span> <span class="pre">{y</span> <span class="pre">:</span> <span class="pre">&#8469;}</span> <span class="pre">(z</span> <span class="pre">:</span> <span class="pre">&#8469;)</span></code> with the arguments shown. Then, when we write the expression <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">7</span></code> without further arguments, it is parsed as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">7</span> <span class="pre">_</span></code>. Lean offers a weaker annotation, <code class="docutils literal notranslate"><span class="pre">{{y</span> <span class="pre">:</span> <span class="pre">&#8469;}}</span></code>, which specifies that a placeholder should only be added <em>before</em> a subsequent explicit argument. This annotation can also be written using as <code class="docutils literal notranslate"><span class="pre">&#10627;y</span> <span class="pre">:</span> <span class="pre">&#8469;&#10628;</span></code>, where the unicode brackets are entered as <code class="docutils literal notranslate"><span class="pre">\{{</span></code> and <code class="docutils literal notranslate"><span class="pre">\}}</span></code>, respectively. With this annotation, the expression <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">7</span></code> would be parsed as is, whereas <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">7</span> <span class="pre">3</span></code> would be parsed as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">7</span> <span class="pre">_</span> <span class="pre">3</span></code>, just as it would be with the strong annotation.</p>
<p>To illustrate the difference, consider the following example, which shows that a reflexive euclidean relation is both symmetric and transitive.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20BEGIN%0Anamespace%20hidden%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20(r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop)%0A%0Adefinition%20reflexive%20%20%3A%20Prop%20%3A%3D%20%E2%88%80%20(a%20%3A%20%CE%B1)%2C%20r%20a%20a%0Adefinition%20symmetric%20%20%3A%20Prop%20%3A%3D%20%E2%88%80%20%7Ba%20b%20%3A%20%CE%B1%7D%2C%20r%20a%20b%20%E2%86%92%20r%20b%20a%0Adefinition%20transitive%20%3A%20Prop%20%3A%3D%0A%20%20%E2%88%80%20%7Ba%20b%20c%20%3A%20%CE%B1%7D%2C%20r%20a%20b%20%E2%86%92%20r%20b%20c%20%E2%86%92%20r%20a%20c%0Adefinition%20euclidean%20%20%3A%20Prop%20%3A%3D%0A%20%20%E2%88%80%20%7Ba%20b%20c%20%3A%20%CE%B1%7D%2C%20r%20a%20b%20%E2%86%92%20r%20a%20c%20%E2%86%92%20r%20b%20c%0A%0Avariable%20%7Br%7D%0A%0Atheorem%20th1%20(reflr%20%3A%20reflexive%20r)%20(euclr%20%3A%20euclidean%20r)%20%3A%0A%20%20symmetric%20r%20%3A%3D%0Aassume%20a%20b%20%3A%20%CE%B1%2C%20assume%20%3A%20r%20a%20b%2C%0Ashow%20r%20b%20a%2C%20from%20euclr%20this%20(reflr%20_)%0A%0Atheorem%20th2%20(symmr%20%3A%20symmetric%20r)%20(euclr%20%3A%20euclidean%20r)%20%3A%0A%20%20transitive%20r%20%3A%3D%0Aassume%20(a%20b%20c%20%3A%20%CE%B1)%2C%20assume%20(rab%20%3A%20r%20a%20b)%20(rbc%20%3A%20r%20b%20c)%2C%0Aeuclr%20(symmr%20rab)%20rbc%0A%0A--%20error%3A%0A%2F-%0Atheorem%20th3%20(reflr%20%3A%20reflexive%20r)%20(euclr%20%3A%20euclidean%20r)%20%3A%0A%20%20transitive%20r%20%3A%3D%0Ath2%20(th1%20reflr%20euclr)%20euclr%0A-%2F%0A%0Atheorem%20th3%20(reflr%20%3A%20reflexive%20r)%20(euclr%20%3A%20euclidean%20r)%20%3A%0A%20%20transitive%20r%20%3A%3D%0A%40th2%20_%20_%20(%40th1%20_%20_%20reflr%20%40euclr)%20%40euclr%0Aend%20hidden%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">hidden</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>

<span class="kd">definition</span><span class="w"> </span><span class="n">reflexive</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span>
<span class="kd">definition</span><span class="w"> </span><span class="n">symmetric</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">},</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span>
<span class="kd">definition</span><span class="w"> </span><span class="n">transitive</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">},</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span>
<span class="kd">definition</span><span class="w"> </span><span class="n">euclidean</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">},</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">r</span><span class="o">}</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">th1</span><span class="w"> </span><span class="o">(</span><span class="n">reflr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">reflexive</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">euclr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">euclidean</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">symmetric</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="k">assume</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">euclr</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">(</span><span class="n">reflr</span><span class="w"> </span><span class="n">_</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">th2</span><span class="w"> </span><span class="o">(</span><span class="n">symmr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">symmetric</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">euclr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">euclidean</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">transitive</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="k">assume</span><span class="w"> </span><span class="o">(</span><span class="n">rab</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">rbc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">),</span>
<span class="n">euclr</span><span class="w"> </span><span class="o">(</span><span class="n">symmr</span><span class="w"> </span><span class="n">rab</span><span class="o">)</span><span class="w"> </span><span class="n">rbc</span>

<span class="c1">-- error:</span>
<span class="c">/-</span>
<span class="cm">theorem th3 (reflr : reflexive r) (euclr : euclidean r) :</span>
<span class="cm">  transitive r :=</span>
<span class="cm">th2 (th1 reflr euclr) euclr</span>
<span class="cm">-/</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">th3</span><span class="w"> </span><span class="o">(</span><span class="n">reflr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">reflexive</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">euclr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">euclidean</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">transitive</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="bp">@</span><span class="n">th2</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">th1</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">reflr</span><span class="w"> </span><span class="bp">@</span><span class="n">euclr</span><span class="o">)</span><span class="w"> </span><span class="bp">@</span><span class="n">euclr</span>
<span class="kd">end</span><span class="w"> </span><span class="n">hidden</span>
</pre></div>
</div>
</div><p>The results are broken down into small steps: <code class="docutils literal notranslate"><span class="pre">th1</span></code> shows that a relation that is reflexive and euclidean is symmetric, and <code class="docutils literal notranslate"><span class="pre">th2</span></code> shows that a relation that is symmetric and euclidean is transitive. Then <code class="docutils literal notranslate"><span class="pre">th3</span></code> combines the two results. But notice that we have to manually disable the implicit arguments in <code class="docutils literal notranslate"><span class="pre">th1</span></code>, <code class="docutils literal notranslate"><span class="pre">th2</span></code>, and <code class="docutils literal notranslate"><span class="pre">euclr</span></code>, because otherwise too many implicit arguments are inserted. The problem goes away if we use weak implicit arguments:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20(r%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20Prop)%0A%0Adefinition%20reflexive%20%20%3A%20Prop%20%3A%3D%20%E2%88%80%20(a%20%3A%20%CE%B1)%2C%20r%20a%20a%0Adefinition%20symmetric%20%20%3A%20Prop%20%3A%3D%20%E2%88%80%20%E2%A6%83a%20b%20%3A%20%CE%B1%E2%A6%84%2C%20r%20a%20b%20%E2%86%92%20r%20b%20a%0Adefinition%20transitive%20%3A%20Prop%20%3A%3D%0A%20%20%E2%88%80%20%E2%A6%83a%20b%20c%20%3A%20%CE%B1%E2%A6%84%2C%20r%20a%20b%20%E2%86%92%20r%20b%20c%20%E2%86%92%20r%20a%20c%0Adefinition%20euclidean%20%20%3A%20Prop%20%3A%3D%0A%20%20%E2%88%80%20%E2%A6%83a%20b%20c%20%3A%20%CE%B1%E2%A6%84%2C%20r%20a%20b%20%E2%86%92%20r%20a%20c%20%E2%86%92%20r%20b%20c%0A%0Avariable%20%7Br%7D%0A%0Atheorem%20th1%20(reflr%20%3A%20reflexive%20r)%20(euclr%20%3A%20euclidean%20r)%20%3A%0A%20%20symmetric%20r%20%3A%3D%0Aassume%20a%20b%20%3A%20%CE%B1%2C%20assume%20%3A%20r%20a%20b%2C%0Ashow%20r%20b%20a%2C%20from%20euclr%20this%20(reflr%20_)%0A%0Atheorem%20th2%20(symmr%20%3A%20symmetric%20r)%20(euclr%20%3A%20euclidean%20r)%20%3A%0A%20%20transitive%20r%20%3A%3D%0Aassume%20(a%20b%20c%20%3A%20%CE%B1)%2C%20assume%20(rab%20%3A%20r%20a%20b)%20(rbc%20%3A%20r%20b%20c)%2C%0Aeuclr%20(symmr%20rab)%20rbc%0A%0Atheorem%20th3%20(reflr%20%3A%20reflexive%20r)%20(euclr%20%3A%20euclidean%20r)%20%3A%0A%20%20transitive%20r%20%3A%3D%0Ath2%20(th1%20reflr%20euclr)%20euclr%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>

<span class="kd">definition</span><span class="w"> </span><span class="n">reflexive</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span>
<span class="kd">definition</span><span class="w"> </span><span class="n">symmetric</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">&#10627;</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">&#10628;,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span>
<span class="kd">definition</span><span class="w"> </span><span class="n">transitive</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">&#10627;</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">&#10628;,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span>
<span class="kd">definition</span><span class="w"> </span><span class="n">euclidean</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">&#10627;</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">&#10628;,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">r</span><span class="o">}</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">th1</span><span class="w"> </span><span class="o">(</span><span class="n">reflr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">reflexive</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">euclr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">euclidean</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">symmetric</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="k">assume</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">euclr</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">(</span><span class="n">reflr</span><span class="w"> </span><span class="n">_</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">th2</span><span class="w"> </span><span class="o">(</span><span class="n">symmr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">symmetric</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">euclr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">euclidean</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">transitive</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="k">assume</span><span class="w"> </span><span class="o">(</span><span class="n">rab</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">rbc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">),</span>
<span class="n">euclr</span><span class="w"> </span><span class="o">(</span><span class="n">symmr</span><span class="w"> </span><span class="n">rab</span><span class="o">)</span><span class="w"> </span><span class="n">rbc</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">th3</span><span class="w"> </span><span class="o">(</span><span class="n">reflr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">reflexive</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">euclr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">euclidean</span><span class="w"> </span><span class="n">r</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">transitive</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:=</span>
<span class="n">th2</span><span class="w"> </span><span class="o">(</span><span class="n">th1</span><span class="w"> </span><span class="n">reflr</span><span class="w"> </span><span class="n">euclr</span><span class="o">)</span><span class="w"> </span><span class="n">euclr</span>
</pre></div>
</div>
</div><p>There is a third kind of implicit argument that is denoted with square brackets, <code class="docutils literal notranslate"><span class="pre">[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code>. These are used for type classes, as explained in <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a>.</p>
</section>
<section id="notation">
<span id="id4"></span><h2><span class="section-number">6.6. </span>Notation<a class="headerlink" href="#notation" title="Link to this heading">&#182;</a></h2>
<p>Identifiers in Lean can include any alphanumeric characters, including Greek characters (other than &#928; , &#931; , and &#955; , which, as we have seen, have a special meaning in the dependent type theory). They can also include subscripts, which can be entered by typing <code class="docutils literal notranslate"><span class="pre">\_</span></code> followed by the desired subscripted character.</p>
<p>Lean&#8217;s parser is extensible, which is to say, we can define new notation.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=notation%20%60%5B%60%20a%20%60**%60%20b%20%60%5D%60%20%3A%3D%20a%20*%20b%20%2B%201%0A%0Adef%20mul_square%20(a%20b%20%3A%20%E2%84%95)%20%3A%3D%20a%20*%20a%20*%20b%20*%20b%0A%0Ainfix%20(name%20%3A%3D%20mul_square)%20%60%3C*%3E%60%3A50%20%3A%3D%20mul_square%0A%0A%23reduce%20%5B2%20**%203%5D%0A%23reduce%202%20%3C*%3E%203" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">notation</span><span class="w"> </span><span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">`**`</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span>

<span class="kd">def</span><span class="w"> </span><span class="n">mul_square</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span>

<span class="kd">infix</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mul_square</span><span class="o">)</span><span class="w"> </span><span class="bp">`&lt;*&gt;`</span><span class="o">:</span><span class="mi">50</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mul_square</span>

<span class="k">#reduce</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="w"> </span><span class="bp">**</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span>
<span class="k">#reduce</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">&lt;*&gt;</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
</div><p>In this example, the <code class="docutils literal notranslate"><span class="pre">notation</span></code> command defines a complex binary notation for multiplying and adding one. The <code class="docutils literal notranslate"><span class="pre">infix</span></code> command declares a new infix operator, with precedence 50, which associates to the left. (More precisely, the token is given left-binding power 50.) The command <code class="docutils literal notranslate"><span class="pre">infixr</span></code> defines notation which associates to the right, instead.</p>
<p>If you declare these notations in a namespace, the notation is only available when the namespace is open. You can declare temporary notation using the keyword <code class="docutils literal notranslate"><span class="pre">local</span></code>, in which case the notation is available in the current file, and moreover, within the scope of the current <code class="docutils literal notranslate"><span class="pre">namespace</span></code> or <code class="docutils literal notranslate"><span class="pre">section</span></code>, if you are in one.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=local%20notation%20%60%5B%60%20a%20%60**%60%20b%20%60%5D%60%20%3A%3D%20a%20*%20b%20%2B%201%0Alocal%20infix%20%60%3C*%3E%60%3A50%20%3A%3D%20%CE%BB%20a%20b%20%3A%20%E2%84%95%2C%20a%20*%20a%20*%20b%20*%20b" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">local</span><span class="w"> </span><span class="kd">notation</span><span class="w"> </span><span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">`**`</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span>
<span class="kn">local</span><span class="w"> </span><span class="kd">infix</span><span class="w"> </span><span class="bp">`&lt;*&gt;`</span><span class="o">:</span><span class="mi">50</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#955;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
</div><p>Lean&#8217;s core library declares the left-binding powers of a number of common symbols.</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/leanprover/lean/blob/master/library/init/core.lean">https://github.com/leanprover/lean/blob/master/library/init/core.lean</a></p>
</div></blockquote>
<p>You are welcome to overload these symbols for your own use.</p>
<p>You can direct the pretty-printer to suppress notation with the command <code class="docutils literal notranslate"><span class="pre">set_option</span> <span class="pre">pp.notation</span> <span class="pre">false</span></code>. You can also declare notation to be used for input purposes only with the <code class="docutils literal notranslate"><span class="pre">[parsing_only]</span></code> attribute:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=notation%20%5Bparsing_only%5D%20%60%5B%60%20a%20%60**%60%20b%20%60%5D%60%20%3A%3D%20a%20*%20b%20%2B%201%0A%0Avariables%20a%20b%20%3A%20%E2%84%95%0A%23check%20%5Ba%20**%20b%5D" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">notation</span><span class="w"> </span><span class="o">[</span><span class="n">parsing_only</span><span class="o">]</span><span class="w"> </span><span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">`**`</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span>

<span class="kd">variables</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="k">#check</span><span class="w"> </span><span class="o">[</span><span class="n">a</span><span class="w"> </span><span class="bp">**</span><span class="w"> </span><span class="n">b</span><span class="o">]</span>
</pre></div>
</div>
</div><p>The output of the <code class="docutils literal notranslate"><span class="pre">#check</span></code> command displays the expression as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">1</span></code>. Lean also provides mechanisms for iterated notation, such as <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d,</span> <span class="pre">e]</span></code> to denote a list with the indicated elements. See the discussion of <code class="docutils literal notranslate"><span class="pre">list</span></code> in the next chapter for an example.</p>
<p>The possibility of declaring parameters in a section also makes it possible to define local notation that depends on those parameters. In the example below, as long as the parameter <code class="docutils literal notranslate"><span class="pre">m</span></code> is fixed, we can write <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8801;</span> <span class="pre">b</span></code> for equivalence modulo <code class="docutils literal notranslate"><span class="pre">m</span></code>. As soon as the section is closed, however, the dependence on <code class="docutils literal notranslate"><span class="pre">m</span></code> becomes explicit, and the notation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8801;</span> <span class="pre">b</span></code> is no longer valid.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.int.basic%0A%0Anamespace%20int%0A%0Adef%20dvd%20(m%20n%20%3A%20%E2%84%A4)%20%3A%20Prop%20%3A%3D%20%E2%88%83%20k%2C%20n%20%3D%20m%20*%20k%0Ainstance%20%3A%20has_dvd%20int%20%3A%3D%20%E2%9F%A8int.dvd%E2%9F%A9%0A%0A%40%5Bsimp%5D%0Atheorem%20dvd_zero%20(n%20%3A%20%E2%84%A4)%20%3A%20n%20%E2%88%A3%200%20%3A%3D%0A%E2%9F%A80%2C%20by%20simp%E2%9F%A9%0A%0Atheorem%20dvd_intro%20%7Bm%20n%20%3A%20%E2%84%A4%7D%20(k%20%3A%20%E2%84%A4)%20(h%20%3A%20n%20%3D%20m%20*%20k)%20%3A%20m%20%E2%88%A3%20n%20%3A%3D%0A%E2%9F%A8k%2C%20h%E2%9F%A9%0A%0Aend%20int%0A%0Aopen%20int%0A%0Asection%20mod_m%0Aparameter%20(m%20%3A%20%E2%84%A4)%0Avariables%20(a%20b%20c%20%3A%20%E2%84%A4)%0A%0Adefinition%20mod_equiv%20%3A%3D%20(m%20%E2%88%A3%20b%20-%20a)%0A%0Alocal%20infix%20%60%20%E2%89%A1%20%60%3A50%20%3A%3D%20mod_equiv%0A%0Atheorem%20mod_refl%20%3A%20a%20%E2%89%A1%20a%20%3A%3D%0Ashow%20m%20%E2%88%A3%20a%20-%20a%2C%20by%20simp%0A%0Atheorem%20mod_symm%20(h%20%3A%20a%20%E2%89%A1%20b)%20%3A%20b%20%E2%89%A1%20a%20%3A%3D%0Aby%20cases%20h%20with%20c%20hc%3B%20apply%20dvd_intro%20(-c)%3B%20simp%20%5Beq.symm%20hc%5D%0A%0Alocal%20attribute%20%5Bsimp%5D%20add_assoc%20add_comm%20add_left_comm%0A%0Atheorem%20mod_trans%20(h%E2%82%81%20%3A%20a%20%E2%89%A1%20b)%20(h%E2%82%82%20%3A%20b%20%E2%89%A1%20c)%20%3A%20a%20%E2%89%A1%20c%20%3A%3D%0Abegin%0A%20%20cases%20h%E2%82%81%20with%20d%20hd%2C%20cases%20h%E2%82%82%20with%20e%20he%2C%0A%20%20apply%20dvd_intro%20(d%20%2B%20e)%2C%0A%20%20simp%20%5Bmul_add%2C%20eq.symm%20hd%2C%20eq.symm%20he%5D%2C%0Aend%0Aend%20mod_m%0A%0A%23check%20(mod_refl%20%3A%20%E2%88%80%20(m%20a%20%3A%20%E2%84%A4)%2C%20mod_equiv%20m%20a%20a)%0A%0A%23check%20(mod_symm%20%3A%20%E2%88%80%20(m%20a%20b%20%3A%20%E2%84%A4)%2C%20mod_equiv%20m%20a%20b%20%E2%86%92%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20mod_equiv%20m%20b%20a)%0A%0A%23check%20(mod_trans%20%3A%20%20%E2%88%80%20(m%20a%20b%20c%20%3A%20%E2%84%A4)%2C%20mod_equiv%20m%20a%20b%20%E2%86%92%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20mod_equiv%20m%20b%20c%20%E2%86%92%20mod_equiv%20m%20a%20c)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">data.int.basic</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">int</span>

<span class="kd">def</span><span class="w"> </span><span class="n">dvd</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">&#8707;</span><span class="w"> </span><span class="n">k</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">k</span>
<span class="kd">instance</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_dvd</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&#10216;</span><span class="n">int.dvd</span><span class="o">&#10217;</span>

<span class="kd">@[</span><span class="n">simp</span><span class="kd">]</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">dvd_zero</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8739;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="o">&#10217;</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">dvd_intro</span><span class="w"> </span><span class="o">{</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&#8739;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">k</span><span class="o">,</span><span class="w"> </span><span class="n">h</span><span class="o">&#10217;</span>

<span class="kd">end</span><span class="w"> </span><span class="n">int</span>

<span class="kn">open</span><span class="w"> </span><span class="n">int</span>

<span class="kn">section</span><span class="w"> </span><span class="n">mod_m</span>
<span class="kd">parameter</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">)</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">)</span>

<span class="kd">definition</span><span class="w"> </span><span class="n">mod_equiv</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">&#8739;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>

<span class="kn">local</span><span class="w"> </span><span class="kd">infix</span><span class="w"> </span><span class="bp">`</span><span class="w"> </span><span class="bp">&#8801;</span><span class="w"> </span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mod_equiv</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">mod_refl</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8801;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="k">show</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&#8739;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">mod_symm</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8801;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8801;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">cases</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">hc</span><span class="bp">;</span><span class="w"> </span><span class="n">apply</span><span class="w"> </span><span class="n">dvd_intro</span><span class="w"> </span><span class="o">(</span><span class="bp">-</span><span class="n">c</span><span class="o">)</span><span class="bp">;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">eq.symm</span><span class="w"> </span><span class="n">hc</span><span class="o">]</span>

<span class="kn">local</span><span class="w"> </span><span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="n">simp</span><span class="o">]</span><span class="w"> </span><span class="n">add_assoc</span><span class="w"> </span><span class="n">add_comm</span><span class="w"> </span><span class="n">add_left_comm</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">mod_trans</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8801;</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8801;</span><span class="w"> </span><span class="n">c</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8801;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">hd</span><span class="o">,</span><span class="w"> </span><span class="n">cases</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">he</span><span class="o">,</span>
<span class="w">  </span><span class="n">apply</span><span class="w"> </span><span class="n">dvd_intro</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">e</span><span class="o">),</span>
<span class="w">  </span><span class="n">simp</span><span class="w"> </span><span class="o">[</span><span class="n">mul_add</span><span class="o">,</span><span class="w"> </span><span class="n">eq.symm</span><span class="w"> </span><span class="n">hd</span><span class="o">,</span><span class="w"> </span><span class="n">eq.symm</span><span class="w"> </span><span class="n">he</span><span class="o">],</span>
<span class="kd">end</span>
<span class="kd">end</span><span class="w"> </span><span class="n">mod_m</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">mod_refl</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">),</span><span class="w"> </span><span class="n">mod_equiv</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">mod_symm</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">),</span><span class="w"> </span><span class="n">mod_equiv</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span>
<span class="w">                     </span><span class="n">mod_equiv</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="n">mod_trans</span><span class="w"> </span><span class="o">:</span><span class="w">  </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span><span class="o">),</span><span class="w"> </span><span class="n">mod_equiv</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span>
<span class="w">                       </span><span class="n">mod_equiv</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">mod_equiv</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="o">)</span>
</pre></div>
</div>
</div></section>
<section id="coercions">
<h2><span class="section-number">6.7. </span>Coercions<a class="headerlink" href="#coercions" title="Link to this heading">&#182;</a></h2>
<p>In Lean, the type of natural numbers, <code class="docutils literal notranslate"><span class="pre">nat</span></code>, is different from the type of integers, <code class="docutils literal notranslate"><span class="pre">int</span></code>. But there is a function <code class="docutils literal notranslate"><span class="pre">int.of_nat</span></code> that embeds the natural numbers in the integers, meaning that we can view any natural number as an integer, when needed. Lean has mechanisms to detect and insert <em>coercions</em> of this sort.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20m%20n%20%3A%20%E2%84%95%0Avariables%20i%20j%20%3A%20%E2%84%A4%0A%0A%23check%20i%20%2B%20m%20%20%20%20%20%20--%20i%20%2B%20%E2%86%91m%20%3A%20%E2%84%A4%0A%23check%20i%20%2B%20m%20%2B%20j%20%20--%20i%20%2B%20%E2%86%91m%20%2B%20j%20%3A%20%E2%84%A4%0A%23check%20i%20%2B%20m%20%2B%20n%20%20--%20i%20%2B%20%E2%86%91m%20%2B%20%E2%86%91n%20%3A%20%E2%84%A4" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span>
<span class="kd">variables</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8484;</span>

<span class="k">#check</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w">      </span><span class="c1">-- i + &#8593;m : &#8484;</span>
<span class="k">#check</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">j</span><span class="w">  </span><span class="c1">-- i + &#8593;m + j : &#8484;</span>
<span class="k">#check</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w">  </span><span class="c1">-- i + &#8593;m + &#8593;n : &#8484;</span>
</pre></div>
</div>
</div><p>Notice that the output of the <code class="docutils literal notranslate"><span class="pre">#check</span></code> command shows that a coercion has been inserted by printing an arrow. The latter is notation for the function <code class="docutils literal notranslate"><span class="pre">coe</span></code>; you can type the unicode arrow with <code class="docutils literal notranslate"><span class="pre">\u</span></code> or use <code class="docutils literal notranslate"><span class="pre">coe</span></code> instead. In fact, when the order of arguments is different, you have to insert the coercion manually, because Lean does not recognize the need for a coercion until it has already parsed the earlier arguments.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20m%20n%20%3A%20%E2%84%95%0Avariables%20i%20j%20%3A%20%E2%84%A4%0A%0A--%20BEGIN%0A%23check%20%E2%86%91m%20%2B%20i%20%20%20%20%20%20%20%20--%20%E2%86%91m%20%2B%20i%20%3A%20%E2%84%A4%0A%23check%20%E2%86%91(m%20%2B%20n)%20%2B%20i%20%20--%20%E2%86%91(m%20%2B%20n)%20%2B%20i%20%3A%20%E2%84%A4%0A%23check%20%E2%86%91m%20%2B%20%E2%86%91n%20%2B%20i%20%20%20--%20%E2%86%91m%20%2B%20%E2%86%91n%20%2B%20i%20%3A%20%E2%84%A4%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="bp">&#8593;</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">i</span><span class="w">        </span><span class="c1">-- &#8593;m + i : &#8484;</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">&#8593;</span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">i</span><span class="w">  </span><span class="c1">-- &#8593;(m + n) + i : &#8484;</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">&#8593;</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">&#8593;</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">i</span><span class="w">   </span><span class="c1">-- &#8593;m + &#8593;n + i : &#8484;</span>
</pre></div>
</div>
</div><p>In fact, Lean allows various kinds of coercions using type classes; for details, see <a class="reference internal" href="type_classes.html#coercions-using-type-classes"><span class="std std-numref">Section 10.6</span></a>.</p>
</section>
<section id="displaying-information">
<h2><span class="section-number">6.8. </span>Displaying Information<a class="headerlink" href="#displaying-information" title="Link to this heading">&#182;</a></h2>
<p>There are a number of ways in which you can query Lean for information about its current state and the objects and theorems that are available in the current context. You have already seen two of the most common ones, <code class="docutils literal notranslate"><span class="pre">#check</span></code> and <code class="docutils literal notranslate"><span class="pre">#reduce</span></code>. Remember that <code class="docutils literal notranslate"><span class="pre">#check</span></code> is often used in conjunction with the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator, which makes all of the arguments to a theorem or definition explicit. In addition, you can use the <code class="docutils literal notranslate"><span class="pre">#print</span></code> command to get information about any identifier. If the identifier denotes a definition or theorem, Lean prints the type of the symbol, and its definition. If it is a constant or an axiom, Lean indicates that fact, and shows the type.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20examples%20with%20equality%0A%23check%20eq%0A%23check%20%40eq%0A%23check%20eq.symm%0A%23check%20%40eq.symm%0A%0A%23print%20eq.symm%0A%0A--%20examples%20with%20and%0A%23check%20and%0A%23check%20and.intro%0A%23check%20%40and.intro%0A%0A--%20a%20user-defined%20function%0Adef%20foo%20%7B%CE%B1%20%3A%20Type*%7D%20(x%20%3A%20%CE%B1)%20%3A%20%CE%B1%20%3A%3D%20x%0A%0A%23check%20foo%0A%23check%20%40foo%0A%23reduce%20foo%0A%23reduce%20(foo%20nat.zero)%0A%23print%20foo" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- examples with equality</span>
<span class="k">#check</span><span class="w"> </span><span class="n">eq</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">eq</span>
<span class="k">#check</span><span class="w"> </span><span class="n">eq.symm</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">eq.symm</span>

<span class="k">#print</span><span class="w"> </span><span class="n">eq.symm</span>

<span class="c1">-- examples with and</span>
<span class="k">#check</span><span class="w"> </span><span class="n">and</span>
<span class="k">#check</span><span class="w"> </span><span class="n">and.intro</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">and.intro</span>

<span class="c1">-- a user-defined function</span>
<span class="kd">def</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span>

<span class="k">#check</span><span class="w"> </span><span class="n">foo</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">foo</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">foo</span>
<span class="k">#reduce</span><span class="w"> </span><span class="o">(</span><span class="n">foo</span><span class="w"> </span><span class="n">nat.zero</span><span class="o">)</span>
<span class="k">#print</span><span class="w"> </span><span class="n">foo</span>
</pre></div>
</div>
</div><p>There are other useful <code class="docutils literal notranslate"><span class="pre">#print</span></code> commands:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#print definition             : display definition
#print inductive              : display an inductive type and its constructors
#print notation               : display all notation
#print notation &lt;tokens&gt;      : display notation using any of the tokens
#print axioms                 : display assumed axioms
#print options                : display options set by user
#print prefix &lt;namespace&gt;     : display all declarations in the namespace
#print classes                : display all classes
#print instances &lt;class name&gt; : display all instances of the given class
#print fields &lt;structure&gt;     : display all fields of a structure
</pre></div>
</div>
<p>We will discuss inductive types, structures, classes, instances in the next four chapters. Here are examples of how these commands are used:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.ring.basic%0A%0A%23print%20notation%0A%23print%20notation%20%2B%20*%20-%0A%23print%20axioms%0A%23print%20options%0A%23print%20prefix%20nat%0A%23print%20prefix%20nat.le%0A%23print%20classes%0A%23print%20instances%20ring%0A%23print%20fields%20ring" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">algebra.ring.basic</span>

<span class="k">#print</span><span class="w"> </span><span class="kd">notation</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">notation</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="bp">-</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">axioms</span>
<span class="k">#print</span><span class="w"> </span><span class="n">options</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">prefix</span><span class="w"> </span><span class="n">nat</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">prefix</span><span class="w"> </span><span class="n">nat.le</span>
<span class="k">#print</span><span class="w"> </span><span class="n">classes</span>
<span class="k">#print</span><span class="w"> </span><span class="n">instances</span><span class="w"> </span><span class="n">ring</span>
<span class="k">#print</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="n">ring</span>
</pre></div>
</div>
</div><p>The behavior of the generic print command is determined by its argument, so that the following pairs of commands all do the same thing.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.group%0A%0A%23print%20list.append%0A%23print%20definition%20list.append%0A%0A%23print%20%2B%0A%23print%20notation%20%2B%0A%0A%23print%20nat%0A%23print%20inductive%20nat%0A%0A%23print%20group%0A%23print%20inductive%20group" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">algebra.group</span>

<span class="k">#print</span><span class="w"> </span><span class="n">list.append</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">definition</span><span class="w"> </span><span class="n">list.append</span>

<span class="k">#print</span><span class="w"> </span><span class="bp">+</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">notation</span><span class="w"> </span><span class="bp">+</span>

<span class="k">#print</span><span class="w"> </span><span class="n">nat</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">nat</span>

<span class="k">#print</span><span class="w"> </span><span class="n">group</span>
<span class="k">#print</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">group</span>
</pre></div>
</div>
</div><p>Moreover, both <code class="docutils literal notranslate"><span class="pre">#print</span> <span class="pre">group</span></code> and <code class="docutils literal notranslate"><span class="pre">#print</span> <span class="pre">inductive</span> <span class="pre">group</span></code> recognize that a group is a structure (see <a class="reference internal" href="structures_and_records.html#structures-and-records"><span class="std std-numref">Chapter 9</span></a>), and so print the fields as well.</p>
</section>
<section id="setting-options">
<span id="id5"></span><h2><span class="section-number">6.9. </span>Setting Options<a class="headerlink" href="#setting-options" title="Link to this heading">&#182;</a></h2>
<p>Lean maintains a number of internal variables that can be set by users to control its behavior. The syntax for doing so is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>set_option &lt;name&gt; &lt;value&gt;
</pre></div>
</div>
<p>One very useful family of options controls the way Lean&#8217;s <em>pretty- printer</em> displays terms. The following options take an input of true or false:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>pp.implicit  : display implicit arguments
pp.universes : display hidden universe parameters
pp.coercions : show coercions
pp.notation  : display output using defined notations
pp.beta      : beta reduce terms before displaying them
</pre></div>
</div>
<p>As an example, the following settings yield much longer output:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=set_option%20pp.implicit%20true%0Aset_option%20pp.universes%20true%0Aset_option%20pp.notation%20false%0Aset_option%20pp.numerals%20false%0A%0A%23check%202%20%2B%202%20%3D%204%0A%23reduce%20(%CE%BB%20x%2C%20x%20%2B%202)%20%3D%20(%CE%BB%20x%2C%20x%20%2B%203)%0A%23check%20(%CE%BB%20x%2C%20x%20%2B%201)%201" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">set_option</span><span class="w"> </span><span class="n">pp.implicit</span><span class="w"> </span><span class="n">true</span>
<span class="kd">set_option</span><span class="w"> </span><span class="n">pp.universes</span><span class="w"> </span><span class="n">true</span>
<span class="kd">set_option</span><span class="w"> </span><span class="n">pp.notation</span><span class="w"> </span><span class="n">false</span>
<span class="kd">set_option</span><span class="w"> </span><span class="n">pp.numerals</span><span class="w"> </span><span class="n">false</span>

<span class="k">#check</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">4</span>
<span class="k">#reduce</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</div><p>The command <code class="docutils literal notranslate"><span class="pre">set_option</span> <span class="pre">pp.all</span> <span class="pre">true</span></code> carries out these settings all at once, whereas <code class="docutils literal notranslate"><span class="pre">set_option</span> <span class="pre">pp.all</span> <span class="pre">false</span></code> reverts to the previous values. Pretty printing additional information is often very useful when you are debugging a proof, or trying to understand a cryptic error message. Too much information can be overwhelming, though, and Lean&#8217;s defaults are generally sufficient for ordinary interactions.</p>
<p>By default, the pretty-printer does not reduce applied lambda-expressions, but this is sometimes useful. The <code class="docutils literal notranslate"><span class="pre">pp.beta</span></code> option controls this feature.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=set_option%20pp.beta%20true%0A%23check%20(%CE%BB%20x%2C%20x%20%2B%201)%201" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">set_option</span><span class="w"> </span><span class="n">pp.beta</span><span class="w"> </span><span class="n">true</span>
<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</div></section>
<section id="elaboration-hints">
<span id="id6"></span><h2><span class="section-number">6.10. </span>Elaboration Hints<a class="headerlink" href="#elaboration-hints" title="Link to this heading">&#182;</a></h2>
<p>When you ask Lean to process an expression like <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z,</span> <span class="pre">f</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">z</span></code>, you are leaving information implicit. For example, the types of <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> have to be inferred from the context, the notation <code class="docutils literal notranslate"><span class="pre">+</span></code> may be overloaded, and there may be implicit arguments to <code class="docutils literal notranslate"><span class="pre">f</span></code> that need to be filled in as well. Moreover, we will see in <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a> that some implicit arguments are synthesized by a process known as <em>type class resolution</em>. And we have also already seen in the last chapter that some parts of an expression can be constructed by the tactic framework.</p>
<p>Inferring some implicit arguments is straightforward. For example, suppose a function <code class="docutils literal notranslate"><span class="pre">f</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">{&#945;</span> <span class="pre">:</span> <span class="pre">Type*},</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#945;</span></code> and Lean is trying to parse the expression <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">n</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> can be inferred to have type <code class="docutils literal notranslate"><span class="pre">nat</span></code>. Then it is clear that the implicit argument <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> has to be <code class="docutils literal notranslate"><span class="pre">nat</span></code>. However, some inference problems are <em>higher order</em>. For example, the substitution operation for equality, <code class="docutils literal notranslate"><span class="pre">eq.subst</span></code>, has the following type:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>eq.subst : &#8704; {&#945; : Sort u} {p : &#945; &#8594; Prop} {a b : &#945;},
             a = b &#8594; p a &#8594; p b
</pre></div>
</div>
<p>Now suppose we are given <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code> and <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">h&#8322;</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">a</span></code>. Then, in the expression <code class="docutils literal notranslate"><span class="pre">eq.subst</span> <span class="pre">h&#8321;</span> <span class="pre">h&#8322;</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span></code> could be any of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">a</span></code></p></li>
</ul>
<p>In other words, our intent may be to replace either the first or second <code class="docutils literal notranslate"><span class="pre">a</span></code> in <code class="docutils literal notranslate"><span class="pre">h&#8322;</span></code>, or both, or neither. Similar ambiguities arise in inferring induction predicates, or inferring function arguments. Even second-order unification is known to be undecidable. Lean therefore relies on heuristics to fill in such arguments, and when it fails to guess the right ones, they need to be provided explicitly.</p>
<p>To make matters worse, sometimes definitions need to be unfolded, and sometimes expressions need to be reduced according to the computational rules of the underlying logical framework. Once again, Lean has to rely on heuristics to determine what to unfold or reduce, and when.</p>
<p>There are attributes, however, that can be used to provide hints to the elaborator. One class of attributes determines how eagerly definitions are unfolded: constants can be marked with the attribute <code class="docutils literal notranslate"><span class="pre">[reducible]</span></code>, <code class="docutils literal notranslate"><span class="pre">[semireducible]</span></code>, or <code class="docutils literal notranslate"><span class="pre">[irreducible]</span></code>. Definitions are marked <code class="docutils literal notranslate"><span class="pre">[semireducible]</span></code> by default. A definition with the <code class="docutils literal notranslate"><span class="pre">[reducible]</span></code> attribute is unfolded eagerly; if you think of a definition as serving as an abbreviation, this attribute would be appropriate. The elaborator avoids unfolding definitions with the <code class="docutils literal notranslate"><span class="pre">[irreducible]</span></code> attribute. Theorems are marked <code class="docutils literal notranslate"><span class="pre">[irreducible]</span></code> by default, because typically proofs are not relevant to the elaboration process.</p>
<p>It is worth emphasizing that these attributes are only hints to the elaborator. When checking an elaborated term for correctness, Lean&#8217;s kernel will unfold whatever definitions it needs to unfold. As with other attributes, the ones above can be assigned with the <code class="docutils literal notranslate"><span class="pre">local</span></code> modifier, so that they are in effect only in the current section or file.</p>
<p>Lean also has a family of attributes that control the elaboration strategy. A definition or theorem can be marked <code class="docutils literal notranslate"><span class="pre">[elab_with_expected_type]</span></code>, <code class="docutils literal notranslate"><span class="pre">[elab_simple]</span></code>. or <code class="docutils literal notranslate"><span class="pre">[elab_as_eliminator]</span></code>. When applied to a definition <code class="docutils literal notranslate"><span class="pre">f</span></code>, these bear on elaboration of an expression <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span> <span class="pre">...</span></code> in which <code class="docutils literal notranslate"><span class="pre">f</span></code> is applied to arguments. With the default attribute, <code class="docutils literal notranslate"><span class="pre">[elab_with_expected_type]</span></code>, the arguments <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, &#8230; are elaborating using information about their expected type, inferred from <code class="docutils literal notranslate"><span class="pre">f</span></code> and the previous arguments. In contrast, with <code class="docutils literal notranslate"><span class="pre">[elab_simple]</span></code>, the arguments are elaborated from left to right without propagating information about their types. The last attribute, <code class="docutils literal notranslate"><span class="pre">[elab_as_eliminator]</span></code>, is commonly used for eliminators like recursors, induction principles, and <code class="docutils literal notranslate"><span class="pre">eq.subst</span></code>. It uses a separate heuristic to infer higher-order parameters. We will consider such operations in more detail in the next chapter.</p>
<p>Once again, these attributes can be assigned and reassigned after an object is defined, and you can use the <code class="docutils literal notranslate"><span class="pre">local</span></code> modifier to limit their scope. Moreover, using the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> symbol in front of an identifier in an expression instructs the elaborator to use the <code class="docutils literal notranslate"><span class="pre">[elab_simple]</span></code> strategy; the idea is that, when you provide the tricky parameters explicitly, you want the elaborator to weigh that information heavily. In fact, Lean offers an alternative annotation, <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>, which leaves parameters before the first higher-order parameter implicit. For example, <code class="docutils literal notranslate"><span class="pre">&#64;&#64;eq.subst</span></code> leaves the type of the equation implicit, but makes the context of the substitution explicit.</p>
</section>
<section id="using-the-library">
<h2><span class="section-number">6.11. </span>Using the Library<a class="headerlink" href="#using-the-library" title="Link to this heading">&#182;</a></h2>
<p>To use Lean effectively you will inevitably need to make use of definitions and theorems in the library. Recall that the <code class="docutils literal notranslate"><span class="pre">import</span></code> command at the beginning of a file imports previously compiled results from other files, and that importing is transitive; if you import <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">foo</span></code> imports <code class="docutils literal notranslate"><span class="pre">bar</span></code>, then the definitions and theorems from <code class="docutils literal notranslate"><span class="pre">bar</span></code> are available to you as well. But the act of opening a namespace, which provides shorter names, does not carry over. In each file, you need to open the namespaces you wish to use.</p>
<p>In general, it is important for you to be familiar with the library and its contents, so you know what theorems, definitions, notations, and resources are available to you. Below we will see that Lean&#8217;s editor modes can also help you find things you need, but studying the contents of the library directly is often unavoidable. Lean&#8217;s standard library can be found online, on github:</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/leanprover/lean/tree/master/library">https://github.com/leanprover/lean/tree/master/library</a></p>
</div></blockquote>
<p>You can see the contents of the directories and files using github&#8217;s browser interface. If you have installed Lean on your own computer, you can find the library in the <code class="docutils literal notranslate"><span class="pre">lean</span></code> folder, and explore it with your file manager. Comment headers at the top of each file provide additional information.</p>
<p>Lean&#8217;s library developers follow general naming guidelines to make it easier to guess the name of a theorem you need, or to find it using tab completion in editors with a Lean mode that supports this, which is discussed in the next section. Identifiers are generally <code class="docutils literal notranslate"><span class="pre">snake_case</span></code>, which is to say, they are composed of words written in lower case separated by underscores. For the most part, we rely on descriptive names. Often the name of theorem simply describes the conclusion:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Aopen%20nat%0A%0A%23check%20succ_ne_zero%0A%23check%20%40mul_zero%0A%23check%20%40mul_one%0A%23check%20%40sub_add_eq_add_sub%0A%23check%20%40le_iff_lt_or_eq" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">data.nat.basic</span>

<span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="k">#check</span><span class="w"> </span><span class="n">succ_ne_zero</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">mul_zero</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">mul_one</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">sub_add_eq_add_sub</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">le_iff_lt_or_eq</span>
</pre></div>
</div>
</div><p>If only a prefix of the description is enough to convey the meaning, the name may be made even shorter:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Aopen%20nat%0A%0A--%20BEGIN%0A%23check%20%40neg_neg%0A%23check%20pred_succ%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">neg_neg</span>
<span class="k">#check</span><span class="w"> </span><span class="n">pred_succ</span>
</pre></div>
</div>
</div><p>Sometimes, to disambiguate the name of theorem or better convey the intended reference, it is necessary to describe some of the hypotheses. The word &#8220;of&#8221; is used to separate these hypotheses:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.order.monoid.lemmas%0A%0A%23check%20%40nat.lt_of_succ_le%0A%23check%20%40lt_of_not_ge%0A%23check%20%40lt_of_le_of_ne%0A%23check%20%40add_lt_add_of_lt_of_le" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">algebra.order.monoid.lemmas</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">nat.lt_of_succ_le</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">lt_of_not_ge</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">lt_of_le_of_ne</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">add_lt_add_of_lt_of_le</span>
</pre></div>
</div>
</div><p>Sometimes the word &#8220;left&#8221; or &#8220;right&#8221; is helpful to describe variants of a theorem.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.order.monoid.lemmas%0A%0A%23check%20%40add_le_add_left%0A%23check%20%40add_le_add_right" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">algebra.order.monoid.lemmas</span>

<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">add_le_add_left</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">add_le_add_right</span>
</pre></div>
</div>
</div><p>We can also use the word &#8220;self&#8221; to indicate a repeated argument:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.group.basic%0A%0A%23check%20mul_inv_self%0A%23check%20neg_add_self" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="n">algebra.group.basic</span>

<span class="k">#check</span><span class="w"> </span><span class="n">mul_inv_self</span>
<span class="k">#check</span><span class="w"> </span><span class="n">neg_add_self</span>
</pre></div>
</div>
</div><p>Remember that identifiers in Lean can be organized into hierarchical namespaces. For example, the theorem named <code class="docutils literal notranslate"><span class="pre">lt_of_succ_le</span></code> in the namespace <code class="docutils literal notranslate"><span class="pre">nat</span></code> has full name <code class="docutils literal notranslate"><span class="pre">nat.lt_of_succ_le</span></code>, but the shorter name is made available by the command <code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">nat</span></code>. We will see in <a class="reference internal" href="inductive_types.html#inductive-types"><span class="std std-numref">Chapter 7</span></a> and <a class="reference internal" href="structures_and_records.html#structures-and-records"><span class="std std-numref">Chapter 9</span></a> that defining structures and inductive data types in Lean generates associated operations, and these are stored in a namespace with the same name as the type under definition. For example, the product type comes with the following operations:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40prod.mk%0A%23check%20%40prod.fst%0A%23check%20%40prod.snd%0A%23check%20%40prod.rec" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">prod.mk</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">prod.fst</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">prod.snd</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">prod.rec</span>
</pre></div>
</div>
</div><p>The first is used to construct a pair, whereas the next two, <code class="docutils literal notranslate"><span class="pre">prod.fst</span></code> and <code class="docutils literal notranslate"><span class="pre">prod.snd</span></code>, project the two elements. The last, <code class="docutils literal notranslate"><span class="pre">prod.rec</span></code>, provides another mechanism for defining functions on a product in terms of a function on the two components. Names like <code class="docutils literal notranslate"><span class="pre">prod.rec</span></code> are <em>protected</em>, which means that one has to use the full name even when the <code class="docutils literal notranslate"><span class="pre">prod</span></code> namespace is open.</p>
<p>With the propositions as types correspondence, logical connectives are also instances of inductive types, and so we tend to use dot notation for them as well:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40and.intro%0A%23check%20%40and.elim%0A%23check%20%40and.left%0A%23check%20%40and.right%0A%23check%20%40or.inl%0A%23check%20%40or.inr%0A%23check%20%40or.elim%0A%23check%20%40exists.intro%0A%23check%20%40exists.elim%0A%23check%20%40eq.refl%0A%23check%20%40eq.subst" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">and.intro</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">and.elim</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">and.left</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">and.right</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">or.inl</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">or.inr</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">or.elim</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">exists.intro</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">exists.elim</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">eq.refl</span>
<span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">eq.subst</span>
</pre></div>
</div>
</div></section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean 3 (outdated)</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositions_and_proofs.html">3. Propositions and Proofs</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Interacting with Lean</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#importing-files">6.1. Importing Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-on-sections">6.2. More on Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-on-namespaces">6.3. More on Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#attributes">6.4. Attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-on-implicit-arguments">6.5. More on Implicit Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#notation">6.6. Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coercions">6.7. Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#displaying-information">6.8. Displaying Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-options">6.9. Setting Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="#elaboration-hints">6.10. Elaboration Hints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-library">6.11. Using the Library</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/interacting_with_lean.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>