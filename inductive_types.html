<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>7. Inductive Types &#8212; Theorem Proving in Lean 3 (outdated) 3.23.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=5ca61e87" />
    <script src="_static/documentation_options.js?v=5de50469"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="8. Induction and Recursion" href="induction_and_recursion.html" />
    <link rel="prev" title="6. Interacting with Lean" href="interacting_with_lean.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="inductive-types">
<span id="id1"></span><h1><span class="section-number">7. </span>Inductive Types<a class="headerlink" href="#inductive-types" title="Link to this heading">&#182;</a></h1>
<p>We have seen that Lean&#8217;s formal foundation includes basic types, <code class="docutils literal notranslate"><span class="pre">Prop,</span> <span class="pre">Type</span> <span class="pre">0,</span> <span class="pre">Type</span> <span class="pre">1,</span> <span class="pre">Type</span> <span class="pre">2,</span> <span class="pre">...</span></code>, and allows for the formation of dependent function types, <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">&#946;</span></code>. In the examples, we have also made use of additional types like <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">nat</span></code>, and <code class="docutils literal notranslate"><span class="pre">int</span></code>, and type constructors, like <code class="docutils literal notranslate"><span class="pre">list</span></code>, and product, <code class="docutils literal notranslate"><span class="pre">&#215;</span></code>. In fact, in Lean&#8217;s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as <em>inductive types</em>. It is remarkable that it is possible to construct a substantial edifice of mathematics based on nothing more than the type universes, Pi types, and inductive types; everything else follows from those.</p>
<p>Intuitively, an inductive type is built up from a specified list of constructors. In Lean, the syntax for specifying such a type is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>inductive foo : Sort u
| constructor&#8321; : ... &#8594; foo
| constructor&#8322; : ... &#8594; foo
...
| constructor&#8345; : ... &#8594; foo
</pre></div>
</div>
<p>The intuition is that each constructor specifies a way of building new objects of <code class="docutils literal notranslate"><span class="pre">foo</span></code>, possibly from previously constructed values. The type <code class="docutils literal notranslate"><span class="pre">foo</span></code> consists of nothing more than the objects that are constructed in this way. The first character <code class="docutils literal notranslate"><span class="pre">|</span></code> in an inductive declaration is optional. We can also separate constructors using a comma instead of <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
<p>We will see below that the arguments to the constructors can include objects of type <code class="docutils literal notranslate"><span class="pre">foo</span></code>, subject to a certain &#8220;positivity&#8221; constraint, which guarantees that elements of <code class="docutils literal notranslate"><span class="pre">foo</span></code> are built from the bottom up. Roughly speaking, each <code class="docutils literal notranslate"><span class="pre">...</span></code> can be any Pi type constructed from <code class="docutils literal notranslate"><span class="pre">foo</span></code> and previously defined types, in which <code class="docutils literal notranslate"><span class="pre">foo</span></code> appears, if at all, only as the &#8220;target&#8221; of the Pi type. For more details, see <a class="reference internal" href="introduction.html#dybj94" id="id2"><span>[Dybj94]</span></a>.</p>
<p>We will provide a number of examples of inductive types. We will also consider slight generalizations of the scheme above, to mutually defined inductive types, and so-called <em>inductive families</em>.</p>
<p>As with the logical connectives, every inductive type comes with introduction rules, which show how to construct an element of the type, and elimination rules, which show how to &#8220;use&#8221; an element of the type in another construction. The analogy to the logical connectives should not come as a surprise; as we will see below, they, too, are examples of inductive type constructions. You have already seen the introduction rules for an inductive type: they are just the constructors that are specified in the definition of the type. The elimination rules provide for a principle of recursion on the type, which includes, as a special case, a principle of induction as well.</p>
<p>In the next chapter, we will describe Lean&#8217;s function definition package, which provides even more convenient ways to define functions on inductive types and carry out inductive proofs. But because the notion of an inductive type is so fundamental, we feel it is important to start with a low-level, hands-on understanding. We will start with some basic examples of inductive types, and work our way up to more elaborate and complex examples.</p>
<section id="enumerated-types">
<h2><span class="section-number">7.1. </span>Enumerated Types<a class="headerlink" href="#enumerated-types" title="Link to this heading">&#182;</a></h2>
<p>The simplest kind of inductive type is simply a type with a finite, enumerated list of elements.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">weekday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">sunday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span>
<span class="bp">|</span><span class="w"> </span><span class="n">monday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span>
<span class="bp">|</span><span class="w"> </span><span class="n">tuesday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span>
<span class="bp">|</span><span class="w"> </span><span class="n">wednesday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span>
<span class="bp">|</span><span class="w"> </span><span class="n">thursday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span>
<span class="bp">|</span><span class="w"> </span><span class="n">friday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span>
<span class="bp">|</span><span class="w"> </span><span class="n">saturday</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">inductive</span></code> command creates a new type, <code class="docutils literal notranslate"><span class="pre">weekday</span></code>. The constructors all live in the <code class="docutils literal notranslate"><span class="pre">weekday</span></code> namespace.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0A--%20BEGIN%0A%23check%20weekday.sunday%0A%23check%20weekday.monday%0A%0Aopen%20weekday%0A%0A%23check%20sunday%0A%23check%20monday%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="n">weekday.sunday</span>
<span class="k">#check</span><span class="w"> </span><span class="n">weekday.monday</span>

<span class="kn">open</span><span class="w"> </span><span class="n">weekday</span>

<span class="k">#check</span><span class="w"> </span><span class="n">sunday</span>
<span class="k">#check</span><span class="w"> </span><span class="n">monday</span>
</pre></div>
</div>
</div><p>Think of <code class="docutils literal notranslate"><span class="pre">sunday</span></code>, <code class="docutils literal notranslate"><span class="pre">monday</span></code>, <span class="math notranslate nohighlight">\(\ldots\)</span>, <code class="docutils literal notranslate"><span class="pre">saturday</span></code> as being distinct elements of <code class="docutils literal notranslate"><span class="pre">weekday</span></code>, with no other distinguishing properties. The elimination principle, <code class="docutils literal notranslate"><span class="pre">weekday.rec</span></code>, is defined along with the type <code class="docutils literal notranslate"><span class="pre">weekday</span></code> and its constructors. It is also known as a <em>recursor</em>, and it is what makes the type &#8220;inductive&#8221;: it allows us to define a function on <code class="docutils literal notranslate"><span class="pre">weekday</span></code> by assigning values corresponding to each constructor. The intuition is that an inductive type is exhaustively generated by the constructors, and has no elements beyond those they construct.</p>
<p>We will use a slight variant of <code class="docutils literal notranslate"><span class="pre">weekday.rec</span></code>, <code class="docutils literal notranslate"><span class="pre">weekday.rec_on</span></code> (also generated automatically), which takes its arguments in a more convenient order. (Note that the shorter names <code class="docutils literal notranslate"><span class="pre">rec</span></code> and <code class="docutils literal notranslate"><span class="pre">rec_on</span></code> are not made available by default when we open the <code class="docutils literal notranslate"><span class="pre">weekday</span></code> namespace. This avoids clashes with the functions of the same names for other inductive types.) We can use <code class="docutils literal notranslate"><span class="pre">weekday.rec_on</span></code> to define a function from <code class="docutils literal notranslate"><span class="pre">weekday</span></code> to the natural numbers:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0A--%20BEGIN%0Adef%20number_of_day%20(d%20%3A%20weekday)%20%3A%20%E2%84%95%20%3A%3D%0Aweekday.rec_on%20d%201%202%203%204%205%206%207%0A%0A%23reduce%20number_of_day%20weekday.sunday%0A%23reduce%20number_of_day%20weekday.monday%0A%23reduce%20number_of_day%20weekday.tuesday%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">number_of_day</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">weekday.rec_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span>

<span class="k">#reduce</span><span class="w"> </span><span class="n">number_of_day</span><span class="w"> </span><span class="n">weekday.sunday</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">number_of_day</span><span class="w"> </span><span class="n">weekday.monday</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">number_of_day</span><span class="w"> </span><span class="n">weekday.tuesday</span>
</pre></div>
</div>
</div><p>The first (explicit) argument to <code class="docutils literal notranslate"><span class="pre">rec_on</span></code> is the element being &#8220;analyzed.&#8221; The next seven arguments are the values corresponding to the seven constructors. Note that <code class="docutils literal notranslate"><span class="pre">number_of_day</span> <span class="pre">weekday.sunday</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">1</span></code>: the computation rule for <code class="docutils literal notranslate"><span class="pre">rec_on</span></code> recognizes that <code class="docutils literal notranslate"><span class="pre">sunday</span></code> is a constructor, and returns the appropriate argument.</p>
<p>Below we will encounter a more restricted variant of <code class="docutils literal notranslate"><span class="pre">rec_on</span></code>, namely, <code class="docutils literal notranslate"><span class="pre">cases_on</span></code>. When it comes to enumerated types, <code class="docutils literal notranslate"><span class="pre">rec_on</span></code> and <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> are the same. You may prefer to use the label <code class="docutils literal notranslate"><span class="pre">cases_on</span></code>, because it emphasizes that the definition is really a definition by cases.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0A--%20BEGIN%0Adef%20number_of_day%20(d%20%3A%20weekday)%20%3A%20%E2%84%95%20%3A%3D%0Aweekday.cases_on%20d%201%202%203%204%205%206%207%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">number_of_day</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">weekday.cases_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span>
</pre></div>
</div>
</div><p>It is often useful to group definitions and theorems related to a structure in a namespace with the same name. For example, we can put the <code class="docutils literal notranslate"><span class="pre">number_of_day</span></code> function in the <code class="docutils literal notranslate"><span class="pre">weekday</span></code> namespace. We are then allowed to use the shorter name when we open the namespace.</p>
<p>The names <code class="docutils literal notranslate"><span class="pre">rec_on</span></code> and <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> are generated automatically. As noted above, they are <em>protected</em> to avoid name clashes. In other words, they are not provided by default when the namespace is opened. However, you can explicitly declare abbreviations for them using the <code class="docutils literal notranslate"><span class="pre">renaming</span></code> option when you open a namespace.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0A--%20BEGIN%0Anamespace%20weekday%0A%40%5Breducible%5D%0Aprivate%20def%20cases_on%20%3A%3D%20%40weekday.cases_on%0A%0Adef%20number_of_day%20(d%20%3A%20weekday)%20%3A%20nat%20%3A%3D%0Acases_on%20d%201%202%203%204%205%206%207%0Aend%20weekday%0A%0A%23reduce%20weekday.number_of_day%20weekday.sunday%0A%0Aopen%20weekday%20(renaming%20cases_on%20%E2%86%92%20cases_on)%0A%0A%23reduce%20number_of_day%20sunday%0A%23check%20cases_on%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">weekday</span>
<span class="kd">@[</span><span class="n">reducible</span><span class="kd">]</span>
<span class="kn">private</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">cases_on</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">@</span><span class="n">weekday.cases_on</span>

<span class="kd">def</span><span class="w"> </span><span class="n">number_of_day</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span>
<span class="n">cases_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span>
<span class="kd">end</span><span class="w"> </span><span class="n">weekday</span>

<span class="k">#reduce</span><span class="w"> </span><span class="n">weekday.number_of_day</span><span class="w"> </span><span class="n">weekday.sunday</span>

<span class="kn">open</span><span class="w"> </span><span class="n">weekday</span><span class="w"> </span><span class="o">(</span><span class="kn">renaming</span><span class="w"> </span><span class="n">cases_on</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">cases_on</span><span class="o">)</span>

<span class="k">#reduce</span><span class="w"> </span><span class="n">number_of_day</span><span class="w"> </span><span class="n">sunday</span>
<span class="k">#check</span><span class="w"> </span><span class="n">cases_on</span>
</pre></div>
</div>
</div><p>We can define functions from <code class="docutils literal notranslate"><span class="pre">weekday</span></code> to <code class="docutils literal notranslate"><span class="pre">weekday</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0A--%20BEGIN%0Anamespace%20weekday%0Adef%20next%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20monday%20tuesday%20wednesday%20thursday%20friday%0A%20%20saturday%20sunday%0A%0Adef%20previous%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20saturday%20sunday%20monday%20tuesday%20wednesday%0A%20%20thursday%20friday%0A%0A%23reduce%20next%20(next%20tuesday)%0A%23reduce%20next%20(previous%20tuesday)%0A%0Aexample%20%3A%20next%20(previous%20tuesday)%20%3D%20tuesday%20%3A%3D%20rfl%0Aend%20weekday%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">weekday</span>
<span class="kd">def</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="w"> </span><span class="o">:=</span>
<span class="n">weekday.cases_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">monday</span><span class="w"> </span><span class="n">tuesday</span><span class="w"> </span><span class="n">wednesday</span><span class="w"> </span><span class="n">thursday</span><span class="w"> </span><span class="n">friday</span>
<span class="w">  </span><span class="n">saturday</span><span class="w"> </span><span class="n">sunday</span>

<span class="kd">def</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="w"> </span><span class="o">:=</span>
<span class="n">weekday.cases_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">saturday</span><span class="w"> </span><span class="n">sunday</span><span class="w"> </span><span class="n">monday</span><span class="w"> </span><span class="n">tuesday</span><span class="w"> </span><span class="n">wednesday</span>
<span class="w">  </span><span class="n">thursday</span><span class="w"> </span><span class="n">friday</span>

<span class="k">#reduce</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">next</span><span class="w"> </span><span class="n">tuesday</span><span class="o">)</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">tuesday</span><span class="o">)</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">tuesday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">tuesday</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">end</span><span class="w"> </span><span class="n">weekday</span>
</pre></div>
</div>
</div><p>How can we prove the general theorem that <code class="docutils literal notranslate"><span class="pre">next</span> <span class="pre">(previous</span> <span class="pre">d)</span> <span class="pre">=</span> <span class="pre">d</span></code> for any weekday <code class="docutils literal notranslate"><span class="pre">d</span></code>? The induction principle parallels the recursion principle: we simply have to provide a proof of the claim for each constructor:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0Anamespace%20weekday%0Adef%20next%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20monday%20tuesday%20wednesday%20thursday%20friday%0A%20%20saturday%20sunday%0A%0Adef%20previous%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20saturday%20sunday%20monday%20tuesday%20wednesday%0A%20%20thursday%20friday%0A%0A--%20BEGIN%0Atheorem%20next_previous%20(d%3A%20weekday)%20%3A%0A%20%20next%20(previous%20d)%20%3D%20d%20%3A%3D%0Aweekday.cases_on%20d%0A%20%20(show%20next%20(previous%20sunday)%20%3D%20sunday%2C%20from%20rfl)%0A%20%20(show%20next%20(previous%20monday)%20%3D%20monday%2C%20from%20rfl)%0A%20%20(show%20next%20(previous%20tuesday)%20%3D%20tuesday%2C%20from%20rfl)%0A%20%20(show%20next%20(previous%20wednesday)%20%3D%20wednesday%2C%20from%20rfl)%0A%20%20(show%20next%20(previous%20thursday)%20%3D%20thursday%2C%20from%20rfl)%0A%20%20(show%20next%20(previous%20friday)%20%3D%20friday%2C%20from%20rfl)%0A%20%20(show%20next%20(previous%20saturday)%20%3D%20saturday%2C%20from%20rfl)%0A--%20END%0Aend%20weekday" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">next_previous</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">d</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:=</span>
<span class="n">weekday.cases_on</span><span class="w"> </span><span class="n">d</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">sunday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">sunday</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">monday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">monday</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">tuesday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">tuesday</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">wednesday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">wednesday</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">thursday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">thursday</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">friday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">friday</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">saturday</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">saturday</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
</pre></div>
</div>
</div><p>While the <code class="docutils literal notranslate"><span class="pre">show</span></code> commands make the proof clearer and more readable, they are not necessary:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0Anamespace%20weekday%0Adef%20next%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20monday%20tuesday%20wednesday%20thursday%20friday%20saturday%20sunday%0A%0Adef%20previous%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20saturday%20sunday%20monday%20tuesday%20wednesday%20thursday%20friday%0A%0A--%20BEGIN%0Atheorem%20next_previous%20(d%3A%20weekday)%20%3A%0A%20%20next%20(previous%20d)%20%3D%20d%20%3A%3D%0Aweekday.cases_on%20d%20rfl%20rfl%20rfl%20rfl%20rfl%20rfl%20rfl%0A--%20END%0Aend%20weekday" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">next_previous</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">d</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:=</span>
<span class="n">weekday.cases_on</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>Using a tactic proof, we can be even more concise:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0Anamespace%20weekday%0Adef%20next%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20monday%20tuesday%20wednesday%20thursday%20friday%20saturday%20sunday%0A%0Adef%20previous%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20saturday%20sunday%20monday%20tuesday%20wednesday%20thursday%20friday%0A%0A--%20BEGIN%0Atheorem%20next_previous%20(d%3A%20weekday)%20%3A%0A%20%20next%20(previous%20d)%20%3D%20d%20%3A%3D%0Aby%20apply%20weekday.cases_on%20d%3B%20refl%0A--%20END%0Aend%20weekday" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">next_previous</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">d</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">apply</span><span class="w"> </span><span class="n">weekday.cases_on</span><span class="w"> </span><span class="n">d</span><span class="bp">;</span><span class="w"> </span><span class="n">refl</span>
</pre></div>
</div>
</div><p><a class="reference internal" href="#tactics-for-inductive-types"><span class="std std-numref">Section 7.6</span></a> below will introduce additional tactics that are specifically designed to make use of inductive types.</p>
<p>Notice that, under the propositions-as-types correspondence, we can use <code class="docutils literal notranslate"><span class="pre">cases_on</span></code> to prove theorems as well as define functions. In fact, we could equally well have used <code class="docutils literal notranslate"><span class="pre">rec_on</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20weekday%20%3A%20Type%0A%7C%20sunday%20%3A%20weekday%0A%7C%20monday%20%3A%20weekday%0A%7C%20tuesday%20%3A%20weekday%0A%7C%20wednesday%20%3A%20weekday%0A%7C%20thursday%20%3A%20weekday%0A%7C%20friday%20%3A%20weekday%0A%7C%20saturday%20%3A%20weekday%0A%0Anamespace%20weekday%0Adef%20next%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20monday%20tuesday%20wednesday%20thursday%20friday%20saturday%20sunday%0A%0Adef%20previous%20(d%20%3A%20weekday)%20%3A%20weekday%20%3A%3D%0Aweekday.cases_on%20d%20saturday%20sunday%20monday%20tuesday%20wednesday%20thursday%20friday%0A%0A--%20BEGIN%0Atheorem%20next_previous%20(d%3A%20weekday)%20%3A%0A%20%20next%20(previous%20d)%20%3D%20d%20%3A%3D%0Aby%20apply%20weekday.rec_on%20d%3B%20refl%0A--%20END%0Aend%20weekday" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">next_previous</span><span class="w"> </span><span class="o">(</span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="n">weekday</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">next</span><span class="w"> </span><span class="o">(</span><span class="n">previous</span><span class="w"> </span><span class="n">d</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">apply</span><span class="w"> </span><span class="n">weekday.rec_on</span><span class="w"> </span><span class="n">d</span><span class="bp">;</span><span class="w"> </span><span class="n">refl</span>
</pre></div>
</div>
</div><p>In other words, under the propositions-as-types correspondence, the proof by cases is a kind of definition by recursion, where what is being &#8220;defined&#8221; is a proof instead of a piece of data.</p>
<p>Some fundamental data types in the Lean library are instances of
enumerated types.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20BEGIN%0Anamespace%20hidden%0Ainductive%20empty%20%3A%20Type%0A%0Ainductive%20unit%20%3A%20Type%0A%7C%20star%20%3A%20unit%0A%0Ainductive%20bool%20%3A%20Type%0A%7C%20ff%20%3A%20bool%0A%7C%20tt%20%3A%20bool%0Aend%20hidden%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">hidden</span>
<span class="kd">inductive</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">star</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">unit</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span>
<span class="bp">|</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span>
<span class="kd">end</span><span class="w"> </span><span class="n">hidden</span>
</pre></div>
</div>
</div><p>(To run these examples, we put them in a namespace called <code class="docutils literal notranslate"><span class="pre">hidden</span></code>, so that a name like <code class="docutils literal notranslate"><span class="pre">bool</span></code> does not conflict with the <code class="docutils literal notranslate"><span class="pre">bool</span></code> in the standard library. This is necessary because these types are part of the Lean &#8220;prelude&#8221; that is automatically imported when the system is started.)</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">empty</span></code> is an inductive data type with no constructors. The type <code class="docutils literal notranslate"><span class="pre">unit</span></code> has a single element, <code class="docutils literal notranslate"><span class="pre">star</span></code>, and the type <code class="docutils literal notranslate"><span class="pre">bool</span></code> represents the familiar boolean values. As an exercise, you should think about what the introduction and elimination rules for these types do. As a further exercise, we suggest defining boolean operations <code class="docutils literal notranslate"><span class="pre">band</span></code>, <code class="docutils literal notranslate"><span class="pre">bor</span></code>, <code class="docutils literal notranslate"><span class="pre">bnot</span></code> on the boolean, and verifying common identities. Note that you can define a binary operation like <code class="docutils literal notranslate"><span class="pre">band</span></code> using a case split:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20band%20(b1%20b2%20%3A%20bool)%20%3A%20bool%20%3A%3D%0Abool.cases_on%20b1%20ff%20b2%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">band</span><span class="w"> </span><span class="o">(</span><span class="n">b1</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="o">:=</span>
<span class="n">bool.cases_on</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">b2</span>
</pre></div>
</div>
</div><p>Similarly, most identities can be proved by introducing suitable case splits, and then using <code class="docutils literal notranslate"><span class="pre">rfl</span></code>.</p>
</section>
<section id="constructors-with-arguments">
<h2><span class="section-number">7.2. </span>Constructors with Arguments<a class="headerlink" href="#constructors-with-arguments" title="Link to this heading">&#182;</a></h2>
<p>Enumerated types are a very special case of inductive types, in which the constructors take no arguments at all. In general, a &#8220;construction&#8221; can depend on data, which is then represented in the constructed argument. Consider the definitions of the product type and sum type in the library:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Auniverses%20u%20v%0A%0Ainductive%20prod%20(%CE%B1%20%3A%20Type%20u)%20(%CE%B2%20%3A%20Type%20v)%0A%7C%20mk%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20prod%0A%0Ainductive%20sum%20(%CE%B1%20%3A%20Type%20u)%20(%CE%B2%20%3A%20Type%20v)%0A%7C%20inl%20%3A%20%CE%B1%20%E2%86%92%20sum%0A%7C%20inr%20%3A%20%CE%B2%20%E2%86%92%20sum%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">prod</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">prod</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">inl</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">sum</span>
<span class="bp">|</span><span class="w"> </span><span class="n">inr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">sum</span>
</pre></div>
</div>
</div><p>Notice that we do not include the types <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> in the target of the constructors. In the meanwhile, think about what is going on in these examples. The product type has one constructor, <code class="docutils literal notranslate"><span class="pre">prod.mk</span></code>, which takes two arguments. To define a function on <code class="docutils literal notranslate"><span class="pre">prod</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span></code>, we can assume the input is of the form <code class="docutils literal notranslate"><span class="pre">prod.mk</span> <span class="pre">a</span> <span class="pre">b</span></code>, and we have to specify the output, in terms of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. We can use this to define the two projections for prod. Remember that the standard library defines notation <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#215;</span> <span class="pre">&#946;</span></code> for <code class="docutils literal notranslate"><span class="pre">prod</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span></code> and <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> for <code class="docutils literal notranslate"><span class="pre">prod.mk</span> <span class="pre">a</span> <span class="pre">b</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universes%20u%20v%0A%0A--%20BEGIN%0Adef%20fst%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7B%CE%B2%20%3A%20Type%20v%7D%20(p%20%3A%20%CE%B1%20%C3%97%20%CE%B2)%20%3A%20%CE%B1%20%3A%3D%0Aprod.rec_on%20p%20(%CE%BB%20a%20b%2C%20a)%0A%0Adef%20snd%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7B%CE%B2%20%3A%20Type%20v%7D%20(p%20%3A%20%CE%B1%20%C3%97%20%CE%B2)%20%3A%20%CE%B2%20%3A%3D%0Aprod.rec_on%20p%20(%CE%BB%20a%20b%2C%20b)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">prod.rec_on</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">snd</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">prod.rec_on</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The function <code class="docutils literal notranslate"><span class="pre">fst</span></code> takes a pair, <code class="docutils literal notranslate"><span class="pre">p</span></code>. Applying the recursor <code class="docutils literal notranslate"><span class="pre">prod.rec_on</span> <span class="pre">p</span> <span class="pre">(&#955;</span> <span class="pre">a</span> <span class="pre">b,</span> <span class="pre">a)</span></code> interprets <code class="docutils literal notranslate"><span class="pre">p</span></code> as a pair, <code class="docutils literal notranslate"><span class="pre">prod.mk</span> <span class="pre">a</span> <span class="pre">b</span></code>, and then uses the second argument to determine what to do with <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. Remember that you can enter the symbol for a product by typing <code class="docutils literal notranslate"><span class="pre">\times</span></code>. Recall also from <a class="reference internal" href="dependent_type_theory.html#dependent-types"><span class="std std-numref">Section 2.8</span></a> that to give these definitions the greatest generality possible, we allow the types <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> to belong to any universe.</p>
<p>Here is another example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20prod_example%20(p%20%3A%20bool%20%C3%97%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Aprod.rec_on%20p%20(%CE%BB%20b%20n%2C%20cond%20b%20(2%20*%20n)%20(2%20*%20n%20%2B%201))%0A%0A%23reduce%20prod_example%20(tt%2C%203)%0A%23reduce%20prod_example%20(ff%2C%203)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">prod_example</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="bp">&#215;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">prod.rec_on</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">))</span>

<span class="k">#reduce</span><span class="w"> </span><span class="n">prod_example</span><span class="w"> </span><span class="o">(</span><span class="n">tt</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">prod_example</span><span class="w"> </span><span class="o">(</span><span class="n">ff</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">cond</span></code> function is a boolean conditional: <code class="docutils literal notranslate"><span class="pre">cond</span> <span class="pre">b</span> <span class="pre">t1</span> <span class="pre">t2</span></code> returns <code class="docutils literal notranslate"><span class="pre">t1</span></code> if <code class="docutils literal notranslate"><span class="pre">b</span></code> is true, and <code class="docutils literal notranslate"><span class="pre">t2</span></code> otherwise. (It has the same effect as <code class="docutils literal notranslate"><span class="pre">bool.rec_on</span> <span class="pre">b</span> <span class="pre">t2</span> <span class="pre">t1</span></code>.) The function <code class="docutils literal notranslate"><span class="pre">prod_example</span></code> takes a pair consisting of a boolean, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and a number, <code class="docutils literal notranslate"><span class="pre">n</span></code>, and returns either <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> according to whether <code class="docutils literal notranslate"><span class="pre">b</span></code> is true or false.</p>
<p>In contrast, the sum type has <em>two</em> constructors, <code class="docutils literal notranslate"><span class="pre">inl</span></code> and <code class="docutils literal notranslate"><span class="pre">inr</span></code> (for &#8220;insert left&#8221; and &#8220;insert right&#8221;), each of which takes <em>one</em> (explicit) argument. To define a function on <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span></code>, we have to handle two cases: either the input is of the form <code class="docutils literal notranslate"><span class="pre">inl</span> <span class="pre">a</span></code>, in which case we have to specify an output value in terms of <code class="docutils literal notranslate"><span class="pre">a</span></code>, or the input is of the form <code class="docutils literal notranslate"><span class="pre">inr</span> <span class="pre">b</span></code>, in which case we have to specify an output value in terms of <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20BEGIN%0Adef%20sum_example%20(s%20%3A%20%E2%84%95%20%E2%8A%95%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Asum.cases_on%20s%20(%CE%BB%20n%2C%202%20*%20n)%20(%CE%BB%20n%2C%202%20*%20n%20%2B%201)%0A%0A%23reduce%20sum_example%20(sum.inl%203)%0A%23reduce%20sum_example%20(sum.inr%203)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">sum_example</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8853;</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">sum.cases_on</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>

<span class="k">#reduce</span><span class="w"> </span><span class="n">sum_example</span><span class="w"> </span><span class="o">(</span><span class="n">sum.inl</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">sum_example</span><span class="w"> </span><span class="o">(</span><span class="n">sum.inr</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
</pre></div>
</div>
</div><p>This example is similar to the previous one, but now an input to <code class="docutils literal notranslate"><span class="pre">sum_example</span></code> is implicitly either of the form <code class="docutils literal notranslate"><span class="pre">inl</span> <span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">inr</span> <span class="pre">n</span></code>. In the first case, the function returns <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">n</span></code>, and the second case, it returns <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>. You can enter the symbol for the sum by typing <code class="docutils literal notranslate"><span class="pre">\oplus</span></code>.</p>
<p>Notice that the product type depends on parameters <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#946;</span> <span class="pre">:</span> <span class="pre">Type</span></code> which are arguments to the constructors as well as <code class="docutils literal notranslate"><span class="pre">prod</span></code>. Lean detects when these arguments can be inferred from later arguments to a constructor or the return type, and makes them implicit in that case.</p>
<p>In the section after next we will see what happens when the constructor of an inductive type takes arguments from the inductive type itself. What characterizes the examples we consider in this section is that this is not the case: each constructor relies only on previously specified types.</p>
<p>Notice that a type with multiple constructors is disjunctive: an element of <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span></code> is either of the form <code class="docutils literal notranslate"><span class="pre">inl</span> <span class="pre">a</span></code> <em>or</em> of the form <code class="docutils literal notranslate"><span class="pre">inl</span> <span class="pre">b</span></code>. A constructor with multiple arguments introduces conjunctive information: from an element <code class="docutils literal notranslate"><span class="pre">prod.mk</span> <span class="pre">a</span> <span class="pre">b</span></code> of <code class="docutils literal notranslate"><span class="pre">prod</span> <span class="pre">&#945;</span> <span class="pre">&#946;</span></code> we can extract <code class="docutils literal notranslate"><span class="pre">a</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">b</span></code>. An arbitrary inductive type can include both features, by having any number of constructors, each of which takes any number of arguments.</p>
<p>As with function definitions, Lean&#8217;s inductive definition syntax will let you put named arguments to the constructors before the colon:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Auniverses%20u%20v%0A%0Ainductive%20prod%20(%CE%B1%20%3A%20Type%20u)%20(%CE%B2%20%3A%20Type%20v)%0A%7C%20mk%20(fst%20%3A%20%CE%B1)%20(snd%20%3A%20%CE%B2)%20%3A%20prod%0A%0Ainductive%20sum%20(%CE%B1%20%3A%20Type%20u)%20(%CE%B2%20%3A%20Type%20v)%0A%7C%20inl%20%7B%7D%20(a%20%3A%20%CE%B1)%20%3A%20sum%0A%7C%20inr%20%7B%7D%20(b%20%3A%20%CE%B2)%20%3A%20sum%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">prod</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="o">(</span><span class="n">fst</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">snd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">prod</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">inl</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sum</span>
<span class="bp">|</span><span class="w"> </span><span class="n">inr</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sum</span>
</pre></div>
</div>
</div><p>The results of these definitions are essentially the same as the ones given earlier in this section. Note that in the definition of <code class="docutils literal notranslate"><span class="pre">sum</span></code>, the annotation <code class="docutils literal notranslate"><span class="pre">{}</span></code> refers to the parameters, <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>. As with function definitions, you can use curly braces to specify which arguments are meant to be left implicit.</p>
<p>A type, like <code class="docutils literal notranslate"><span class="pre">prod</span></code>, that has only one constructor is purely conjunctive: the constructor simply packs the list of arguments into a single piece of data, essentially a tuple where the type of subsequent arguments can depend on the type of the initial argument. We can also think of such a type as a &#8220;record&#8221; or a &#8220;structure&#8221;. In Lean, the keyword <code class="docutils literal notranslate"><span class="pre">structure</span></code> can be used to define such an inductive type as well as its projections, at the same time.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Astructure%20prod%20(%CE%B1%20%CE%B2%20%3A%20Type*)%20%3A%3D%0Amk%20%3A%3A%20(fst%20%3A%20%CE%B1)%20(snd%20%3A%20%CE%B2)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">structure</span><span class="w"> </span><span class="n">prod</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">mk</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="o">(</span><span class="n">fst</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">snd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>This example simultaneously introduces the inductive type, <code class="docutils literal notranslate"><span class="pre">prod</span></code>, its constructor, <code class="docutils literal notranslate"><span class="pre">mk</span></code>, the usual eliminators (<code class="docutils literal notranslate"><span class="pre">rec</span></code> and <code class="docutils literal notranslate"><span class="pre">rec_on</span></code>), as well as the projections, <code class="docutils literal notranslate"><span class="pre">fst</span></code> and <code class="docutils literal notranslate"><span class="pre">snd</span></code>, as defined above.</p>
<p>If you do not name the constructor, Lean uses <code class="docutils literal notranslate"><span class="pre">mk</span></code> as a default. For example, the following defines a record to store a color as a triple of RGB values:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0A--%20BEGIN%0Astructure%20color%20%3A%3D%20(red%20%3A%20nat)%20(green%20%3A%20nat)%20(blue%20%3A%20nat)%0Adef%20yellow%20%3A%3D%20color.mk%20255%20255%200%0A%23reduce%20color.red%20yellow%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">structure</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">(</span><span class="n">red</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">green</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">blue</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span>
<span class="kd">def</span><span class="w"> </span><span class="n">yellow</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">color.mk</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="mi">0</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">color.red</span><span class="w"> </span><span class="n">yellow</span>
</pre></div>
</div>
</div><p>The definition of <code class="docutils literal notranslate"><span class="pre">yellow</span></code> forms the record with the three values shown, and the projection <code class="docutils literal notranslate"><span class="pre">color.red</span></code> returns the red component. The <code class="docutils literal notranslate"><span class="pre">structure</span></code> command is especially useful for defining algebraic structures, and Lean provides substantial infrastructure to support working with them. Here, for example, is the definition of a semigroup:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Astructure%20Semigroup%20%3A%3D%0A(carrier%20%3A%20Type%20u)%0A(mul%20%3A%20carrier%20%E2%86%92%20carrier%20%E2%86%92%20carrier)%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%2C%20mul%20(mul%20a%20b)%20c%20%3D%20mul%20a%20(mul%20b%20c))" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span><span class="w"> </span><span class="n">u</span>

<span class="kd">structure</span><span class="w"> </span><span class="n">Semigroup</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">carrier</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">carrier</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">,</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="o">(</span><span class="n">mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">(</span><span class="n">mul</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">))</span>
</pre></div>
</div>
</div><p>We will see more examples in <a class="reference internal" href="structures_and_records.html#structures-and-records"><span class="std std-numref">Chapter 9</span></a>.</p>
<p>We have already discussed sigma types, also known as the dependent product:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universes%20u%20v%0A%0Anamespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20sigma%20%7B%CE%B1%20%3A%20Type%20u%7D%20(%CE%B2%20%3A%20%CE%B1%20%E2%86%92%20Type%20v)%0A%7C%20dpair%20%3A%20%CE%A0%20a%20%3A%20%CE%B1%2C%20%CE%B2%20a%20%E2%86%92%20sigma%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">v</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">dpair</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">sigma</span>
</pre></div>
</div>
</div><p>Two more examples of inductive types in the library are the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20option%20(%CE%B1%20%3A%20Type*)%0A%7C%20none%20%7B%7D%20%3A%20option%0A%7C%20some%20%20%20%20%3A%20%CE%B1%20%E2%86%92%20option%0A%0Ainductive%20inhabited%20(%CE%B1%20%3A%20Type*)%0A%7C%20mk%20%3A%20%CE%B1%20%E2%86%92%20inhabited%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">none</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">option</span>
<span class="bp">|</span><span class="w"> </span><span class="n">some</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">option</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">inhabited</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">inhabited</span>
</pre></div>
</div>
</div><p>In the semantics of dependent type theory, there is no built-in notion of a partial function. Every element of a function type <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code> or a Pi type <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">&#946;</span></code> is assumed to have a value at every input. The <code class="docutils literal notranslate"><span class="pre">option</span></code> type provides a way of representing partial functions. An element of <code class="docutils literal notranslate"><span class="pre">option</span> <span class="pre">&#946;</span></code> is either <code class="docutils literal notranslate"><span class="pre">none</span></code> or of the form <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">b</span></code>, for some value <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">:</span> <span class="pre">&#946;</span></code>. Thus we can think of an element <code class="docutils literal notranslate"><span class="pre">f</span></code> of the type <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">option</span> <span class="pre">&#946;</span></code> as being a partial function from <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> to <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>: for every <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> either returns <code class="docutils literal notranslate"><span class="pre">none</span></code>, indicating the <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> is &#8220;undefined&#8221;, or <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">b</span></code>.</p>
<p>An element of <code class="docutils literal notranslate"><span class="pre">inhabited</span> <span class="pre">&#945;</span></code> is simply a witness to the fact that there is an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. Later, we will see that <code class="docutils literal notranslate"><span class="pre">inhabited</span></code> is an example of a <em>type class</em> in Lean: Lean can be instructed that suitable base types are inhabited, and can automatically infer that other constructed types are inhabited on that basis.</p>
<p>As exercises, we encourage you to develop a notion of composition for partial functions from <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> to <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> to <code class="docutils literal notranslate"><span class="pre">&#947;</span></code>, and show that it behaves as expected. We also encourage you to show that <code class="docutils literal notranslate"><span class="pre">bool</span></code> and <code class="docutils literal notranslate"><span class="pre">nat</span></code> are inhabited, that the product of two inhabited types is inhabited, and that the type of functions to an inhabited type is inhabited.</p>
</section>
<section id="inductively-defined-propositions">
<h2><span class="section-number">7.3. </span>Inductively Defined Propositions<a class="headerlink" href="#inductively-defined-propositions" title="Link to this heading">&#182;</a></h2>
<p>Inductively defined types can live in any type universe, including the bottom-most one, <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. In fact, this is exactly how the logical connectives are defined.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20false%20%3A%20Prop%0A%0Ainductive%20true%20%3A%20Prop%0A%7C%20intro%20%3A%20true%0A%0Ainductive%20and%20(a%20b%20%3A%20Prop)%20%3A%20Prop%0A%7C%20intro%20%3A%20a%20%E2%86%92%20b%20%E2%86%92%20and%0A%0Ainductive%20or%20(a%20b%20%3A%20Prop)%20%3A%20Prop%0A%7C%20intro_left%20%20%3A%20a%20%E2%86%92%20or%0A%7C%20intro_right%20%3A%20b%20%E2%86%92%20or%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">true</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">and</span>

<span class="kd">inductive</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">intro_left</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">or</span>
<span class="bp">|</span><span class="w"> </span><span class="n">intro_right</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">or</span>
</pre></div>
</div>
</div><p>You should think about how these give rise to the introduction and elimination rules that you have already seen. There are rules that govern what the eliminator of an inductive type can eliminate <em>to</em>, that is, what kinds of types can be the target of a recursor. Roughly speaking, what characterizes inductive types in <code class="docutils literal notranslate"><span class="pre">Prop</span></code> is that one can only eliminate to other types in <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. This is consistent with the understanding that if <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, an element <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> carries no data. There is a small exception to this rule, however, which we will discuss below, in the section on inductive families.</p>
<p>Even the existential quantifier is inductively defined:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20Exists%20%7B%CE%B1%20%3A%20Type*%7D%20(q%20%3A%20%CE%B1%20%E2%86%92%20Prop)%20%3A%20Prop%0A%7C%20intro%20%3A%20%E2%88%80%20(a%20%3A%20%CE%B1)%2C%20q%20a%20%E2%86%92%20Exists%0A%0A%20def%20exists.intro%20%3A%3D%20%40Exists.intro%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">Exists</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">),</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">Exists</span>

<span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="n">exists.intro</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">@</span><span class="n">Exists.intro</span>
</pre></div>
</div>
</div><p>Keep in mind that the notation <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">p</span></code> is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">Exists</span> <span class="pre">(&#955;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">p)</span></code>.</p>
<p>The definitions of <code class="docutils literal notranslate"><span class="pre">false</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">and</span></code>, and <code class="docutils literal notranslate"><span class="pre">or</span></code> are perfectly analogous to the definitions of <code class="docutils literal notranslate"><span class="pre">empty</span></code>, <code class="docutils literal notranslate"><span class="pre">unit</span></code>, <code class="docutils literal notranslate"><span class="pre">prod</span></code>, and <code class="docutils literal notranslate"><span class="pre">sum</span></code>. The difference is that the first group yields elements of <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, and the second yields elements of <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u</span></code> for some <code class="docutils literal notranslate"><span class="pre">u</span></code>. In a similar way, <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">p</span></code> is a <code class="docutils literal notranslate"><span class="pre">Prop</span></code>-valued variant of <code class="docutils literal notranslate"><span class="pre">&#931;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">p</span></code>.</p>
<p>This is a good place to mention another inductive type, denoted <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">//</span> <span class="pre">p}</span></code>, which is sort of a hybrid between <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">&#931;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">P</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20subtype%20%7B%CE%B1%20%3A%20Type*%7D%20(p%20%3A%20%CE%B1%20%E2%86%92%20Prop)%0A%7C%20mk%20%3A%20%CE%A0%20x%20%3A%20%CE%B1%2C%20p%20x%20%E2%86%92%20subtype%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">subtype</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#928;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">subtype</span>
</pre></div>
</div>
</div><p>In fact, in Lean, <code class="docutils literal notranslate"><span class="pre">subtype</span></code> is defined using the structure command:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Anamespace%20hidden%0A%0A--%20BEGIN%0Astructure%20subtype%20%7B%CE%B1%20%3A%20Sort%20u%7D%20(p%20%3A%20%CE%B1%20%E2%86%92%20Prop)%20%3A%3D%0A(val%20%3A%20%CE%B1)%20(property%20%3A%20p%20val)%0A%0Asection%0Avariables%20%7B%CE%B1%20%3A%20Type%20u%7D%20(p%20%3A%20%CE%B1%20%E2%86%92%20Prop)%0A%0A%23check%20subtype%20p%0A%23check%20%7B%20x%20%3A%20%CE%B1%20%2F%2F%20p%20x%7D%0Aend%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">structure</span><span class="w"> </span><span class="n">subtype</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="o">(</span><span class="n">val</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">property</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">val</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span>

<span class="k">#check</span><span class="w"> </span><span class="n">subtype</span><span class="w"> </span><span class="n">p</span>
<span class="k">#check</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">//</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="o">}</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The notation <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">//</span> <span class="pre">p</span> <span class="pre">x}</span></code> is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">subtype</span> <span class="pre">(&#955;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;,</span> <span class="pre">p</span> <span class="pre">x)</span></code>. It is modeled after subset notation in set theory: the idea is that <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">//</span> <span class="pre">p</span> <span class="pre">x}</span></code> denotes the collection of elements of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> that have property <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
</section>
<section id="defining-the-natural-numbers">
<h2><span class="section-number">7.4. </span>Defining the Natural Numbers<a class="headerlink" href="#defining-the-natural-numbers" title="Link to this heading">&#182;</a></h2>
<p>The inductively defined types we have seen so far are &#8220;flat&#8221;: constructors wrap data and insert it into a type, and the corresponding recursor unpacks the data and acts on it. Things get much more interesting when the constructors act on elements of the very type being defined. A canonical example is the type <code class="docutils literal notranslate"><span class="pre">nat</span></code> of natural numbers:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span>
<span class="bp">|</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">nat</span>
</pre></div>
</div>
</div><p>There are two constructors. We start with <code class="docutils literal notranslate"><span class="pre">zero</span> <span class="pre">:</span> <span class="pre">nat</span></code>; it takes no arguments, so we have it from the start. In contrast, the constructor <code class="docutils literal notranslate"><span class="pre">succ</span></code> can only be applied to a previously constructed <code class="docutils literal notranslate"><span class="pre">nat</span></code>. Applying it to <code class="docutils literal notranslate"><span class="pre">zero</span></code> yields <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">zero</span> <span class="pre">:</span> <span class="pre">nat</span></code>. Applying it again yields <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(succ</span> <span class="pre">zero)</span> <span class="pre">:</span> <span class="pre">nat</span></code>, and so on. Intuitively, <code class="docutils literal notranslate"><span class="pre">nat</span></code> is the &#8220;smallest&#8221; type with these constructors, meaning that it is exhaustively (and freely) generated by starting with <code class="docutils literal notranslate"><span class="pre">zero</span></code> and applying <code class="docutils literal notranslate"><span class="pre">succ</span></code> repeatedly.</p>
<p>As before, the recursor for <code class="docutils literal notranslate"><span class="pre">nat</span></code> is designed to define a dependent function <code class="docutils literal notranslate"><span class="pre">f</span></code> from <code class="docutils literal notranslate"><span class="pre">nat</span></code> to any domain, that is, an element <code class="docutils literal notranslate"><span class="pre">f</span></code> of <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat,</span> <span class="pre">C</span> <span class="pre">n</span></code> for some <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">:</span> <span class="pre">nat</span> <span class="pre">&#8594;</span> <span class="pre">Type</span></code>. It has to handle two cases: the case where the input is <code class="docutils literal notranslate"><span class="pre">zero</span></code>, and the case where the input is of the form <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">n</span></code> for some <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat</span></code>. In the first case, we simply specify a target value with the appropriate type, as before. In the second case, however, the recursor can assume that a value of <code class="docutils literal notranslate"><span class="pre">f</span></code> at <code class="docutils literal notranslate"><span class="pre">n</span></code> has already been computed. As a result, the next argument to the recursor specifies a value for <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(succ</span> <span class="pre">n)</span></code> in terms of <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">n</span></code>. If we check the type of the recursor,</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A--%20BEGIN%0A%23check%20%40nat.rec_on%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="bp">@</span><span class="n">nat.rec_on</span>
</pre></div>
</div>
</div><p>we find the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&#928; {C : nat &#8594; Type*} (n : nat),
  C nat.zero &#8594; (&#928; (a : nat), C a &#8594; C (nat.succ a)) &#8594; C n
</pre></div>
</div>
<p>The implicit argument, <code class="docutils literal notranslate"><span class="pre">C</span></code>, is the codomain of the function being defined. In type theory it is common to say <code class="docutils literal notranslate"><span class="pre">C</span></code> is the <em>motive</em> for the elimination/recursion, since it describes the kind of object we wish to construct. The next argument, <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat</span></code>, is the input to the function. It is also known as the <code class="docutils literal notranslate"><span class="pre">major</span> <span class="pre">premise</span></code>. Finally, the two arguments after specify how to compute the zero and successor cases, as described above. They are also known as the <code class="docutils literal notranslate"><span class="pre">minor</span> <span class="pre">premises</span></code>.</p>
<p>Consider, for example, the addition function <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">m</span> <span class="pre">n</span></code> on the natural numbers. Fixing <code class="docutils literal notranslate"><span class="pre">m</span></code>, we can define addition by recursion on <code class="docutils literal notranslate"><span class="pre">n</span></code>. In the base case, we set <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">m</span> <span class="pre">zero</span></code> to <code class="docutils literal notranslate"><span class="pre">m</span></code>. In the successor step, assuming the value <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">m</span> <span class="pre">n</span></code> is already determined, we define <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">m</span> <span class="pre">(succ</span> <span class="pre">n)</span></code> to be <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(add</span> <span class="pre">m</span> <span class="pre">n)</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A--%20BEGIN%0Anamespace%20nat%0A%0Adef%20add%20(m%20n%20%3A%20nat)%20%3A%20nat%20%3A%3D%0Anat.rec_on%20n%20m%20(%CE%BB%20n%20add_m_n%2C%20succ%20add_m_n)%0A%0A--%20try%20it%20out%0A%23reduce%20add%20(succ%20zero)%20(succ%20(succ%20zero))%0A%0Aend%20nat%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">def</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">add_m_n</span><span class="o">,</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">add_m_n</span><span class="o">)</span>

<span class="c1">-- try it out</span>
<span class="k">#reduce</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">zero</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">zero</span><span class="o">))</span>

<span class="kd">end</span><span class="w"> </span><span class="n">nat</span>
</pre></div>
</div>
</div><p>It is useful to put such definitions into a namespace, <code class="docutils literal notranslate"><span class="pre">nat</span></code>. We can then go on to define familiar notation in that namespace. The two defining equations for addition now hold definitionally:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20nat%20%3A%20Type%0A%7C%20zero%20%3A%20nat%0A%7C%20succ%20%3A%20nat%20%E2%86%92%20nat%0A%0Anamespace%20nat%0A%0Adef%20add%20(m%20n%20%3A%20nat)%20%3A%20nat%20%3A%3D%0Anat.rec_on%20n%20m%20(fun%20n%20add_m_n%2C%20succ%20add_m_n)%0A--%20BEGIN%0Ainstance%20%3A%20has_zero%20nat%20%3A%3D%20has_zero.mk%20zero%0Ainstance%20%3A%20has_add%20nat%20%3A%3D%20has_add.mk%20add%0A%0Atheorem%20add_zero%20(m%20%3A%20nat)%20%3A%20m%20%2B%200%20%3D%20m%20%3A%3D%20rfl%0Atheorem%20add_succ%20(m%20n%20%3A%20nat)%20%3A%20m%20%2B%20succ%20n%20%3D%20succ%20(m%20%2B%20n)%20%3A%3D%20rfl%0A--%20END%0Aend%20nat%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_zero</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">has_zero.mk</span><span class="w"> </span><span class="n">zero</span>
<span class="kd">instance</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">has_add</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">has_add.mk</span><span class="w"> </span><span class="n">add</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">add_zero</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">add_succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>We will explain how the <code class="docutils literal notranslate"><span class="pre">instance</span></code> command works in <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a>. In the examples below, we will henceforth use Lean&#8217;s version of the natural numbers.</p>
<p>Proving a fact like <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">m</span></code>, however, requires a proof by induction. As observed above, the induction principle is just a special case of the recursion principle, when the codomain <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">n</span></code> is an element of <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. It represents the familiar pattern of an inductive proof: to prove <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n,</span> <span class="pre">C</span> <span class="pre">n</span></code>, first prove <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">0</span></code>, and then, for arbitrary <code class="docutils literal notranslate"><span class="pre">n</span></code>, assume <code class="docutils literal notranslate"><span class="pre">ih</span> <span class="pre">:</span> <span class="pre">C</span> <span class="pre">n</span></code> and prove <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">(succ</span> <span class="pre">n)</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0A--%20BEGIN%0Atheorem%20zero_add%20(n%20%3A%20%E2%84%95)%20%3A%200%20%2B%20n%20%3D%20n%20%3A%3D%0Anat.rec_on%20n%0A%20%20(show%200%20%2B%200%20%3D%200%2C%20from%20rfl)%0A%20%20(assume%20n%2C%0A%20%20%20%20assume%20ih%20%3A%200%20%2B%20n%20%3D%20n%2C%0A%20%20%20%20show%200%20%2B%20succ%20n%20%3D%20succ%20n%2C%20from%0A%20%20%20%20%20%20calc%0A%20%20%20%20%20%20%20%200%20%2B%20succ%20n%20%3D%20succ%20(0%20%2B%20n)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20succ%20n%20%3A%20by%20rw%20ih)%0A%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">    </span><span class="k">assume</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="k">from</span>
<span class="w">      </span><span class="k">calc</span>
<span class="w">        </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rfl</span>
<span class="w">          </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="n">ih</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice that, once again, when <code class="docutils literal notranslate"><span class="pre">nat.rec_on</span></code> is used in the context of a proof, it is really the induction principle in disguise. The <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> and <code class="docutils literal notranslate"><span class="pre">simp</span></code> tactics tend to be very effective in proofs like these. In this case, each can be used to reduce the proof to a one-liner:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0A--%20BEGIN%0Atheorem%20zero_add%20(n%20%3A%20%E2%84%95)%20%3A%200%20%2B%20n%20%3D%20n%20%3A%3D%0Anat.rec_on%20n%20rfl%20(%CE%BB%20n%20ih%2C%20by%20rw%20%5Badd_succ%2C%20ih%5D)%0A%0Atheorem%20zero_add'%20(n%20%3A%20%E2%84%95)%20%3A%200%20%2B%20n%20%3D%20n%20%3A%3D%0Anat.rec_on%20n%20rfl%20(%CE%BB%20n%20ih%2C%20by%20simp%20only%20%5Badd_succ%2C%20ih%5D)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">])</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add&#39;</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">])</span>
</pre></div>
</div>
</div><p>The second example would be misleading without the <code class="docutils literal notranslate"><span class="pre">only</span></code> modifier, because <code class="docutils literal notranslate"><span class="pre">zero_add</span></code> is in fact declared to be a simplification rule in the standard library. Using <code class="docutils literal notranslate"><span class="pre">only</span></code> guarantees that <code class="docutils literal notranslate"><span class="pre">simp</span></code> only uses the identities listed.</p>
<p>For another example, let us prove the associativity of addition, <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">k,</span> <span class="pre">m</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">+</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">k)</span></code>. (The notation <code class="docutils literal notranslate"><span class="pre">+</span></code>, as we have defined it, associates to the left, so <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">k</span></code> is really <code class="docutils literal notranslate"><span class="pre">(m</span> <span class="pre">+</span> <span class="pre">n)</span> <span class="pre">+</span> <span class="pre">k</span></code>.) The hardest part is figuring out which variable to do the induction on. Since addition is defined by recursion on the second argument, <code class="docutils literal notranslate"><span class="pre">k</span></code> is a good guess, and once we make that choice the proof almost writes itself:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0A--%20BEGIN%0Atheorem%20add_assoc%20(m%20n%20k%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%20%3A%3D%0Anat.rec_on%20k%0A%20%20(show%20m%20%2B%20n%20%2B%200%20%3D%20m%20%2B%20(n%20%2B%200)%2C%20from%20rfl)%0A%20%20(assume%20k%2C%0A%20%20%20%20assume%20ih%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%2C%0A%20%20%20%20show%20m%20%2B%20n%20%2B%20succ%20k%20%3D%20m%20%2B%20(n%20%2B%20succ%20k)%2C%20from%0A%20%20%20%20%20%20calc%0A%20%20%20%20%20%20%20%20m%20%2B%20n%20%2B%20succ%20k%20%3D%20succ%20(m%20%2B%20n%20%2B%20k)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20succ%20(m%20%2B%20(n%20%2B%20k))%20%3A%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20m%20%2B%20succ%20(n%20%2B%20k)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20m%20%2B%20(n%20%2B%20succ%20k)%20%3A%20rfl)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">add_assoc</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">k</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">0</span><span class="o">),</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">k</span><span class="o">,</span>
<span class="w">    </span><span class="k">assume</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">),</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">k</span><span class="o">),</span><span class="w"> </span><span class="k">from</span>
<span class="w">      </span><span class="k">calc</span>
<span class="w">        </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rfl</span>
<span class="w">          </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="n">ih</span>
<span class="w">          </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rfl</span>
<span class="w">          </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
</pre></div>
</div>
</div><p>One again, there is a one-line proof:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0A--%20BEGIN%0Atheorem%20add_assoc%20(m%20n%20k%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%20%3A%3D%0Anat.rec_on%20k%20rfl%20(%CE%BB%20k%20ih%2C%20by%20simp%20only%20%5Badd_succ%2C%20ih%5D)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">add_assoc</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">])</span>
</pre></div>
</div>
</div><p>Suppose we try to prove the commutativity of addition. Choosing induction on the second argument, we might begin as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0Atheorem%20add_assoc%20(m%20n%20k%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%20%3A%3D%0Anat.rec_on%20k%0A%20%20(show%20m%20%2B%20n%20%2B%200%20%3D%20m%20%2B%20(n%20%2B%200)%2C%20from%20rfl)%0A%20%20(assume%20k%2C%0A%20%20%20%20assume%20ih%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%2C%0A%20%20%20%20show%20m%20%2B%20n%20%2B%20succ%20k%20%3D%20m%20%2B%20(n%20%2B%20succ%20k)%2C%20from%0A%20%20%20%20%20%20calc%0A%20%20%20%20%20%20%20%20m%20%2B%20n%20%2B%20succ%20k%20%3D%20succ%20(m%20%2B%20n%20%2B%20k)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20succ%20(m%20%2B%20(n%20%2B%20k))%20%3A%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20m%20%2B%20succ%20(n%20%2B%20k)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20m%20%2B%20(n%20%2B%20succ%20k)%20%3A%20rfl)%0A%0A--%20BEGIN%0Atheorem%20add_comm%20(m%20n%20%3A%20nat)%20%3A%20m%20%2B%20n%20%3D%20n%20%2B%20m%20%3A%3D%0Anat.rec_on%20n%0A%20%20(show%20m%20%2B%200%20%3D%200%20%2B%20m%2C%20by%20rw%20%5Bnat.zero_add%2C%20nat.add_zero%5D)%0A%20%20(assume%20n%2C%0A%20%20%20%20assume%20ih%20%3A%20m%20%2B%20n%20%3D%20n%20%2B%20m%2C%0A%20%20%20%20calc%0A%20%20%20%20%20%20m%20%2B%20succ%20n%20%3D%20succ%20(m%20%2B%20n)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20...%20%3D%20succ%20(n%20%2B%20m)%20%3A%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20...%20%3D%20succ%20n%20%2B%20m%20%3A%20sorry)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">add_comm</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">nat.zero_add</span><span class="o">,</span><span class="w"> </span><span class="n">nat.add_zero</span><span class="o">])</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">    </span><span class="k">assume</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="o">,</span>
<span class="w">    </span><span class="k">calc</span>
<span class="w">      </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rfl</span>
<span class="w">        </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="n">ih</span>
<span class="w">        </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="gr">sorry</span><span class="o">)</span>
</pre></div>
</div>
</div><p>At this point, we see that we need another supporting fact, namely, that <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">succ</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></code>. We can prove this by induction on <code class="docutils literal notranslate"><span class="pre">m</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0Atheorem%20add_assoc%20(m%20n%20k%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%20%3A%3D%0Anat.rec_on%20k%0A%20%20(show%20m%20%2B%20n%20%2B%200%20%3D%20m%20%2B%20(n%20%2B%200)%2C%20from%20rfl)%0A%20%20(assume%20k%2C%0A%20%20%20%20assume%20ih%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%2C%0A%20%20%20%20show%20m%20%2B%20n%20%2B%20succ%20k%20%3D%20m%20%2B%20(n%20%2B%20succ%20k)%2C%20from%0A%20%20%20%20%20%20calc%0A%20%20%20%20%20%20%20%20m%20%2B%20n%20%2B%20succ%20k%20%3D%20succ%20(m%20%2B%20n%20%2B%20k)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20succ%20(m%20%2B%20(n%20%2B%20k))%20%3A%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20m%20%2B%20succ%20(n%20%2B%20k)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20m%20%2B%20(n%20%2B%20succ%20k)%20%3A%20rfl)%0A%0A--%20BEGIN%0Atheorem%20succ_add%20(m%20n%20%3A%20nat)%20%3A%20succ%20m%20%2B%20n%20%3D%20succ%20(m%20%2B%20n)%20%3A%3D%0Anat.rec_on%20n%0A%20%20(show%20succ%20m%20%2B%200%20%3D%20succ%20(m%20%2B%200)%2C%20from%20rfl)%0A%20%20(assume%20n%2C%0A%20%20%20%20assume%20ih%20%3A%20succ%20m%20%2B%20n%20%3D%20succ%20(m%20%2B%20n)%2C%0A%20%20%20%20show%20succ%20m%20%2B%20succ%20n%20%3D%20succ%20(m%20%2B%20succ%20n)%2C%20from%0A%20%20%20%20%20%20calc%0A%20%20%20%20%20%20%20%20succ%20m%20%2B%20succ%20n%20%3D%20succ%20(succ%20m%20%2B%20n)%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20succ%20(succ%20(m%20%2B%20n))%20%3A%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20...%20%3D%20succ%20(m%20%2B%20succ%20n)%20%3A%20rfl)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">succ_add</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="o">(</span><span class="k">show</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">0</span><span class="o">),</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="k">assume</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">    </span><span class="k">assume</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">),</span>
<span class="w">    </span><span class="k">show</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">),</span><span class="w"> </span><span class="k">from</span>
<span class="w">      </span><span class="k">calc</span>
<span class="w">        </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rfl</span>
<span class="w">          </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="n">ih</span>
<span class="w">          </span><span class="bp">...</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rfl</span><span class="o">)</span>
</pre></div>
</div>
</div><p>We can then replace the <code class="docutils literal notranslate"><span class="pre">sorry</span></code> in the previous proof with <code class="docutils literal notranslate"><span class="pre">succ_add</span></code>. Yet again, the proofs can be compressed:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0Atheorem%20add_zero%20(m%20%3A%20nat)%20%3A%20m%20%2B%200%20%3D%20m%20%3A%3D%20rfl%0A%0Atheorem%20zero_add%20(n%20%3A%20%E2%84%95)%20%3A%200%20%2B%20n%20%3D%20n%20%3A%3D%0Anat.rec_on%20n%20rfl%20(%CE%BB%20n%20ih%2C%20by%20rw%20%5Badd_succ%2C%20ih%5D)%0A%0A--%20BEGIN%0Atheorem%20add_assoc%20(m%20n%20k%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%20%3A%3D%0Anat.rec_on%20k%20rfl%20(%CE%BB%20k%20ih%2C%20by%20simp%20only%20%5Badd_succ%2C%20ih%5D)%0A%0Atheorem%20succ_add%20(m%20n%20%3A%20nat)%20%3A%20succ%20m%20%2B%20n%20%3D%20succ%20(m%20%2B%20n)%20%3A%3D%0Anat.rec_on%20n%20rfl%20(%CE%BB%20n%20ih%2C%20by%20simp%20only%20%5Badd_succ%2C%20ih%5D)%0A%0Atheorem%20add_comm%20(m%20n%20%3A%20nat)%20%3A%20m%20%2B%20n%20%3D%20n%20%2B%20m%20%3A%3D%0Anat.rec_on%20n%0A%20%20(by%20simp%20only%20%5Bzero_add%2C%20add_zero%5D)%0A%20%20(%CE%BB%20n%20ih%2C%20by%20simp%20only%20%5Badd_succ%2C%20ih%2C%20succ_add%5D)%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">add_assoc</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">])</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">succ_add</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">])</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">add_comm</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:=</span>
<span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="o">(</span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">zero_add</span><span class="o">,</span><span class="w"> </span><span class="n">add_zero</span><span class="o">])</span>
<span class="w">  </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="kd">by</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="n">succ_add</span><span class="o">])</span>
</pre></div>
</div>
</div></section>
<section id="other-recursive-data-types">
<h2><span class="section-number">7.5. </span>Other Recursive Data Types<a class="headerlink" href="#other-recursive-data-types" title="Link to this heading">&#182;</a></h2>
<p>Let us consider some more examples of inductively defined types. For any type, <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, the type <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">&#945;</span></code> of lists of elements of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is defined in the library.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A--%20BEGIN%0Ainductive%20list%20(%CE%B1%20%3A%20Type*)%0A%7C%20nil%20%7B%7D%20%3A%20list%0A%7C%20cons%20%3A%20%CE%B1%20%E2%86%92%20list%20%E2%86%92%20list%0A%0Anamespace%20list%0A%0Avariable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Anotation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%20%3A%3D%20cons%20h%20t%0A%0Adef%20append%20(s%20t%20%3A%20list%20%CE%B1)%20%3A%20list%20%CE%B1%20%3A%3D%0Alist.rec%20t%20(%CE%BB%20x%20l%20u%2C%20x%3A%3Au)%20s%0A%0Anotation%20(name%20%3A%3D%20append)%20s%20%2B%2B%20t%20%3A%3D%20append%20s%20t%0A%0Atheorem%20nil_append%20(t%20%3A%20list%20%CE%B1)%20%3A%20nil%20%2B%2B%20t%20%3D%20t%20%3A%3D%20rfl%0A%0Atheorem%20cons_append%20(x%20%3A%20%CE%B1)%20(s%20t%20%3A%20list%20%CE%B1)%20%3A%0A%20%20x%3A%3As%20%2B%2B%20t%20%3D%20x%3A%3A(s%20%2B%2B%20t)%20%3A%3D%20rfl%0A%0Aend%20list%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span>
<span class="bp">|</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">list</span>

<span class="kd">variable</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="o">)</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">t</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">t</span>

<span class="kd">def</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="o">:=</span>
<span class="n">list.rec</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">u</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="o">::</span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="n">s</span>

<span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">append</span><span class="o">)</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">t</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">nil_append</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">cons_append</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">x</span><span class="o">::</span><span class="n">s</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">x</span><span class="o">::(</span><span class="n">s</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>

<span class="kd">end</span><span class="w"> </span><span class="n">list</span>
</pre></div>
</div>
</div><p>A list of elements of type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is either the empty list, <code class="docutils literal notranslate"><span class="pre">nil</span></code>, or an element <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">&#945;</span></code> followed by a list <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">list</span> <span class="pre">&#945;</span></code>. We define the notation <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">::</span> <span class="pre">t</span></code> to represent the latter. The first element, <code class="docutils literal notranslate"><span class="pre">h</span></code>, is commonly known as the &#8220;head&#8221; of the list, and the remainder, <code class="docutils literal notranslate"><span class="pre">t</span></code>, is known as the &#8220;tail.&#8221; Recall that the notation <code class="docutils literal notranslate"><span class="pre">{}</span></code> in the definition of the inductive type ensures that the argument to <code class="docutils literal notranslate"><span class="pre">nil</span></code> is implicit. In most cases, it can be inferred from context. When it cannot, we have to write <code class="docutils literal notranslate"><span class="pre">&#64;nil</span> <span class="pre">&#945;</span></code> to specify the type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>.</p>
<p>Lean allows us to define iterative notation for lists:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20list%20(%CE%B1%20%3A%20Type*)%0A%7C%20nil%20%7B%7D%20%3A%20list%0A%7C%20cons%20%3A%20%CE%B1%20%E2%86%92%20list%20%E2%86%92%20list%0A%0Anamespace%20list%0A%0Anotation%20(name%20%3A%3D%20list)%20%20%60%5B%60%20l%3A(foldr%20%60%2C%60%20(h%20t%2C%20cons%20h%20t)%20nil)%20%60%5D%60%20%3A%3D%20l%0A%0Asection%0Aopen%20nat%0A%23check%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%0A%23check%20(%5B1%2C%202%2C%203%2C%204%2C%205%5D%20%3A%20list%20int)%0Aend%0A%0Aend%20list%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span>
<span class="bp">|</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">list</span>

<span class="kd">notation</span><span class="w"> </span><span class="o">(</span><span class="n">name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">list</span><span class="o">)</span><span class="w">  </span><span class="bp">`</span><span class="o">[</span><span class="bp">`</span><span class="w"> </span><span class="n">l</span><span class="o">:(</span><span class="n">foldr</span><span class="w"> </span><span class="bp">`</span><span class="o">,</span><span class="bp">`</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="n">t</span><span class="o">,</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="n">nil</span><span class="o">)</span><span class="w"> </span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">l</span>

<span class="kn">section</span>
<span class="kn">open</span><span class="w"> </span><span class="n">nat</span>
<span class="k">#check</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]</span>
<span class="k">#check</span><span class="w"> </span><span class="o">([</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">int</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">end</span><span class="w"> </span><span class="n">list</span>
</pre></div>
</div>
</div><p>In the first <code class="docutils literal notranslate"><span class="pre">#check</span></code>, Lean assumes that <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5]</span></code> is a list of natural numbers. The <code class="docutils literal notranslate"><span class="pre">(t</span> <span class="pre">:</span> <span class="pre">list</span> <span class="pre">int)</span></code> expression forces Lean to interpret <code class="docutils literal notranslate"><span class="pre">t</span></code> as a list of integers.</p>
<p>As an exercise, prove the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0A%0Ainductive%20list%20(%CE%B1%20%3A%20Type*)%0A%7C%20nil%20%7B%7D%20%3A%20list%0A%7C%20cons%20%3A%20%CE%B1%20%E2%86%92%20list%20%E2%86%92%20list%0A%0Anamespace%20list%0A%0Anotation%20(name%20%3A%3D%20list)%20%20%60%5B%60%20l%3A(foldr%20%60%2C%60%20(h%20t%2C%20cons%20h%20t)%20nil)%20%60%5D%60%20%3A%3D%20l%0A%0Avariable%20%7B%CE%B1%20%3A%20Type*%7D%0A%0Anotation%20(name%20%3A%3D%20cons)%20h%20%3A%3A%20t%20%20%3A%3D%20cons%20h%20t%0A%0Adef%20append%20(s%20t%20%3A%20list%20%CE%B1)%20%3A%20list%20%CE%B1%20%3A%3D%0Alist.rec_on%20s%20t%20(%CE%BB%20x%20l%20u%2C%20x%3A%3Au)%0A%0Anotation%20(name%20%3A%3D%20append)%20s%20%2B%2B%20t%20%3A%3D%20append%20s%20t%0A%0Atheorem%20nil_append%20(t%20%3A%20list%20%CE%B1)%20%3A%20nil%20%2B%2B%20t%20%3D%20t%20%3A%3D%20rfl%0A%0Atheorem%20cons_append%20(x%20%3A%20%CE%B1)%20(s%20t%20%3A%20list%20%CE%B1)%20%3A%20x%3A%3As%20%2B%2B%20t%20%3D%20x%3A%3A(s%20%2B%2B%20t)%20%3A%3D%20rfl%0A%0A--%20BEGIN%0Atheorem%20append_nil%20(t%20%3A%20list%20%CE%B1)%20%3A%20t%20%2B%2B%20nil%20%3D%20t%20%3A%3D%20sorry%0A%0Atheorem%20append_assoc%20(r%20s%20t%20%3A%20list%20%CE%B1)%20%3A%0A%20%20r%20%2B%2B%20s%20%2B%2B%20t%20%3D%20r%20%2B%2B%20(s%20%2B%2B%20t)%20%3A%3D%20sorry%0A--%20END%0A%0Aend%20list%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">append_nil</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">append_assoc</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="w"> </span><span class="bp">++</span><span class="w"> </span><span class="n">t</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="gr">sorry</span>
</pre></div>
</div>
</div><p>Try also defining the function <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">:</span> <span class="pre">&#928;</span> <span class="pre">{&#945;</span> <span class="pre">:</span> <span class="pre">Type*},</span> <span class="pre">list</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">nat</span></code> that returns the length of a list, and prove that it behaves as expected (for example, <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">(s</span> <span class="pre">++</span> <span class="pre">t)</span> <span class="pre">=</span> <span class="pre">length</span> <span class="pre">s</span> <span class="pre">+</span> <span class="pre">length</span> <span class="pre">t</span></code>).</p>
<p>For another example, we can define the type of binary trees:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20binary_tree%0A%7C%20leaf%20%3A%20binary_tree%0A%7C%20node%20%3A%20binary_tree%20%E2%86%92%20binary_tree%20%E2%86%92%20binary_tree" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">binary_tree</span>
<span class="bp">|</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">binary_tree</span>
<span class="bp">|</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">binary_tree</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">binary_tree</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">binary_tree</span>
</pre></div>
</div>
</div><p>In fact, we can even define the type of countably branching trees:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20cbtree%0A%7C%20leaf%20%3A%20cbtree%0A%7C%20sup%20%3A%20(%E2%84%95%20%E2%86%92%20cbtree)%20%E2%86%92%20cbtree%0A%0Anamespace%20cbtree%0A%0Adef%20succ%20(t%20%3A%20cbtree)%20%3A%20cbtree%20%3A%3D%0Asup%20(%CE%BB%20n%2C%20t)%0A%0Adef%20omega%20%3A%20cbtree%20%3A%3D%0Asup%20(%CE%BB%20n%2C%20nat.rec_on%20n%20leaf%20(%CE%BB%20n%20t%2C%20succ%20t))%0A%0Aend%20cbtree" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">cbtree</span>
<span class="bp">|</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cbtree</span>
<span class="bp">|</span><span class="w"> </span><span class="n">sup</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">cbtree</span><span class="o">)</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">cbtree</span>

<span class="kn">namespace</span><span class="w"> </span><span class="n">cbtree</span>

<span class="kd">def</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cbtree</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cbtree</span><span class="w"> </span><span class="o">:=</span>
<span class="n">sup</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">t</span><span class="o">)</span>

<span class="kd">def</span><span class="w"> </span><span class="n">omega</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cbtree</span><span class="w"> </span><span class="o">:=</span>
<span class="n">sup</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">nat.rec_on</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="o">(</span><span class="bp">&#955;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">t</span><span class="o">,</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">t</span><span class="o">))</span>

<span class="kd">end</span><span class="w"> </span><span class="n">cbtree</span>
</pre></div>
</div>
</div></section>
<section id="tactics-for-inductive-types">
<span id="id3"></span><h2><span class="section-number">7.6. </span>Tactics for Inductive Types<a class="headerlink" href="#tactics-for-inductive-types" title="Link to this heading">&#182;</a></h2>
<p>Given the fundamental importance of inductive types in Lean, it should not be surprising that there are a number of tactics designed to work with them effectively. We describe some of them here.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic works on elements of an inductively defined type, and does what the name suggests: it decomposes the element according to each of the possible constructors. In its most basic form, it is applied to an element <code class="docutils literal notranslate"><span class="pre">x</span></code> in the local context. It then reduces the goal to cases in which <code class="docutils literal notranslate"><span class="pre">x</span></code> is replaced by each of the constructions.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0Avariable%20p%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%0Aexample%20(hz%20%3A%20p%200)%20(hs%20%3A%20%E2%88%80%20n%2C%20p%20(succ%20n))%20%3A%20%E2%88%80%20n%2C%20p%20n%20%3A%3D%0Abegin%0A%20%20intro%20n%2C%0A%20%20cases%20n%2C%0A%20%20%7B%20exact%20hz%20%7D%2C%20%20--%20goal%20is%20p%200%0A%20%20apply%20hs%20%20%20%20%20%20%20--%20goal%20is%20a%20%3A%20%E2%84%95%20%E2%8A%A2%20p%20(succ%20a)%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hz</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">intro</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">hz</span><span class="w"> </span><span class="o">},</span><span class="w">  </span><span class="c1">-- goal is p 0</span>
<span class="w">  </span><span class="n">apply</span><span class="w"> </span><span class="n">hs</span><span class="w">       </span><span class="c1">-- goal is a : &#8469; &#8866; p (succ a)</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>There are extra bells and whistles. For one thing, <code class="docutils literal notranslate"><span class="pre">cases</span></code> allows you to choose the names for the arguments to the constructors using a <code class="docutils literal notranslate"><span class="pre">with</span></code> clause. In the next example, for example, we choose the name <code class="docutils literal notranslate"><span class="pre">m</span></code> for the argument to <code class="docutils literal notranslate"><span class="pre">succ</span></code>, so that the second case refers to <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">m</span></code>. More importantly, the cases tactic will detect any items in the local context that depend on the target variable. It reverts these elements, does the split, and reintroduces them. In the example below, notice that the hypothesis <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">n</span> <span class="pre">&#8800;</span> <span class="pre">0</span></code> becomes <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">0</span> <span class="pre">&#8800;</span> <span class="pre">0</span></code> in the first branch, and <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">succ</span> <span class="pre">m</span> <span class="pre">&#8800;</span> <span class="pre">0</span></code> in the second.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0Aexample%20(n%20%3A%20%E2%84%95)%20(h%20%3A%20n%20%E2%89%A0%200)%20%3A%20succ%20(pred%20n)%20%3D%20n%20%3A%3D%0Abegin%0A%20%20cases%20n%20with%20m%2C%0A%20%20--%20first%20goal%3A%20h%20%3A%200%20%E2%89%A0%200%20%E2%8A%A2%20succ%20(pred%200)%20%3D%200%0A%20%20%20%20%7B%20apply%20(absurd%20rfl%20h)%20%7D%2C%0A%20%20--%20second%20goal%3A%20h%20%3A%20succ%20m%20%E2%89%A0%200%20%E2%8A%A2%20succ%20(pred%20(succ%20m))%20%3D%20succ%20m%0A%20%20reflexivity%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8800;</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">pred</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">m</span><span class="o">,</span>
<span class="w">  </span><span class="c1">-- first goal: h : 0 &#8800; 0 &#8866; succ (pred 0) = 0</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="n">apply</span><span class="w"> </span><span class="o">(</span><span class="n">absurd</span><span class="w"> </span><span class="n">rfl</span><span class="w"> </span><span class="n">h</span><span class="o">)</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="c1">-- second goal: h : succ m &#8800; 0 &#8866; succ (pred (succ m)) = succ m</span>
<span class="w">  </span><span class="n">reflexivity</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Notice that <code class="docutils literal notranslate"><span class="pre">cases</span></code> can be used to produce data as well as prove propositions.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20f%20(n%20%3A%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Abegin%0A%20%20cases%20n%2C%20exact%203%2C%20exact%207%0Aend%0A%0Aexample%20%3A%20f%200%20%3D%203%20%3A%3D%20rfl%0Aexample%20%3A%20f%205%20%3D%207%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="mi">7</span>
<span class="kd">end</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>Once again, cases will revert, split, and then reintroduce dependencies in the context.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20tuple%20(%CE%B1%20%3A%20Type*)%20(n%20%3A%20%E2%84%95)%20%3A%3D%0A%20%20%7B%20l%20%3A%20list%20%CE%B1%20%2F%2F%20list.length%20l%20%3D%20n%20%7D%0A%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%7Bn%20%3A%20%E2%84%95%7D%0A%0Adef%20f%20%7Bn%20%3A%20%E2%84%95%7D%20(t%20%3A%20tuple%20%CE%B1%20n)%20%3A%20%E2%84%95%20%3A%3D%0Abegin%0A%20%20cases%20n%2C%20exact%203%2C%20exact%207%0Aend%0A%0Adef%20my_tuple%20%3A%20tuple%20%E2%84%95%203%20%3A%3D%20%20%E2%9F%A8%5B0%2C%201%2C%202%5D%2C%20rfl%E2%9F%A9%0A%0Aexample%20%3A%20f%20my_tuple%20%3D%207%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">//</span><span class="w"> </span><span class="n">list.length</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">}</span>

<span class="kd">variables</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">}</span>

<span class="kd">def</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="mi">7</span>
<span class="kd">end</span>

<span class="kd">def</span><span class="w"> </span><span class="n">my_tuple</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">:=</span><span class="w">  </span><span class="o">&#10216;[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">],</span><span class="w"> </span><span class="n">rfl</span><span class="o">&#10217;</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">my_tuple</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>If there are multiple constructors with arguments, you can provide <code class="docutils literal notranslate"><span class="pre">cases</span></code> with a list of all the names, arranged sequentially:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20foo%20%3A%20Type%0A%7C%20bar1%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20foo%0A%7C%20bar2%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20foo%0A%0Adef%20silly%20(x%20%3A%20foo)%20%3A%20%E2%84%95%20%3A%3D%0Abegin%0A%20%20cases%20x%20with%20a%20b%20c%20d%20e%2C%0A%20%20exact%20b%2C%20%20%20%20--%20a%2C%20b%20%20%20%20are%20in%20the%20context%0A%20%20exact%20e%20%20%20%20%20--%20c%2C%20d%2C%20e%20are%20in%20the%20context%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">bar1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">foo</span>
<span class="bp">|</span><span class="w"> </span><span class="n">bar2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">foo</span>

<span class="kd">def</span><span class="w"> </span><span class="n">silly</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="o">,</span>
<span class="w">  </span><span class="n">exact</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w">    </span><span class="c1">-- a, b    are in the context</span>
<span class="w">  </span><span class="n">exact</span><span class="w"> </span><span class="n">e</span><span class="w">     </span><span class="c1">-- c, d, e are in the context</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The syntax of the <code class="docutils literal notranslate"><span class="pre">with</span></code> is unfortunate, in that we have to list the arguments to all the constructors sequentially, making it hard to remember what the constructors are, or what the arguments are supposed to be. For that reason, Lean provides a complementary <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic, which allows one to assign variable names after the fact:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20foo%20%3A%20Type%0A%7C%20bar1%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20foo%0A%7C%20bar2%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20foo%0A%0Aopen%20foo%0A%0Adef%20silly%20(x%20%3A%20foo)%20%3A%20%E2%84%95%20%3A%3D%0Abegin%0A%20%20cases%20x%2C%0A%20%20%20%20case%20bar1%20%3A%20a%20b%0A%20%20%20%20%20%20%7B%20exact%20b%20%7D%2C%0A%20%20%20%20case%20bar2%20%3A%20c%20d%20e%0A%20%20%20%20%20%20%7B%20exact%20e%20%7D%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">bar1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">foo</span>
<span class="bp">|</span><span class="w"> </span><span class="n">bar2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">foo</span>

<span class="kn">open</span><span class="w"> </span><span class="n">foo</span>

<span class="kd">def</span><span class="w"> </span><span class="n">silly</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">x</span><span class="o">,</span>
<span class="w">    </span><span class="n">case</span><span class="w"> </span><span class="n">bar1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>
<span class="w">      </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">},</span>
<span class="w">    </span><span class="n">case</span><span class="w"> </span><span class="n">bar2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span>
<span class="w">      </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">}</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic is clever, in that it will match the constructor to the appropriate goal. For example, we can fill the goals above in the opposite order:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20foo%20%3A%20Type%0A%7C%20bar1%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20foo%0A%7C%20bar2%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20foo%0A%0Aopen%20foo%0A%0Adef%20silly%20(x%20%3A%20foo)%20%3A%20%E2%84%95%20%3A%3D%0Abegin%0A%20%20cases%20x%2C%0A%20%20%20%20case%20bar2%20%3A%20c%20d%20e%0A%20%20%20%20%20%20%7B%20exact%20e%20%7D%2C%0A%20%20%20%20case%20bar1%20%3A%20a%20b%0A%20%20%20%20%20%20%7B%20exact%20b%20%7D%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span>
<span class="bp">|</span><span class="w"> </span><span class="n">bar1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">foo</span>
<span class="bp">|</span><span class="w"> </span><span class="n">bar2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">foo</span>

<span class="kn">open</span><span class="w"> </span><span class="n">foo</span>

<span class="kd">def</span><span class="w"> </span><span class="n">silly</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">x</span><span class="o">,</span>
<span class="w">    </span><span class="n">case</span><span class="w"> </span><span class="n">bar2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span>
<span class="w">      </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">},</span>
<span class="w">    </span><span class="n">case</span><span class="w"> </span><span class="n">bar1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>
<span class="w">      </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">}</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>You can also use <code class="docutils literal notranslate"><span class="pre">cases</span></code> with an arbitrary expression. Assuming that expression occurs in the goal, the cases tactic will generalize over the expression, introduce the resulting universally quantified variable, and case on that.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0Avariable%20p%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%0Aexample%20(hz%20%3A%20p%200)%20(hs%20%3A%20%E2%88%80%20n%2C%20p%20(succ%20n))%20(m%20k%20%3A%20%E2%84%95)%20%3A%0A%20%20p%20(m%20%2B%203%20*%20k)%20%3A%3D%0Abegin%0A%20%20cases%20(m%20%2B%203%20*%20k)%2C%0A%20%20%7B%20exact%20hz%20%7D%2C%20%20--%20goal%20is%20p%200%0A%20%20apply%20hs%20%20%20%20%20%20%20--%20goal%20is%20a%20%3A%20%E2%84%95%20%E2%8A%A2%20p%20(succ%20a)%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>
<span class="kd">variable</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hz</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">))</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">k</span><span class="o">),</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">hz</span><span class="w"> </span><span class="o">},</span><span class="w">  </span><span class="c1">-- goal is p 0</span>
<span class="w">  </span><span class="n">apply</span><span class="w"> </span><span class="n">hs</span><span class="w">       </span><span class="c1">-- goal is a : &#8469; &#8866; p (succ a)</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Think of this as saying &#8220;split on cases as to whether <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">k</span></code> is zero or the successor of some number.&#8221; The result is functionally equivalent to the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0Avariable%20p%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%0A--%20BEGIN%0Aexample%20(hz%20%3A%20p%200)%20(hs%20%3A%20%E2%88%80%20n%2C%20p%20(succ%20n))%20(m%20k%20%3A%20%E2%84%95)%20%3A%0A%20%20p%20(m%20%2B%203%20*%20k)%20%3A%3D%0Abegin%0A%20%20generalize%20%3A%20m%20%2B%203%20*%20k%20%3D%20n%2C%0A%20%20cases%20n%2C%0A%20%20%7B%20exact%20hz%20%7D%2C%20%20--%20goal%20is%20p%200%0A%20%20apply%20hs%20%20%20%20%20%20%20--%20goal%20is%20a%20%3A%20%E2%84%95%20%E2%8A%A2%20p%20(succ%20a)%0Aend%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">hz</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">hs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">))</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">generalize</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">hz</span><span class="w"> </span><span class="o">},</span><span class="w">  </span><span class="c1">-- goal is p 0</span>
<span class="w">  </span><span class="n">apply</span><span class="w"> </span><span class="n">hs</span><span class="w">       </span><span class="c1">-- goal is a : &#8469; &#8866; p (succ a)</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Notice that the expression <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">k</span></code> is erased by generalize; all that matters is whether it is of the form <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">a</span></code>. This form of <code class="docutils literal notranslate"><span class="pre">cases</span></code> will <em>not</em> revert any hypotheses that also mention the expression in equation (in this case, <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">k</span></code>). If such a term appears in a hypothesis and you want to generalize over that as well, you need to <code class="docutils literal notranslate"><span class="pre">revert</span></code> it explicitly.</p>
<p>If the expression you case on does not appear in the goal, the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic uses <code class="docutils literal notranslate"><span class="pre">have</span></code> to put the type of the expression into the context. Here is an example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20(p%20%3A%20Prop)%20(m%20n%20%3A%20%E2%84%95)%0A%20%20(h%E2%82%81%20%3A%20m%20%3C%20n%20%E2%86%92%20p)%20(h%E2%82%82%20%3A%20m%20%E2%89%A5%20n%20%E2%86%92%20p)%20%3A%20p%20%3A%3D%0Abegin%0A%20%20cases%20lt_or_ge%20m%20n%20with%20hlt%20hge%2C%0A%20%20%7B%20exact%20h%E2%82%81%20hlt%20%7D%2C%0A%20%20exact%20h%E2%82%82%20hge%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&#8805;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">lt_or_ge</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">hlt</span><span class="w"> </span><span class="n">hge</span><span class="o">,</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">hlt</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="n">exact</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="n">hge</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The theorem <code class="docutils literal notranslate"><span class="pre">lt_or_ge</span> <span class="pre">m</span> <span class="pre">n</span></code> says <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">n</span> <span class="pre">&#8744;</span> <span class="pre">m</span> <span class="pre">&#8805;</span> <span class="pre">n</span></code>, and it is natural to think of the proof above as splitting on these two cases. In the first branch, we have the hypothesis <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">n</span></code>, and in the second we have the hypothesis <code class="docutils literal notranslate"><span class="pre">h&#8322;</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">&#8805;</span> <span class="pre">n</span></code>. The proof above is functionally equivalent to the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20(p%20%3A%20Prop)%20(m%20n%20%3A%20%E2%84%95)%0A%20%20(h%E2%82%81%20%3A%20m%20%3C%20n%20%E2%86%92%20p)%20(h%E2%82%82%20%3A%20m%20%E2%89%A5%20n%20%E2%86%92%20p)%20%3A%20p%20%3A%3D%0Abegin%0A%20%20have%20h%20%3A%20m%20%3C%20n%20%E2%88%A8%20m%20%E2%89%A5%20n%2C%0A%20%20%7B%20exact%20lt_or_ge%20m%20n%20%7D%2C%0A%20%20cases%20h%20with%20hlt%20hge%2C%0A%20%20%7B%20exact%20h%E2%82%81%20hlt%20%7D%2C%0A%20%20exact%20h%E2%82%82%20hge%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&#8805;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">p</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="k">have</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&#8805;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">lt_or_ge</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">hlt</span><span class="w"> </span><span class="n">hge</span><span class="o">,</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">h&#8321;</span><span class="w"> </span><span class="n">hlt</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="n">exact</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="n">hge</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>After the first two lines, we have <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">n</span> <span class="pre">&#8744;</span> <span class="pre">m</span> <span class="pre">&#8805;</span> <span class="pre">n</span></code> as a hypothesis, and we simply do cases on that.</p>
<p>Here is another example, where we use the decidability of equality on the natural numbers to split on the cases <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#8800;</span> <span class="pre">n</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20nat.sub_self%0A%0Aexample%20(m%20n%20%3A%20%E2%84%95)%20%3A%20m%20-%20n%20%3D%200%20%E2%88%A8%20m%20%E2%89%A0%20n%20%3A%3D%0Abegin%0A%20%20cases%20decidable.em%20(m%20%3D%20n)%20with%20heq%20hne%2C%0A%20%20%7B%20rw%20heq%2C%0A%20%20%20%20left%2C%20exact%20nat.sub_self%20n%20%7D%2C%0A%20%20right%2C%20exact%20hne%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span><span class="w"> </span><span class="n">nat.sub_self</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">&#8744;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">&#8800;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">decidable.em</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">heq</span><span class="w"> </span><span class="n">hne</span><span class="o">,</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="n">heq</span><span class="o">,</span>
<span class="w">    </span><span class="n">left</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">nat.sub_self</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="n">right</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">hne</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Remember that if you <code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">classical</span></code>, you can use the law of the excluded middle for any proposition at all. But using type class inference (see <a class="reference internal" href="type_classes.html#type-classes"><span class="std std-numref">Chapter 10</span></a>), Lean can actually find the relevant decision procedure, which means that you can use the case split in a computable function.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20f%20(m%20k%20%3A%20%E2%84%95)%20%3A%20%E2%84%95%20%3A%3D%0Abegin%0A%20%20cases%20m%20-%20k%2C%20exact%203%2C%20exact%207%0Aend%0A%0Aexample%20%3A%20f%205%207%20%3D%203%20%3A%3D%20rfl%0Aexample%20%3A%20f%2010%202%20%3D%207%20%3A%3D%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">cases</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">-</span><span class="w"> </span><span class="n">k</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="mi">7</span>
<span class="kd">end</span>

<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
<span class="kd">example</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rfl</span>
</pre></div>
</div>
</div><p>Aspects of computability will be discussed in <a class="reference internal" href="axioms_and_computation.html#axioms-and-computation"><span class="std std-numref">Chapter 11</span></a>.</p>
<p>Just as the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic can be used to carry out proof by cases, the <code class="docutils literal notranslate"><span class="pre">induction</span></code> tactic can be used to carry out proofs by induction. The syntax is similar to that of <code class="docutils literal notranslate"><span class="pre">cases</span></code>, except that the argument can only be a term in the local context. Here is an example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0A--%20BEGIN%0Atheorem%20zero_add%20(n%20%3A%20%E2%84%95)%20%3A%200%20%2B%20n%20%3D%20n%20%3A%3D%0Abegin%0A%20%20induction%20n%20with%20n%20ih%2C%0A%20%20%20%20refl%2C%0A%20%20rw%20%5Badd_succ%2C%20ih%5D%0Aend%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span>
<span class="w">    </span><span class="n">refl</span><span class="o">,</span>
<span class="w">  </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">]</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As with <code class="docutils literal notranslate"><span class="pre">cases</span></code>, we can use the <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic instead to identify one case at a time and name the arguments:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0A--%20BEGIN%0Atheorem%20zero_add%20(n%20%3A%20%E2%84%95)%20%3A%200%20%2B%20n%20%3D%20n%20%3A%3D%0Abegin%0A%20%20induction%20n%2C%0A%20%20case%20zero%20%3A%20%7B%20refl%20%7D%2C%0A%20%20case%20succ%20%3A%20n%20ih%20%7B%20rw%20%5Badd_succ%2C%20ih%5D%7D%0Aend%0A%0Atheorem%20succ_add%20(m%20n%20%3A%20%E2%84%95)%20%3A%20succ%20m%20%2B%20n%20%3D%20succ%20(m%20%2B%20n)%20%3A%3D%0Abegin%0A%20%20induction%20n%2C%0A%20%20case%20zero%20%3A%20%7B%20refl%20%7D%2C%0A%20%20case%20succ%20%3A%20n%20ih%20%7B%20rw%20%5Badd_succ%2C%20add_succ%2C%20ih%5D%20%7D%0Aend%0A%0Atheorem%20add_comm%20(m%20n%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%3D%20n%20%2B%20m%20%3A%3D%0Abegin%0A%20%20induction%20n%2C%0A%20%20case%20zero%20%3A%20%7B%20rw%20zero_add%2C%20refl%20%7D%2C%0A%20%20case%20succ%20%3A%20n%20ih%20%7B%20rw%20%5Badd_succ%2C%20ih%2C%20succ_add%5D%20%7D%0Aend%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="n">case</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">refl</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="n">case</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">]}</span>
<span class="kd">end</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">succ_add</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="n">case</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">refl</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="n">case</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">]</span><span class="w"> </span><span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">add_comm</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="o">,</span>
<span class="w">  </span><span class="n">case</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="n">zero_add</span><span class="o">,</span><span class="w"> </span><span class="n">refl</span><span class="w"> </span><span class="o">},</span>
<span class="w">  </span><span class="n">case</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ih</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">rw</span><span class="w"> </span><span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">ih</span><span class="o">,</span><span class="w"> </span><span class="n">succ_add</span><span class="o">]</span><span class="w"> </span><span class="o">}</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The name before the colon corresponds to the constructor of the associated inductive type. The cases can appear in any order, and when there are no parameters to rename (for example, as in the <code class="docutils literal notranslate"><span class="pre">zero</span></code> cases above) the colon can be omitted. Once again, we can reduce the proofs of these, as well as the proof of associativity, to one-liners.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Aopen%20nat%0A%0Atheorem%20add_zero%20(m%20%3A%20nat)%20%3A%20m%20%2B%200%20%3D%20m%20%3A%3D%20rfl%0A%0A--%20BEGIN%0Atheorem%20zero_add%20(n%20%3A%20%E2%84%95)%20%3A%200%20%2B%20n%20%3D%20n%20%3A%3D%0Aby%20induction%20n%3B%20simp%20only%20%5B*%2C%20add_zero%2C%20add_succ%5D%0A%0Atheorem%20succ_add%20(m%20n%20%3A%20%E2%84%95)%20%3A%20succ%20m%20%2B%20n%20%3D%20succ%20(m%20%2B%20n)%20%3A%3D%0Aby%20induction%20n%3B%20simp%20only%20%5B*%2C%20add_zero%2C%20add_succ%5D%0A%0Atheorem%20add_comm%20(m%20n%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%3D%20n%20%2B%20m%20%3A%3D%0Aby%20induction%20n%3B%0A%20%20%20%20%20simp%20only%20%5B*%2C%20add_zero%2C%20add_succ%2C%20succ_add%2C%20zero_add%5D%0A%0Atheorem%20add_assoc%20(m%20n%20k%20%3A%20%E2%84%95)%20%3A%20m%20%2B%20n%20%2B%20k%20%3D%20m%20%2B%20(n%20%2B%20k)%20%3A%3D%0Aby%20induction%20k%3B%20simp%20only%20%5B*%2C%20add_zero%2C%20add_succ%5D%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">zero_add</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="bp">;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="bp">*</span><span class="o">,</span><span class="w"> </span><span class="n">add_zero</span><span class="o">,</span><span class="w"> </span><span class="n">add_succ</span><span class="o">]</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">succ_add</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="bp">;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="bp">*</span><span class="o">,</span><span class="w"> </span><span class="n">add_zero</span><span class="o">,</span><span class="w"> </span><span class="n">add_succ</span><span class="o">]</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">add_comm</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="bp">;</span>
<span class="w">     </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="bp">*</span><span class="o">,</span><span class="w"> </span><span class="n">add_zero</span><span class="o">,</span><span class="w"> </span><span class="n">add_succ</span><span class="o">,</span><span class="w"> </span><span class="n">succ_add</span><span class="o">,</span><span class="w"> </span><span class="n">zero_add</span><span class="o">]</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">add_assoc</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">induction</span><span class="w"> </span><span class="n">k</span><span class="bp">;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">[</span><span class="bp">*</span><span class="o">,</span><span class="w"> </span><span class="n">add_zero</span><span class="o">,</span><span class="w"> </span><span class="n">add_succ</span><span class="o">]</span>
</pre></div>
</div>
</div><p>We close this section with one last tactic that is designed to facilitate working with inductive types, namely, the <code class="docutils literal notranslate"><span class="pre">injection</span></code> tactic. By design, the elements of an inductive type are freely generated, which is to say, the constructors are injective and have disjoint ranges. The <code class="docutils literal notranslate"><span class="pre">injection</span></code> tactic is designed to make use of this fact:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0Aexample%20(m%20n%20k%20%3A%20%E2%84%95)%20(h%20%3A%20succ%20(succ%20m)%20%3D%20succ%20(succ%20n))%20%3A%0A%20%20n%20%2B%20k%20%3D%20m%20%2B%20k%20%3A%3D%0Abegin%0A%20%20injection%20h%20with%20h'%2C%0A%20%20injection%20h'%20with%20h''%2C%0A%20%20rw%20h''%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span><span class="w"> </span><span class="n">nat</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">))</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">injection</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">h&#39;</span><span class="o">,</span>
<span class="w">  </span><span class="n">injection</span><span class="w"> </span><span class="n">h&#39;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">h&#39;&#39;</span><span class="o">,</span>
<span class="w">  </span><span class="n">rw</span><span class="w"> </span><span class="n">h&#39;&#39;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The first instance of the tactic adds <code class="docutils literal notranslate"><span class="pre">h'</span> <span class="pre">:</span> <span class="pre">succ</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">succ</span> <span class="pre">n</span></code> to the context, and the second adds <code class="docutils literal notranslate"><span class="pre">h''</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">n</span></code>. The plural variant, <code class="docutils literal notranslate"><span class="pre">injections</span></code>, applies <code class="docutils literal notranslate"><span class="pre">injection</span></code> to all hypotheses repeatedly. It still allows you to name the results using <code class="docutils literal notranslate"><span class="pre">with</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0A--%20BEGIN%0Aexample%20(m%20n%20k%20%3A%20%E2%84%95)%20(h%20%3A%20succ%20(succ%20m)%20%3D%20succ%20(succ%20n))%20%3A%0A%20%20n%20%2B%20k%20%3D%20m%20%2B%20k%20%3A%3D%0Abegin%0A%20%20injections%20with%20h'%20h''%2C%0A%20%20rw%20h''%0Aend%0A%0Aexample%20(m%20n%20k%20%3A%20%E2%84%95)%20(h%20%3A%20succ%20(succ%20m)%20%3D%20succ%20(succ%20n))%20%3A%0A%20%20n%20%2B%20k%20%3D%20m%20%2B%20k%20%3A%3D%0Aby%20injections%3B%20simp%20*%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">))</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="w">  </span><span class="n">injections</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">h&#39;</span><span class="w"> </span><span class="n">h&#39;&#39;</span><span class="o">,</span>
<span class="w">  </span><span class="n">rw</span><span class="w"> </span><span class="n">h&#39;&#39;</span>
<span class="kd">end</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="o">)</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">))</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">injections</span><span class="bp">;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="bp">*</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">injection</span></code> and <code class="docutils literal notranslate"><span class="pre">injections</span></code> tactics will also detect contradictions that arise when different constructors are set equal to one another, and use them to close the goal.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0A%0A--%20BEGIN%0Aexample%20(m%20n%20%3A%20%E2%84%95)%20(h%20%3A%20succ%20m%20%3D%200)%20%3A%20n%20%3D%20n%20%2B%207%20%3A%3D%0Aby%20injections%0A%0Aexample%20(m%20n%20%3A%20%E2%84%95)%20(h%20%3A%20succ%20m%20%3D%200)%20%3A%20n%20%3D%20n%20%2B%207%20%3A%3D%0Aby%20contradiction%0A%0Aexample%20(h%20%3A%207%20%3D%204)%20%3A%20false%20%3A%3D%0Aby%20injections%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">injections</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">contradiction</span>

<span class="kd">example</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">4</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="o">:=</span>
<span class="kd">by</span><span class="w"> </span><span class="n">injections</span>
</pre></div>
</div>
</div><p>As the second example shows, the <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> tactic also detects contradictions of this form. But the <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> tactic does not solve the third goal, while <code class="docutils literal notranslate"><span class="pre">injections</span></code> does.</p>
</section>
<section id="inductive-families">
<h2><span class="section-number">7.7. </span>Inductive Families<a class="headerlink" href="#inductive-families" title="Link to this heading">&#182;</a></h2>
<p>We are almost done describing the full range of inductive definitions accepted by Lean. So far, you have seen that Lean allows you to introduce inductive types with any number of recursive constructors. In fact, a single inductive definition can introduce an indexed <em>family</em> of inductive types, in a manner we now describe.</p>
<p>An inductive family is an indexed family of types defined by a simultaneous induction of the following form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>inductive foo : ... &#8594; Sort u :=
| constructor&#8321; : ... &#8594; foo ...
| constructor&#8322; : ... &#8594; foo ...
...
| constructor&#8345; : ... &#8594; foo ...
</pre></div>
</div>
<p>In contrast to ordinary inductive definition, which constructs an element of some <code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">u</span></code>, the more general version constructs a function <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">&#8594;</span> <span class="pre">Sort</span> <span class="pre">u</span></code>, where &#8220;<code class="docutils literal notranslate"><span class="pre">...</span></code>&#8221; denotes a sequence of argument types, also known as <em>indices</em>. Each constructor then constructs an element of some member of the family. One example is the definition of <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">&#945;</span> <span class="pre">n</span></code>, the type of vectors of elements of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20nat%0Auniverse%20u%0Anamespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20vector%20(%CE%B1%20%3A%20Type%20u)%20%3A%20nat%20%E2%86%92%20Type%20u%0A%7C%20nil%20%7B%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20vector%20zero%0A%7C%20cons%20%7Bn%20%3A%20%E2%84%95%7D%20(a%20%3A%20%CE%B1)%20(v%20%3A%20vector%20n)%20%3A%20vector%20(succ%20n)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">nat</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span>
<span class="bp">|</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">{}</span><span class="w">                              </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">zero</span>
<span class="bp">|</span><span class="w"> </span><span class="n">cons</span><span class="w"> </span><span class="o">{</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="o">(</span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice that the <code class="docutils literal notranslate"><span class="pre">cons</span></code> constructor takes an element of <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">&#945;</span> <span class="pre">n</span></code> and returns an element of <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">&#945;</span> <span class="pre">(succ</span> <span class="pre">n)</span></code>, thereby using an element of one member of the family to build an element of another.</p>
<p>A more exotic example is given by the definition of the equality type in Lean:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Anamespace%20hidden%0A%0A--%20BEGIN%0Ainductive%20eq%20%7B%CE%B1%20%3A%20Sort%20u%7D%20(a%20%3A%20%CE%B1)%20%3A%20%CE%B1%20%E2%86%92%20Prop%0A%7C%20refl%20%5B%5D%20%3A%20eq%20a%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">refl</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
</div><p>For each fixed <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">:</span> <span class="pre">Sort</span> <span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, this definition constructs a family of types <code class="docutils literal notranslate"><span class="pre">eq</span> <span class="pre">a</span> <span class="pre">x</span></code>, indexed by <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>. Notably, however, there is only one constructor, <code class="docutils literal notranslate"><span class="pre">refl</span></code>, which is an element of <code class="docutils literal notranslate"><span class="pre">eq</span> <span class="pre">a</span> <span class="pre">a</span></code>, and the square brackets after the constructor tell Lean to make the argument to <code class="docutils literal notranslate"><span class="pre">refl</span></code> explicit. Intuitively, the only way to construct a proof of <code class="docutils literal notranslate"><span class="pre">eq</span> <span class="pre">a</span> <span class="pre">x</span></code> is to use reflexivity, in the case where <code class="docutils literal notranslate"><span class="pre">x</span></code> is <code class="docutils literal notranslate"><span class="pre">a</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">eq</span> <span class="pre">a</span> <span class="pre">a</span></code> is the only inhabited type in the family of types <code class="docutils literal notranslate"><span class="pre">eq</span> <span class="pre">a</span> <span class="pre">x</span></code>. The elimination principle generated by Lean is as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universes%20u%20v%0A%0A%23check%20(%40eq.rec_on%20%3A%0A%20%20%CE%A0%20%7B%CE%B1%20%3A%20Sort%20u%7D%20%7Ba%20%3A%20%CE%B1%7D%20%7BC%20%3A%20%CE%B1%20%E2%86%92%20Sort%20v%7D%20%7Bb%20%3A%20%CE%B1%7D%2C%0A%20%20%20%20a%20%3D%20b%20%E2%86%92%20C%20a%20%E2%86%92%20C%20b)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universes</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="n">v</span>

<span class="k">#check</span><span class="w"> </span><span class="o">(</span><span class="bp">@</span><span class="n">eq.rec_on</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="bp">&#928;</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Sort</span><span class="w"> </span><span class="n">v</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">},</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div><p>It is a remarkable fact that all the basic axioms for equality follow from the constructor, <code class="docutils literal notranslate"><span class="pre">refl</span></code>, and the eliminator, <code class="docutils literal notranslate"><span class="pre">eq.rec_on</span></code>. The definition of equality is atypical, however; see the discussion in the next section.</p>
<p>The recursor <code class="docutils literal notranslate"><span class="pre">eq.rec_on</span></code> is also used to define substitution:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Auniverse%20u%0A%0Ainductive%20eq%20%7B%CE%B1%20%3A%20Type%20u%7D%20(a%20%3A%20%CE%B1)%20%3A%20%CE%B1%20%E2%86%92%20Prop%0A%7C%20refl%20%5B%5D%20%3A%20eq%20a%0A%0A--%20BEGIN%0A%40%5Belab_as_eliminator%5D%0Atheorem%20subst%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7Ba%20b%20%3A%20%CE%B1%7D%20%7Bp%20%3A%20%CE%B1%20%E2%86%92%20Prop%7D%0A%20%20(h%E2%82%81%20%3A%20eq%20a%20b)%20(h%E2%82%82%20%3A%20p%20a)%20%3A%20p%20b%20%3A%3D%0Aeq.rec%20h%E2%82%82%20h%E2%82%81%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">@[</span><span class="n">elab_as_eliminator</span><span class="kd">]</span>
<span class="kd">theorem</span><span class="w"> </span><span class="n">subst</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span><span class="o">}</span>
<span class="w">  </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span>
<span class="n">eq.rec</span><span class="w"> </span><span class="n">h&#8322;</span><span class="w"> </span><span class="n">h&#8321;</span>
</pre></div>
</div>
</div><p>Using the recursor with <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>, we may assume <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are the same, in which case, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">a</span></code> are the same. The definition of <code class="docutils literal notranslate"><span class="pre">subst</span></code> is marked with an elaboration hint, as described in <a class="reference internal" href="interacting_with_lean.html#elaboration-hints"><span class="std std-numref">Section 6.10</span></a>.</p>
<p>It is not hard to prove that <code class="docutils literal notranslate"><span class="pre">eq</span></code> is symmetric and transitive. In the following example, we prove <code class="docutils literal notranslate"><span class="pre">symm</span></code> and leave as exercise the theorems <code class="docutils literal notranslate"><span class="pre">trans</span></code> and <code class="docutils literal notranslate"><span class="pre">congr</span></code> (congruence).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20hidden%0Auniverse%20u%0A%0Ainductive%20eq%20%7B%CE%B1%20%3A%20Type%20u%7D%20(a%20%3A%20%CE%B1)%20%3A%20%CE%B1%20%E2%86%92%20Prop%0A%7C%20refl%20%5B%5D%20%3A%20eq%20a%0A%0A%40%5Belab_as_eliminator%5D%0Atheorem%20subst%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7Ba%20b%20%3A%20%CE%B1%7D%20%7BP%20%3A%20%CE%B1%20%E2%86%92%20Prop%7D%0A%20%20(h%E2%82%81%20%3A%20eq%20a%20b)%20(h%E2%82%82%20%3A%20P%20a)%20%3A%20P%20b%20%3A%3D%0Aeq.rec%20h%E2%82%82%20h%E2%82%81%0A%0A%0A--%20BEGIN%0Atheorem%20symm%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7Ba%20b%20%3A%20%CE%B1%7D%20(h%20%3A%20eq%20a%20b)%20%3A%20eq%20b%20a%20%3A%3D%0Asubst%20h%20(eq.refl%20a)%0A%0Atheorem%20trans%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7Ba%20b%20c%20%3A%20%CE%B1%7D%0A%20%20(h%E2%82%81%20%3A%20eq%20a%20b)%20(h%E2%82%82%20%3A%20eq%20b%20c)%20%3A%20eq%20a%20c%20%3A%3D%0Asorry%0A%0Atheorem%20congr%20%7B%CE%B1%20%CE%B2%20%3A%20Type%20u%7D%20%7Ba%20b%20%3A%20%CE%B1%7D%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2)%0A%20%20(h%20%3A%20eq%20a%20b)%20%3A%20eq%20(f%20a)%20(f%20b)%20%3A%3D%0Asorry%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">symm</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span>
<span class="n">subst</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">(</span><span class="n">eq.refl</span><span class="w"> </span><span class="n">a</span><span class="o">)</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">trans</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span>
<span class="w">  </span><span class="o">(</span><span class="n">h&#8321;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">h&#8322;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">theorem</span><span class="w"> </span><span class="n">congr</span><span class="w"> </span><span class="o">{</span><span class="n">&#945;</span><span class="w"> </span><span class="n">&#946;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">}</span><span class="w"> </span><span class="o">{</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">&#946;</span><span class="o">)</span>
<span class="w">  </span><span class="o">(</span><span class="n">h</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
</div><p>In the type theory literature, there are further generalizations of inductive definitions, for example, the principles of <em>induction-recursion</em> and <em>induction-induction</em>. These are not supported by Lean.</p>
</section>
<section id="axiomatic-details">
<h2><span class="section-number">7.8. </span>Axiomatic Details<a class="headerlink" href="#axiomatic-details" title="Link to this heading">&#182;</a></h2>
<p>We have described inductive types and their syntax through examples. This section provides additional information for those interested in the axiomatic foundations.</p>
<p>We have seen that the constructor to an inductive type takes <em>parameters</em> &#8212; intuitively, the arguments that remain fixed throughout the inductive construction &#8212; and <em>indices</em>, the arguments parameterizing the family of types that is simultaneously under construction. Each constructor should have a Pi type, where the argument types are built up from previously defined types, the parameter and index types, and the inductive family currently being defined. The requirement is that if the latter is present at all, it occurs only <em>strictly positively</em>. This means simply that any argument to the constructor in which it occurs is a Pi type in which the inductive type under definition occurs only as the resulting type, where the indices are given in terms of constants and previous arguments.</p>
<p>Since an inductive type lives in <code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">u</span></code> for some <code class="docutils literal notranslate"><span class="pre">u</span></code>, it is reasonable to ask <em>which</em> universe levels <code class="docutils literal notranslate"><span class="pre">u</span></code> can be instantiated to. Each constructor <code class="docutils literal notranslate"><span class="pre">c</span></code> in the definition of a family <code class="docutils literal notranslate"><span class="pre">C</span></code> of inductive types is of the form</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>c : &#928; (a : &#945;) (b : &#946;[a]), C a p[a,b]
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a</span></code> is a sequence of data type parameters, <code class="docutils literal notranslate"><span class="pre">b</span></code> is the sequence of arguments to the constructors, and <code class="docutils literal notranslate"><span class="pre">p[a,</span> <span class="pre">b]</span></code> are the indices, which determine which element of the inductive family the construction inhabits. (Note that this description is somewhat misleading, in that the arguments to the constructor can appear in any order as long as the dependencies make sense.) The constraints on the universe level of <code class="docutils literal notranslate"><span class="pre">C</span></code> fall into two cases, depending on whether or not the inductive type is specified to land in <code class="docutils literal notranslate"><span class="pre">Prop</span></code> (that is, <code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">0</span></code>).</p>
<p>Let us first consider the case where the inductive type is <em>not</em> specified to land in <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. Then the universe level <code class="docutils literal notranslate"><span class="pre">u</span></code> is constrained to satisfy the following:</p>
<blockquote>
<div><p>For each constructor <code class="docutils literal notranslate"><span class="pre">c</span></code> as above, and each <code class="docutils literal notranslate"><span class="pre">&#946;k[a]</span></code> in the sequence <code class="docutils literal notranslate"><span class="pre">&#946;[a]</span></code>, if <code class="docutils literal notranslate"><span class="pre">&#946;k[a]</span> <span class="pre">:</span> <span class="pre">Sort</span> <span class="pre">v</span></code>, we have <code class="docutils literal notranslate"><span class="pre">u</span></code> &#8805; <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</div></blockquote>
<p>In other words, the universe level <code class="docutils literal notranslate"><span class="pre">u</span></code> is required to be at least as large as the universe level of each type that represents an argument to a constructor.</p>
<p>When the inductive type is specified to land in <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, there are no constraints on the universe levels of the constructor arguments. But these universe levels do have a bearing on the elimination rule. Generally speaking, for an inductive type in <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, the motive of the elimination rule is required to be in <code class="docutils literal notranslate"><span class="pre">Prop</span></code>.</p>
<p>There is an exception to this last rule: we are allowed to eliminate from an inductively defined <code class="docutils literal notranslate"><span class="pre">Prop</span></code> to an arbitrary <code class="docutils literal notranslate"><span class="pre">Sort</span></code> when there is only one constructor and each constructor argument is either in <code class="docutils literal notranslate"><span class="pre">Prop</span></code> or an index. The intuition is that in this case the elimination does not make use of any information that is not already given by the mere fact that the type of argument is inhabited. This special case is known as <em>singleton elimination</em>.</p>
<p>We have already seen singleton elimination at play in applications of <code class="docutils literal notranslate"><span class="pre">eq.rec</span></code>, the eliminator for the inductively defined equality type. We can use an element <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">eq</span> <span class="pre">a</span> <span class="pre">b</span></code> to cast an element <code class="docutils literal notranslate"><span class="pre">t'</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">b</span></code> even when <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">b</span></code> are arbitrary types, because the cast does not produce new data; it only reinterprets the data we already have. Singleton elimination is also used with heterogeneous equality and well-founded recursion, which will be discussed in a later chapter.</p>
</section>
<section id="mutual-and-nested-inductive-types">
<span id="id4"></span><h2><span class="section-number">7.9. </span>Mutual and Nested Inductive Types<a class="headerlink" href="#mutual-and-nested-inductive-types" title="Link to this heading">&#182;</a></h2>
<p>We now consider two generalizations of inductive types that are often useful, which Lean supports by &#8220;compiling&#8221; them down to the more primitive kinds of inductive types described above. In other words, Lean parses the more general definitions, defines auxiliary inductive types based on them, and then uses the auxiliary types to define the ones we really want. Lean&#8217;s equation compiler, described in the next chapter, is needed to make use of these types effectively. Nonetheless, it makes sense to describe the declarations here, because they are straightforward variations on ordinary inductive definitions.</p>
<p>First, Lean supports <em>mutually defined</em> inductive types. The idea is that we can define two (or more) inductive types at the same time, where each one refers to the other(s).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=mutual%20inductive%20even%2C%20odd%0Awith%20even%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20even_zero%20%3A%20even%200%0A%7C%20even_succ%20%3A%20%E2%88%80%20n%2C%20odd%20n%20%E2%86%92%20even%20(n%20%2B%201)%0Awith%20odd%20%3A%20%E2%84%95%20%E2%86%92%20Prop%0A%7C%20odd_succ%20%3A%20%E2%88%80%20n%2C%20even%20n%20%E2%86%92%20odd%20(n%20%2B%201)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">mutual</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">even</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span>
<span class="k">with</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">even_zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="mi">0</span>
<span class="bp">|</span><span class="w"> </span><span class="n">even_succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="k">with</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#8469;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="kt">Prop</span>
<span class="bp">|</span><span class="w"> </span><span class="n">odd_succ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">&#8704;</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div><p>In this example, two types are defined simultaneously: a natural number <code class="docutils literal notranslate"><span class="pre">n</span></code> is <code class="docutils literal notranslate"><span class="pre">even</span></code> if it is <code class="docutils literal notranslate"><span class="pre">0</span></code> or one more than an <code class="docutils literal notranslate"><span class="pre">odd</span></code> number, and <code class="docutils literal notranslate"><span class="pre">odd</span></code> if it is one more than an even number. Under the hood, this definition is compiled down to a single inductive type with an index <code class="docutils literal notranslate"><span class="pre">i</span></code> in a two-valued type (such as <code class="docutils literal notranslate"><span class="pre">bool</span></code>), where <code class="docutils literal notranslate"><span class="pre">i</span></code> encodes which of <code class="docutils literal notranslate"><span class="pre">even</span></code> or <code class="docutils literal notranslate"><span class="pre">odd</span></code> is intended. In the exercises below, you are asked to spell out the details.</p>
<p>A mutual inductive definition can also be used to define the notation of a finite tree with nodes labeled by elements of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0Amutual%20inductive%20tree%2C%20list_tree%20(%CE%B1%20%3A%20Type%20u)%0Awith%20tree%20%3A%20Type%20u%0A%7C%20node%20%3A%20%CE%B1%20%E2%86%92%20list_tree%20%E2%86%92%20tree%0Awith%20list_tree%20%3A%20Type%20u%0A%7C%20nil%20%7B%7D%20%3A%20list_tree%0A%7C%20cons%20%20%20%20%3A%20tree%20%E2%86%92%20list_tree%20%E2%86%92%20list_tree" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span><span class="w"> </span><span class="n">u</span>

<span class="kd">mutual</span><span class="w"> </span><span class="kd">inductive</span><span class="w"> </span><span class="n">tree</span><span class="o">,</span><span class="w"> </span><span class="n">list_tree</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span>
<span class="k">with</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span>
<span class="bp">|</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list_tree</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">tree</span>
<span class="k">with</span><span class="w"> </span><span class="n">list_tree</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span>
<span class="bp">|</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">{}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list_tree</span>
<span class="bp">|</span><span class="w"> </span><span class="n">cons</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list_tree</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list_tree</span>
</pre></div>
</div>
</div><p>With this definition, one can construct an element of <code class="docutils literal notranslate"><span class="pre">tree</span> <span class="pre">&#945;</span></code> by giving an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> together with a list of subtrees, possibly empty. The list of subtrees is represented by the type <code class="docutils literal notranslate"><span class="pre">list_tree</span> <span class="pre">&#945;</span></code>, which is defined to be either the empty list, <code class="docutils literal notranslate"><span class="pre">nil</span></code>, or the <code class="docutils literal notranslate"><span class="pre">cons</span></code> of a tree and an element of <code class="docutils literal notranslate"><span class="pre">list_tree</span> <span class="pre">&#945;</span></code>.</p>
<p>This definition is inconvenient to work with, however. It would be much nicer if the list of subtrees were given by the type <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">(tree</span> <span class="pre">&#945;)</span></code>, especially since Lean&#8217;s library contains a number of functions and theorems for working with lists. One can show that the type <code class="docutils literal notranslate"><span class="pre">list_tree</span> <span class="pre">&#945;</span></code> is <em>isomorphic</em> to <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">(tree</span> <span class="pre">&#945;)</span></code>, but translating results back and forth along this isomorphism is tedious.</p>
<p>In fact, Lean allows us to define the inductive type we really want:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0A--%20BEGIN%0Ainductive%20tree%20(%CE%B1%20%3A%20Type%20u)%0A%7C%20mk%20%3A%20%CE%B1%20%E2%86%92%20list%20tree%20%E2%86%92%20tree%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">(</span><span class="n">&#945;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="n">u</span><span class="o">)</span>
<span class="bp">|</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">&#945;</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">tree</span>
</pre></div>
</div>
</div><p>This is known as a <em>nested</em> inductive type. It falls outside the strict specification of an inductive type given in the last section because <code class="docutils literal notranslate"><span class="pre">tree</span></code> does not occur strictly positively among the arguments to <code class="docutils literal notranslate"><span class="pre">mk</span></code>, but, rather, nested inside the <code class="docutils literal notranslate"><span class="pre">list</span></code> type constructor. Under the hood, Lean compiles this down to the mutual inductive type described above, which, in turn, is compiled down to an ordinary inductive type. Lean then automatically builds the isomorphism between <code class="docutils literal notranslate"><span class="pre">list_tree</span> <span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">(tree</span>&#160; <span class="pre">&#945;)</span></code>, and defines the constructors for <code class="docutils literal notranslate"><span class="pre">tree</span></code> in terms of the isomorphism.</p>
<p>The types of the constructors for mutual and nested inductive types can be read off from the definitions. Defining functions <em>from</em> such types is more complicated, because these also have to be compiled down to more basic operations, making use of the primitive recursors that are associated to the inductive types that are declared under the hood. Lean does its best to hide the details from users, allowing them to use the equation compiler, described in the next section, to define such functions in natural ways.</p>
</section>
<section id="exercises">
<h2><span class="section-number">7.10. </span>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">&#182;</a></h2>
<ol class="arabic">
<li><p>Try defining other operations on the natural numbers, such as multiplication, the predecessor function (with <code class="docutils literal notranslate"><span class="pre">pred</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code>), truncated subtraction (with <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">0</span></code> when <code class="docutils literal notranslate"><span class="pre">m</span></code> is greater than or equal to <code class="docutils literal notranslate"><span class="pre">n</span></code>), and exponentiation. Then try proving some of their basic properties, building on the theorems we have already
proved.</p>
<p>Since many of these are already defined in Lean&#8217;s core library, you should work within a namespace named <code class="docutils literal notranslate"><span class="pre">hide</span></code>, or something like that, in order to avoid name clashes.</p>
</li>
<li><p>Define some operations on lists, like a <code class="docutils literal notranslate"><span class="pre">length</span></code> function or the <code class="docutils literal notranslate"><span class="pre">reverse</span></code> function. Prove some properties, such as the following:</p>
<ol class="loweralpha simple">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">(s</span> <span class="pre">++</span> <span class="pre">t)</span> <span class="pre">=</span> <span class="pre">length</span> <span class="pre">s</span> <span class="pre">+</span> <span class="pre">length</span> <span class="pre">t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">(reverse</span> <span class="pre">t)</span> <span class="pre">=</span> <span class="pre">length</span> <span class="pre">t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">(reverse</span> <span class="pre">t)</span> <span class="pre">=</span> <span class="pre">t</span></code></p></li>
</ol>
</li>
<li><p>Define an inductive data type consisting of terms built up from the following constructors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">n</span></code>, a constant denoting the natural number <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">n</span></code>, a variable, numbered <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plus</span> <span class="pre">s</span> <span class="pre">t</span></code>, denoting the sum of <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">times</span> <span class="pre">s</span> <span class="pre">t</span></code>, denoting the product of <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
</ul>
<p>Recursively define a function that evaluates any such term with respect to an assignment of values to the variables.</p>
</li>
<li><p>Similarly, define the type of propositional formulas, as well as functions on the type of such formulas: an evaluation function, functions that measure the complexity of a formula, and a function that substitutes another formula for a given variable.</p></li>
<li><p>Simulate the mutual inductive definition of <code class="docutils literal notranslate"><span class="pre">even</span></code> and <code class="docutils literal notranslate"><span class="pre">odd</span></code> described in <a class="reference internal" href="#mutual-and-nested-inductive-types"><span class="std std-numref">Section 7.9</span></a> with an ordinary inductive type, using an index to encode the choice between them in the target type.</p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean 3 (outdated)</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositions_and_proofs.html">3. Propositions and Proofs</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. Inductive Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#enumerated-types">7.1. Enumerated Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructors-with-arguments">7.2. Constructors with Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inductively-defined-propositions">7.3. Inductively Defined Propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-the-natural-numbers">7.4. Defining the Natural Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#other-recursive-data-types">7.5. Other Recursive Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tactics-for-inductive-types">7.6. Tactics for Inductive Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inductive-families">7.7. Inductive Families</a></li>
<li class="toctree-l2"><a class="reference internal" href="#axiomatic-details">7.8. Axiomatic Details</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mutual-and-nested-inductive-types">7.9. Mutual and Nested Inductive Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">7.10. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/inductive_types.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>