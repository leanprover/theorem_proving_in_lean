<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1. Introduction &#8212; Theorem Proving in Lean 3 (outdated) 3.23.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=5ca61e87" />
    <script src="_static/documentation_options.js?v=5de50469"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Dependent Type Theory" href="dependent_type_theory.html" />
    <link rel="prev" title="Theorem Proving in Lean 3 (outdated)" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="introduction">
<span id="id1"></span><h1><span class="section-number">1. </span>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">&#182;</a></h1>
<section id="computers-and-theorem-proving">
<h2><span class="section-number">1.1. </span>Computers and Theorem Proving<a class="headerlink" href="#computers-and-theorem-proving" title="Link to this heading">&#182;</a></h2>
<p><em>Formal verification</em> involves the use of logical and computational methods to establish claims that are expressed in precise mathematical terms. These can include ordinary mathematical theorems, as well as claims that pieces of hardware or software, network protocols, and mechanical and hybrid systems meet their specifications. In practice, there is not a sharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal verification requires describing hardware and software systems in mathematical terms, at which point establishing claims as to their correctness becomes a form of theorem proving. Conversely, the proof of a mathematical theorem may require a lengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what it is supposed to do.</p>
<p>The gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic show most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of foundational systems. With this reduction, there are two ways that a computer can help establish a claim: it can help find a proof in the first place, and it can help verify that a purported proof is correct.</p>
<p><em>Automated theorem proving</em> focuses on the &#8220;finding&#8221; aspect. Resolution theorem provers, tableau theorem provers, fast satisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and first-order logic. Other systems provide search procedures and decision procedures for specific languages and domains, such as linear or nonlinear expressions over the integers or the real numbers. Architectures like SMT (&#8220;satisfiability modulo theories&#8221;) combine domain-general search methods with domain-specific procedures. Computer algebra systems and specialized mathematical software packages provide means of carrying out mathematical computations, establishing mathematical bounds, or finding mathematical objects. A calculation can be viewed as a proof as well, and these systems, too, help establish mathematical claims.</p>
<p>Automated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness. Such systems can have bugs, and it can be difficult to ensure that the results they deliver are correct. In contrast, <em>interactive theorem proving</em> focuses on the &#8220;verification&#8221; aspect of theorem proving, requiring that every claim is supported by a proof in a suitable axiomatic foundation. This sets a very high standard: every rule of inference and every step of a calculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and rules. In fact, most such systems provide fully elaborated &#8220;proof objects&#8221; that can be communicated to other systems and checked independently. Constructing such proofs typically requires much more input and interaction from users, but it allows us to obtain deeper and more complex proofs.</p>
<p>The <em>Lean Theorem Prover</em> aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify claims in both domains.</p>
<p>Lean&#8217;s underlying logic has a computational interpretation, and Lean can be viewed equally well as a programming language. More to the point, it can be viewed as a system for writing programs with a precise semantics, as well as reasoning about the functions that the programs compute. Lean also has mechanisms to serve as its own <em>metaprogramming language</em>, which means that one can implement automation and extend the functionality of Lean using Lean itself. These aspects of Lean are explored in a companion tutorial to this one, <a class="reference external" href="https://leanprover.github.io/programming_in_lean">Programming in Lean</a>, though computational aspects of the system will make an appearance here.</p>
</section>
<section id="about-lean">
<h2><span class="section-number">1.2. </span>About Lean<a class="headerlink" href="#about-lean" title="Link to this heading">&#182;</a></h2>
<p>The <em>Lean</em> project was launched by Leonardo de Moura at Microsoft Research Redmond in 2013. It is an ongoing, long-term effort, and much of the potential for automation will be realized only gradually over time. Lean is released under the Apache 2.0 license, a permissive open source license that permits others to use and extend the code and mathematical libraries freely.</p>
<p>There are currently two ways to use Lean. The first is to run it from the web: a Javascript version of Lean, a standard library of definitions and theorems, and an editor are actually downloaded to your browser and run there. This provides a quick and convenient way to begin experimenting with the system.</p>
<p>The second way to use Lean is to install and run it natively on your computer. The native version is much faster than the web version, and is more flexible in other ways, too. Special modes in Visual Studio Code (VS Code for short) and Emacs offer powerful support for writing and debugging proofs, and is much better suited for serious use. The source code, and instructions for building Lean, are available at <a class="reference external" href="https://github.com/leanprover/lean/">https://github.com/leanprover/lean/</a>.</p>
<p>This tutorial describes an old version of Lean, known as Lean 3. The current version of Lean is Lean 4 and up-to-date documentation resources can be found at <a class="reference external" href="https://lean-lang.org/documentation/">https://lean-lang.org/documentation/</a>. A prior version, Lean 2, had special support for homotopy type theory. You can find Lean 2 and the HoTT library at <a class="reference external" href="https://github.com/leanprover/lean2/">https://github.com/leanprover/lean2/</a>. The tutorial for that version of Lean is at <a class="reference external" href="https://leanprover.github.io/tutorial/">https://leanprover.github.io/tutorial/</a>.</p>
</section>
<section id="about-this-book">
<h2><span class="section-number">1.3. </span>About this Book<a class="headerlink" href="#about-this-book" title="Link to this heading">&#182;</a></h2>
<p>This book is designed to teach you to develop and verify proofs in Lean. Much of the background information you will need in order to do this is not specific to Lean at all. To start with, we will explain the logical system that Lean is based on, a version of <em>dependent type theory</em> that is powerful enough to prove almost any conventional mathematical theorem, and expressive enough to do it in a natural way. More specifically, Lean is based on a version of a system known as the <em>Calculus of Constructions</em> <a class="reference internal" href="#cohu88" id="id2"><span>[CoHu88]</span></a> with <em>inductive types</em> <a class="reference internal" href="#dybj94" id="id3"><span>[Dybj94]</span></a>. We will explain not only how to define mathematical objects and express mathematical assertions in dependent type theory, but also how to use it as a language for writing proofs.</p>
<p>Because fully detailed axiomatic proofs are so complicated, the challenge of theorem proving is to have the computer fill in as many of the details as possible. We will describe various methods to support this in dependent type theory. For example, we will discuss term rewriting, and Lean&#8217;s automated methods for simplifying terms and expressions automatically. Similarly, we will discuss methods of <em>elaboration</em> and <em>type inference</em>, which can be used to support flexible forms of algebraic reasoning.</p>
<p>Finally, of course, we will discuss features that are specific to Lean, including the language with which you can communicate with the system, and the mechanisms Lean offers for managing complex theories and data.</p>
<p>Throughout the text you will find examples of Lean code like the one below:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20BEGIN%0Atheorem%20and_commutative%20(p%20q%20%3A%20Prop)%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Aassume%20hpq%20%3A%20p%20%E2%88%A7%20q%2C%0Ahave%20hp%20%3A%20p%2C%20from%20and.left%20hpq%2C%0Ahave%20hq%20%3A%20q%2C%20from%20and.right%20hpq%2C%0Ashow%20q%20%E2%88%A7%20p%2C%20from%20and.intro%20hq%20hp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span><span class="w"> </span><span class="n">and_commutative</span><span class="w"> </span><span class="o">(</span><span class="n">p</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Prop</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8594;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:=</span>
<span class="k">assume</span><span class="w"> </span><span class="n">hpq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">q</span><span class="o">,</span>
<span class="k">have</span><span class="w"> </span><span class="n">hp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.left</span><span class="w"> </span><span class="n">hpq</span><span class="o">,</span>
<span class="k">have</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">q</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.right</span><span class="w"> </span><span class="n">hpq</span><span class="o">,</span>
<span class="k">show</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="bp">&#8743;</span><span class="w"> </span><span class="n">p</span><span class="o">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">and.intro</span><span class="w"> </span><span class="n">hq</span><span class="w"> </span><span class="n">hp</span>
</pre></div>
</div>
</div><p>If you are reading the book online, you will see a button that reads &#8220;try it!&#8221; Pressing the button opens up a tab with a Lean editor, and copies the example with enough surrounding context to make the example compile correctly. You can type things into the editor and modify the examples, and Lean will check the results and provide feedback continuously as you type. We recommend running the examples and experimenting with the code on your own as you work through the chapters that follow.</p>
</section>
<section id="acknowledgments">
<h2><span class="section-number">1.4. </span>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Link to this heading">&#182;</a></h2>
<p>This tutorial is an open access project maintained on Github. Many people have contributed to the effort, providing corrections, suggestions, examples, and text. We are grateful to Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner, Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey, Sebastian Ullrich, Floris van Doorn, Daniel Velleman, and Th&#233;o Zimmerman for their contributions, and we apologize to those whose names we have inadvertently omitted.</p>
<div role="list" class="citation-list">
<div class="citation" id="cohu88" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">CoHu88</a><span class="fn-bracket">]</span></span>
<p>Thierry Coquand and Gerard Huet. The calculus of constructions. Inf. Comput., 76(2-3):95&#8211;120, February 1988.</p>
</div>
<div class="citation" id="dybj94" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Dybj94</a><span class="fn-bracket">]</span></span>
<p>Peter Dybjer. Inductive families. Formal Asp. Comput., 6(4):440&#8211;465, 1994.</p>
</div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean 3 (outdated)</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#computers-and-theorem-proving">1.1. Computers and Theorem Proving</a></li>
<li class="toctree-l2"><a class="reference internal" href="#about-lean">1.2. About Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#about-this-book">1.3. About this Book</a></li>
<li class="toctree-l2"><a class="reference internal" href="#acknowledgments">1.4. Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositions_and_proofs.html">3. Propositions and Proofs</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/introduction.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>